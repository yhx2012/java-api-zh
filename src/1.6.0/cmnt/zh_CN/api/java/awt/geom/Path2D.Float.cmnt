<!-- BEGIN KEY -->
public static class java.awt.geom.Path2D.Float extends java.awt.geom.Path2D implements java.io.Serializable
<!-- END KEY -->
<!-- BEGIN DATA -->
{@code Float} 类定义了一条几何路径，它具有以单精度浮点值形式存储的坐标。

@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.geom.Path2D.Float()
<!-- END KEY -->
<!-- BEGIN DATA -->
根据 {@link #WIND_NON_ZERO} 的默认旋绕规则构造一个新的单精度空 {@code Path2D} 对象。

@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.geom.Path2D.Float(int rule)
<!-- END KEY -->
<!-- BEGIN DATA -->
根据指定旋绕规则构造一个新的单精度空 {@code Path2D} 对象，以控制需要定义路径内部的操作。

@param rule 旋绕规则
@see #WIND_EVEN_ODD
@see #WIND_NON_ZERO
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.geom.Path2D.Float(int rule, int initialCapacity)
<!-- END KEY -->
<!-- BEGIN DATA -->
根据指定旋绕规则和指定初始容量构造一个新的单精度空 {@code Path2D} 对象，以存储路径段。此数是对将添加到路径中的路径段数量的初始猜测，但存储量可以根据需要扩展，以存储添加的所有路径段。

@param rule 旋绕规则
@param initialCapacity 对路径中路径段数量的估计
@see #WIND_EVEN_ODD
@see #WIND_NON_ZERO
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.geom.Path2D.Float(Shape s)
<!-- END KEY -->
<!-- BEGIN DATA -->
根据任意 {@link Shape} 对象构造一个新的单精度 {@code Path2D} 对象。此路径的所有初始几何形状和旋绕规则均取自指定的 {@code Shape} 对象。

@param s 指定的 {@code Shape} 对象
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.geom.Path2D.Float(Shape s, AffineTransform at)
<!-- END KEY -->
<!-- BEGIN DATA -->
根据 {@link AffineTransform} 对象变换的任意 {@link Shape} 对象构造一个新的单精度 {@code Path2D} 对象。此路径的所有初始几何形状和旋绕规则均取自指定的 {@code Shape} 对象，并由指定的 {@code AffineTransform} 对象变换。

@param s 指定的 {@code Shape} 对象
@param at 指定的 {@code AffineTransform} 对象
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final synchronized void java.awt.geom.Path2D.Float.moveTo(double x, double y)
<!-- END KEY -->
<!-- BEGIN DATA -->
{@inheritDoc}
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final synchronized void java.awt.geom.Path2D.Float.moveTo(float x, float y)
<!-- END KEY -->
<!-- BEGIN DATA -->
通过移动到指定的坐标（以 float 精度指定），将一个点添加到路径中。
 <p>
此方法提供了基本 {@code Path2D} 类上的双精度 {@code moveTo()} 方法的单精度变体。

@param x 指定的 X 坐标
@param y 指定的 Y 坐标
@see Path2D#moveTo
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final synchronized void java.awt.geom.Path2D.Float.lineTo(double x, double y)
<!-- END KEY -->
<!-- BEGIN DATA -->
{@inheritDoc}
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final synchronized void java.awt.geom.Path2D.Float.lineTo(float x, float y)
<!-- END KEY -->
<!-- BEGIN DATA -->
通过绘制一条从当前坐标到指定新坐标（以 float 精度指定）的直线，将一个点添加到路径中。
 <p>
此方法提供了基本 {@code Path2D} 类上的双精度 {@code lineTo()} 方法的单精度变体。

@param x 指定的 X 坐标
@param y 指定的 Y 坐标
@see Path2D#lineTo
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final synchronized void java.awt.geom.Path2D.Float.quadTo(double x1, double y1, double x2, double y2)
<!-- END KEY -->
<!-- BEGIN DATA -->
{@inheritDoc}
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final synchronized void java.awt.geom.Path2D.Float.quadTo(float x1, float y1, float x2, float y2)
<!-- END KEY -->
<!-- BEGIN DATA -->
通过绘制与当前坐标和指定坐标 {@code (x2,y2)} 都相交的二次曲线，并将指定点 {@code (x1,y1)} 用作二次曲线参数控制点，可以将由两个新点定义的曲线段添加到路径中。所有坐标都以 float 精度指定。
 <p>
此方法提供了基本 {@code Path2D} 类上的双精度 {@code quadTo()} 方法的单精度变体。

@param x1 二次曲线控制点的 X 坐标
@param y1 二次曲线控制点的 Y 坐标
@param x2 终端点的 X 坐标
@param y2 终端点的 Y 坐标
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final synchronized void java.awt.geom.Path2D.Float.curveTo(double x1, double y1, double x2, double y2, double x3, double y3)
<!-- END KEY -->
<!-- BEGIN DATA -->
{@inheritDoc}
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final synchronized void java.awt.geom.Path2D.Float.curveTo(float x1, float y1, float x2, float y2, float x3, float y3)
<!-- END KEY -->
<!-- BEGIN DATA -->
通过绘制与当前坐标和指定坐标 {@code (x3,y3)} 都相交的 B&eacute;zier 曲线，并将指定点 {@code (x1,y1)} 和 {@code (x2,y2)} 用作 B&eacute;zier 曲线的控制点，可以将由三个新点定义的曲线段添加到路径中。所有坐标都以 float 精度指定。
 <p>
此方法提供了基本 {@code Path2D} 类上的双精度 {@code curveTo()} 方法的单精度变体。

@param x1 第一个 B&eacute;zier 控制点的 X 坐标
@param y1 第一个 B&eacute;zier 控制点的 Y 坐标
@param x2 第二个 B&eacute;zier 控制点的 X 坐标
@param y2 第二个 B&eacute;zier 控制点的 Y 坐标
@param x3 终端点的 X 坐标
@param y3 终端点的 Y 坐标
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.awt.geom.Path2D.Float.append(PathIterator pi, boolean connect)
<!-- END KEY -->
<!-- BEGIN DATA -->
{@inheritDoc}
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.awt.geom.Path2D.Float.transform(AffineTransform at)
<!-- END KEY -->
<!-- BEGIN DATA -->
{@inheritDoc}
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final synchronized java.awt.geom.Rectangle2D java.awt.geom.Path2D.Float.getBounds2D()
<!-- END KEY -->
<!-- BEGIN DATA -->
{@inheritDoc}
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.geom.PathIterator java.awt.geom.Path2D.Float.getPathIterator(AffineTransform at)
<!-- END KEY -->
<!-- BEGIN DATA -->
{@inheritDoc}
 <p>
此类的迭代器不是多线程安全的，这意味着该 {@code Path2D} 类不保证对此 {@code Path2D} 对象几何形状所作的修改不影响该几何形状已在处理中的迭代。

@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final java.lang.Object java.awt.geom.Path2D.Float.clone()
<!-- END KEY -->
<!-- BEGIN DATA -->
创建一个与此对象具有相同类的新对象。

@return 此实例的一个副本。
@exception  OutOfMemoryError            如果没有足够的内存。
@see        java.lang.Cloneable
@since      1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
private void java.awt.geom.Path2D.Float.readObject(ObjectInputStream s) throws java.lang.ClassNotFoundException, java.io.IOException
<!-- END KEY -->
<!-- BEGIN DATA -->
从 {@code ObjectInputStream} 中读取默认的可序列化字段，然后显式序列化此路径中存储的路径段。
 <p>
从 1.6 开始，没有默认的可序列化字段。
 <p>
此对象的序列数据是用 writeObject 方法描述的。

@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
private void java.awt.geom.Path2D.Float.writeObject(ObjectOutputStream s) throws java.io.IOException
<!-- END KEY -->
<!-- BEGIN DATA -->
将默认的可序列化字段写入 {@code ObjectOutputStream}，然后显式序列化此路径中存储的路径段。

@serialData <a name="Path2DSerialData"><!-- --></a>
 <ol>
<li>默认的可序列化字段。从 1.6 开始，没有默认的可序列化字段。
<li>后跟一个字节，指示将初始对象的存储类型作为提示 (SERIAL_STORAGE_FLT_ARRAY)。
<li>接着是一个整数，指示应该遵循的路径段数量 (NP)，或者为 -1 ，指示遵循未知数量的路径段。
<li>接着又是一个整数，指示应该遵循的坐标总数 (NC)，或者为 -1，指示遵循未知的坐标数（NC 应该始终是偶数，因为坐标始终以成对的 x,y 形式出现）。
<li>再接着是一个指示旋绕规则（{@link #WIND_EVEN_ODD WIND_EVEN_ODD} 或 {@link #WIND_NON_ZERO WIND_NON_ZERO}）的字节。
<li>再接着是由指示路径段类型的单个字节组成的值的 NP 集合（如果 NP &lt; 0，则值是无限的），后跟表示路径段坐标的一对或多对 float 或 double 值。
<li>最后是指示路径结尾的字节 (SERIAL_PATH_END) 。
 </ol>
 <p>
以下字节值常量用于 {@code Path2D} 对象的序列化形式中：
 <table>
 <tr>
<th>常量名</th>
<th>字节值</th>
<th>后跟</th>
<th>描述</th>
 </tr>
 <tr>
<td>{@code SERIAL_STORAGE_FLT_ARRAY}</td>
<td>0x30</td>
 <td></td>
<td>一个提示，原始 {@code Path2D} 对象以 Java 的 float 数组形式存储于坐标中。</td>
 </tr>
 <tr>
<td>{@code SERIAL_STORAGE_DBL_ARRAY}</td>
<td>0x31</td>
 <td></td>
<td>一个提示，原始 {@code Path2D} 对象以 Java 的 double 数组形式存储于坐标中。</td>
 </tr>
 <tr>
<td>{@code SERIAL_SEG_FLT_MOVETO}</td>
<td>0x40</td>
<td>2 浮点型</td>
<td>后跟一个 {@link #moveTo moveTo} 路径段。</td>
 </tr>
 <tr>
<td>{@code SERIAL_SEG_FLT_LINETO}</td>
<td>0x41</td>
<td>2 浮点型</td>
<td>后跟一个 {@link #lineTo lineTo} 路径段。</td>
 </tr>
 <tr>
<td>{@code SERIAL_SEG_FLT_QUADTO}</td>
<td>0x42</td>
<td>4 浮点型</td>
<td>后跟一个 {@link #quadTo quadTo} 路径段。</td>
 </tr>
 <tr>
<td>{@code SERIAL_SEG_FLT_CUBICTO}</td>
<td>0x43</td>
<td>6 浮点型</td>
<td>后跟一个 {@link #curveTo curveTo} 路径段。</td>
 </tr>
 <tr>
<td>{@code SERIAL_SEG_DBL_MOVETO}</td>
<td>0x50</td>
<td>2 双精度型</td>
<td>后跟一个 {@link #moveTo moveTo} 路径段。</td>
 </tr>
 <tr>
<td>{@code SERIAL_SEG_DBL_LINETO}</td>
<td>0x51</td>
<td>2 双精度型</td>
<td>后跟一个 {@link #lineTo lineTo} 路径段。</td>
 </tr>
 <tr>
<td>{@code SERIAL_SEG_DBL_QUADTO}</td>
<td>0x52</td>
<td>4 双精度型</td>
<td>后跟一个 {@link #curveTo curveTo} 路径段。</td>
 </tr>
 <tr>
<td>{@code SERIAL_SEG_DBL_CUBICTO}</td>
<td>0x53</td>
<td>6 双精度型</td>
<td>后跟一个 {@link #curveTo curveTo} 路径段。</td>
 </tr>
 <tr>
<td>{@code SERIAL_SEG_CLOSE}</td>
<td>0x60</td>
 <td></td>
<td>一个 {@link #closePath closePath} 路径段。</td>
 </tr>
 <tr>
<td>{@code SERIAL_PATH_END}</td>
<td>0x61</td>
 <td></td>
<td>不再有路径段跟在后面。</td>
 </table>

@since 1.6

<!-- END DATA -->
