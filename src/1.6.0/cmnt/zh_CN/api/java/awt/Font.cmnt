<!-- BEGIN KEY -->
public class java.awt.Font extends java.lang.Object implements java.io.Serializable
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>Font</code> 类表示字体，可以使用它以可见方式呈现文本。字体提供将<em>字符</em> 序列映射到<em>字形</em> 序列所需要的信息，以便在 <code>Graphics</code> 对象和 <code>Component</code> 对象上呈现字形序列。
 
<h4>字符和字形</h4>
 
<em>字符</em> 是表示项的符号（如字母、数字或具有抽象意义的标点）。例如，<code>'g'</code>（<font size=-1>G 的拉丁小写字母</font>）是一个字符。
 <p>
<em>字形</em> 是用来呈现字符或字符序列的一种形状。在简单的书写系统（如拉丁文）中，通常一个字形就表示一个字符。但在一般情况下，字符和字形并没有一对一的对应关系。例如，字符 '&aacute;' <font size=-1>A 的带重音符号的拉丁小写字母</font> 可以由两个字形表示：一个是 'a'，一个是 '&acute;'。另一方面，两字符的字符串 &quot;fi&quot; 可以由单个字形 &quot;fi&quot; 连字表示。在复杂的书写系统（如阿拉伯语或南亚和东南亚语言）中，字符与字形之间的关系可能更复杂，涉及到依赖于上下文的字形选择以及字形重排序。字体封装了呈现所选择的字符集所需的字形集，还封装了将字符序列映射到相应的字形序列所需的表。

<h4>物理字体和逻辑字体</h4>

Java Platform 可以区分两种字体：<em>物理</em> 字体和<em>逻辑</em> 字体。
 <p>
<em>物理</em> 字体是实际的字体库，包含字形数据和表，这些数据和表使用字体技术（如 TrueType 或 PostScript Type 1）将字符序列映射到字形序列。Java Platform 的所有实现都支持 TrueType 字体；对其他字体技术的支持是与实现相关的。物理字体可以使用字体名称，如 Helvetica、Palatino、HonMincho 或任意数量的其他字体名称。通常，每种物理字体只支持有限的书写系统集合，例如，只支持拉丁文字符，或者只支持日文和基本拉丁文。可用的物理字体集合随配置的不同而有所不同。要求特定字体的应用程序可以使用 {@link #createFont createFont} 方法来捆绑这些字体，并对其进行实例化。
 <p>
<em>逻辑</em> 字体是由必须受所有 Java 运行时环境支持的 Java 平台所定义的五种字体系列：Serif、SansSerif、Monospaced、Dialog 和 DialogInput。这些逻辑字体不是实际的字体库。此外，由 Java 运行时环境将逻辑字体名称映射到物理字体。映射关系与实现和通常语言环境相关，因此它们提供的外观和规格各不相同。通常，为了覆盖庞大的字符范围，每种逻辑字体名称都映射到几种物理字体。
 <p>
同级的 AWT 组件（如 {@link Label Label} 和 {@link TextField TextField}）只可以使用逻辑字体。
 <p>
有关使用物理字体或逻辑字体的相对优势和劣势的讨论，请参阅 <a href="http://java.sun.com/j2se/corejava/intl/reference/faqs/index.html#desktop-rendering">Internationalization FAQ</a> 文档。

<h4>字体外观和名称</h4>
 
<code>Font</code> 可以有多个外观，如 heavy、medium、oblique、gothic 和 regular。所有这些外观都有相似的排字设计。
 <p>
可以从 <code>Font</code> 对象获得三种不同的名称。<em>逻辑字体名称</em> 只是用来构造字体的名称。<em>字体外观名称</em>，或<em>外观名称</em> 是特定字体外观的名称，如 Helvetica Bold。<em>系列名称</em> 是字体系列的名称，用来确定多种外观（如 Helvetica）的排字设计。
 <p>
<code>Font</code> 类表示字体外观集合中字体外观的实例，字体外观集合位于主机系统的系统资源中。例如，Arial Bold 和 Courier Bold Italic 是字体外观。有几个 <code>Font</code> 对象与字体外观相关，每个对象在大小、样式、变换和字体特征上都有所不同。
<p>
<code>GraphicsEnvironment</code> 类的 {@link GraphicsEnvironment#getAllFonts() getAllFonts} 方法返回系统中所有可用字体外观组成的数组。这些字体外观被作为 <code>Font</code> 对象返回，对象的大小为 1，具有恒等变换和默认字体特征。这些基本字体可以用来派生新的 <code>Font</code> 对象，使之具有变化的大小、样式、变换和字体特征，这些可以通过此类中的 <code>deriveFont</code> 方法实现。

<h4>Font 和 TextAttribute</h4>

 <p><code>Font</code> 支持大多数 <code>TextAttribute</code>。这使得一些操作（如呈现带下划线的文本）变得更方便，因为没必要再显式构造一个 <code>TextLayout</code> 对象。通过使用 <code>TextAttribute</code> 值的 <code>Map</code> 来构造或派生属性，可以在 Font 上设置属性。

 <p>一些 <code>TextAttributes</code> 值是不可序列化的，因此尝试序列化具有这样的值的 <code>Font</code> 实例不会使它们获得序列化。这意味着从这样一个流实现序列化的 Font 不会等同于包含不可序列化属性的原始 Font。这应该是很少出现的一个问题，因为这些属性通常只使用在特殊情况下并且不可能被序列化。

 <ul>
 <li><code>FOREGROUND</code> 和 <code>BACKGROUND</code> 使用 <code>Paint</code> 值。子类 <code>Color</code> 是可序列化的，而 <code>GradientPaint</code> 和 <code>TexturePaint</code> 是不可序列化的。</li>
 <li><code>CHAR_REPLACEMENT</code> 使用 <code>GraphicAttribute</code> 值。子类 <code>ShapeGraphicAttribute</code> 和 <code>ImageGraphicAttribute</code> 是不可序列化的。
</li>
 <li><code>INPUT_METHOD_HIGHLIGHT</code> 使用 <code>InputMethodHighlight</code> 值，它是不可序列化的。请参阅 {@link java.awt.im.InputMethodHighlight}。</li>
 </ul>

 创建 <code>Paint</code> 和 <code>GraphicAttribute</code> 的自定义子类的客户机可以使它们可序列化并避免此问题。使用输入方法高亮显示的客户机可以将这些转换为特定于平台的属性，以便在当前平台上高亮显示它们并在 Font 上设置它们，以此作为解决方法。
</p>

 <p>基于 <code>Map</code> 的构造方法和 <code>deriveFont</code> API 忽略了 FONT 属性，并且没有通过 Font 保留它；如果 FONT 属性可能存在，则应该使用 static {@link #getFont} 方法。有关更多信息，请参阅 {@link java.awt.font.TextAttribute#FONT}。</p>

 <p>一些属性会带来额外的呈现开销，并且可能调用布局。如果某一 <code>Font</code> 具有这样的属性，那么 <code>{@link #hasLayoutAttributes}</code> 方法将返回 true。</p>

 <p>注：字体旋转可能导致文本基线也跟着旋转。为了应对这种（很少见的）可能性，可以指定字体 API 返回字体规格，并使参数“位于相对于基线的坐标中”。这将 'x' 坐标映射到沿基线的某段距离处（正 x 表示沿基线的正方向），将 'y' 坐标映射到位于 'x' 坐标的基线垂直方向的某段距离处（正 y 表示从基线向量顺时针旋转 90 度）。用于实现这些的 API 特别重要，它们被调出，就像具有“相对于基线的坐标”一样。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String java.awt.Font.DIALOG
<!-- END KEY -->
<!-- BEGIN DATA -->
 逻辑字体 "Dialog" 的规范系列名称的 String 常量。它在 Font 构造中很有用，可提供该名称的编译时验证。
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String java.awt.Font.DIALOG_INPUT
<!-- END KEY -->
<!-- BEGIN DATA -->
 逻辑字体 "DialogInput" 的规范系列名称的 String 常量。它在 Font 构造中很有用，可提供该名称的编译时验证。
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String java.awt.Font.SANS_SERIF
<!-- END KEY -->
<!-- BEGIN DATA -->
 逻辑字体 "SansSerif" 的规范系列名称的 String 常量。它在 Font 构造中很有用，可提供该名称的编译时验证。
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String java.awt.Font.SERIF
<!-- END KEY -->
<!-- BEGIN DATA -->
 逻辑字体 "Serif" 的规范系列名称的 String 常量。它在 Font 构造中很有用，可提供该名称的编译时验证。
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String java.awt.Font.MONOSPACED
<!-- END KEY -->
<!-- BEGIN DATA -->
 逻辑字体 "Monospaced" 的规范系列名称的 String 常量。它在 Font 构造中很有用，可提供该名称的编译时验证。
 @since 1.6

@version 	1.200, 07/20/04

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.awt.Font.PLAIN
<!-- END KEY -->
<!-- BEGIN DATA -->
普通样式常量。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.awt.Font.BOLD
<!-- END KEY -->
<!-- BEGIN DATA -->
粗体样式常量。可与其他样式常量（PLAIN 除外）进行组合，从而得到混合样式。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.awt.Font.ITALIC
<!-- END KEY -->
<!-- BEGIN DATA -->
斜体样式常量。可与其他样式常量（PLAIN 除外）进行组合，从而得到混合样式。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.awt.Font.ROMAN_BASELINE
<!-- END KEY -->
<!-- BEGIN DATA -->
布置文本时，在大多数 Roman 脚本中使用的基线。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.awt.Font.CENTER_BASELINE
<!-- END KEY -->
<!-- BEGIN DATA -->
布置文本时，在表意文字的脚本（如中文、日文和韩文）中使用的基线。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.awt.Font.HANGING_BASELINE
<!-- END KEY -->
<!-- BEGIN DATA -->
布置文本时，在 Devanigiri 和类似脚本中使用的基线。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.awt.Font.TRUETYPE_FONT
<!-- END KEY -->
<!-- BEGIN DATA -->
标识 TRUETYPE 类型的字体资源。可用它为 {@link #createFont} 方法指定一个 TrueType 字体资源。
@since 1.3

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.awt.Font.TYPE1_FONT
<!-- END KEY -->
<!-- BEGIN DATA -->
标识 TYPE1 类型的字体资源。可用它为 {@link #createFont} 方法指定一个 Type1 字体资源。
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.lang.String java.awt.Font.name
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>Font</code> 的逻辑名称，它被传递到构造方法中。
@since JDK1.0

@serial
@see #getName

<!-- END DATA -->
<!-- BEGIN KEY -->
protected int java.awt.Font.style
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>Font</code> 的样式，它被传递到构造方法中。此样式可以为 PLAIN、BOLD、ITALIC 或 BOLD+ITALIC。
@since JDK1.0

@serial
@see #getStyle()

<!-- END DATA -->
<!-- BEGIN KEY -->
protected int java.awt.Font.size
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>Font</code> 的磅值大小，舍入为整数。
@since JDK1.0

@serial
@see #getSize()

<!-- END DATA -->
<!-- BEGIN KEY -->
protected float java.awt.Font.pointSize
<!-- END KEY -->
<!-- BEGIN DATA -->
以 <code>float</code> 形式表示的 <code>Font</code> 的磅值大小。

@serial
@see #getSize()
@see #getSize2D()

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.awt.Font.LAYOUT_LEFT_TO_RIGHT
<!-- END KEY -->
<!-- BEGIN DATA -->
layoutGlyphVector 的标志，指示文本是从左到右的，这由 Bidi 分析确定。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.awt.Font.LAYOUT_RIGHT_TO_LEFT
<!-- END KEY -->
<!-- BEGIN DATA -->

layoutGlyphVector 的标志，指示文本是从右到左的，这由 Bidi 分析确定。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.awt.Font.LAYOUT_NO_START_CONTEXT
<!-- END KEY -->
<!-- BEGIN DATA -->
layoutGlyphVector 的标志，指示不应该检查指定 start 之前的 char 数组中的文本。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.awt.Font.LAYOUT_NO_LIMIT_CONTEXT
<!-- END KEY -->
<!-- BEGIN DATA -->
layoutGlyphVector 的标志，指示不应该检查指定 limit 之后的  char 数组中的文本。

<!-- END DATA -->
<!-- BEGIN KEY -->
private java.util.Hashtable java.awt.Font.fRequestedAttributes
<!-- END KEY -->
<!-- BEGIN DATA -->
此方法现在只在序列化期间使用。它通常为 null。

@serial
@see #getAttributes()

<!-- END DATA -->
<!-- BEGIN KEY -->
private int java.awt.Font.fontSerializedDataVersion
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>Font</code> 的可序列化数据形式。

@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Font(String name, int style, int size)
<!-- END KEY -->
<!-- BEGIN DATA -->
根据指定名称、样式和磅值大小，创建一个新 <code>Font</code>。
 <p>
字体名称可以是字体外观名称或字体系列名称。它与样式一起使用，以查找合适的字体外观。如果指定了字体系列名称，则使用样式参数从系列中选择最合适的外观。如果指定了字体外观名称，则合并外观的样式和样式参数，以便从同一个系列查找最匹配的字体。例如，如果指定外观名称 &quot;Arial Bold&quot; 及样式 <code>Font.ITALIC</code>，则字体系统在 &quot;Arial&quot; 系列中寻找既是粗体又是斜体的外观，可以将字体实例与物理字体外观 &quot;Arial Bold Italic&quot; 相关联。将样式参数与指定外观的样式合并，而不是执行添加或减去操作。这意味着，指定粗体外观和粗体样式并不会双倍加粗字体，而指定粗体外观和普通样式也不会变细字体。
 <p>
如果无法找到所要求样式的外观，则字体系统可以应用样式设计算法来获得所需的样式。例如，如果要求 <code>ITALIC</code>，但是没有可用的斜体外观，则可以通过算法使普通外观倾斜。
 <p>
字体名称查找是区分大小写的，可以使用 US 语言环境的大小写转换规则。
<p>
 如果 <code>name</code> 参数表示逻辑字体以外的事物，例如表示为物理字体外观或系列名称，并且无法通过实现物理字体或可兼容的替代物映射它，则字体系统会将 Font 实例映射到 "Dialog"，因此，通过 {@link #getFamily() getFamily} 报告的字体系列名称将是 "Dialog"。
 <p>

@param name 字体名称。可以是字体外观名称或字体系列名称，并且可表示此 <code>GraphicsEnvironment</code> 中找到的逻辑字体或物理字体。逻辑字体的系列名称有：Dialog、DialogInput、Monospaced、Serif 或 SansSerif。预定义 String 常量是为所有这些名称（如 {@see #DIALOG}）而存在。如果 <code>name</code> 为 <code>null</code>，则将新 <code>Font</code> 的<em>逻辑字体名称</em>（由 <code>getName()</code> 返回）设置为 &quot;Default&quot;。
@param style <code>Font</code> 的样式常量。样式参数是整数位掩码，可以为 PLAIN，或 BOLD 和 ITALIC 的按位或（例如，ITALIC 或 BOLD|ITALIC）。如果样式参数不符合任何一个期望的整数位掩码，则将样式设置为 PLAIN。
@param size <code>Font</code> 的磅值大小
@see GraphicsEnvironment#getAllFonts
@see GraphicsEnvironment#getAvailableFontFamilyNames
@since JDK1.0

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Font(java.util.Map<? extends java.text.AttributedCharacterIterator.Attribute, ?> attributes)
<!-- END KEY -->
<!-- BEGIN DATA -->
创建一个具有指定属性的新 <code>Font</code>。只有 {@link java.awt.font.TextAttribute TextAttribute} 中定义的键被识别。此外，FONT 属性也没有被此构造方法识别（请参阅 {@link #getAvailableAttributes}）。只有具有有效类型值的属性会影响新的 <code>Font</code>。
<p>
如果 <code>attributes</code> 为 <code>null</code>，则使用默认值初始化新 <code>Font</code>。
@see java.awt.font.TextAttribute
@param attributes 分配给新 <code>Font</code> 的属性，或 <code>null</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.awt.Font(Font font)
<!-- END KEY -->
<!-- BEGIN DATA -->
 根据指定 <code>font</code> 创建一个新 <code>Font</code>。此构造方法由子类使用。
 @param font 用来创建此 <code>Font</code> 的字体。
 @throws NullPointerException 如果 <code>font</code> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.peer.FontPeer java.awt.Font.getPeer()
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此 <code>Font</code> 的同位体。
@return  <code>Font</code> 的同位体。
@since JDK1.1
@deprecated 现在，字体呈现与平台无关。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.awt.Font java.awt.Font.getFont(java.util.Map<? extends java.text.AttributedCharacterIterator.Attribute, ?> attributes)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回适合于这些属性的 <code>Font</code>。如果 <code>attributes</code> 包含一个使用有效 <code>Font</code> 作为其值的 <code>FONT</code> 属性，那么它将与其余所有属性合并。有关更多信息，请参阅 {@link java.awt.font.TextAttribute#FONT}。

@param attributes 分配给新 <code>Font</code> 的属性
@return 使用指定属性创建的新 <code>Font</code>
@throws NullPointerException 如果 <code>attributes</code> 为 null。
@since 1.2
@see java.awt.font.TextAttribute

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.awt.Font java.awt.Font.createFont(int fontFormat, InputStream fontStream) throws java.awt.FontFormatException, java.io.IOException
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个使用指定字体类型和输入数据的新 <code>Font</code>。创建的新 <code>Font</code> 的磅值大小为 1，样式为 {@link #PLAIN PLAIN}。然后，基本字体可以与此类中的 <code>deriveFont</code> 方法一起使用，从而派生出新的 <code>Font</code> 对象，这些对象具有变化的大小、样式、变换和字体特征。此方法不会关闭 {@link InputStream}。
<p>
 为了使 <code>Font</code> 可用于 Font 构造方法，必须通过调用 {@link GraphicsEnvironment#registerFont(Font) registerFont(Font)} 在 <code>GraphicsEnviroment</code> 中注册返回的 <code>Font</code>。
@param fontFormat <code>Font</code> 的类型，如果指定了 TrueType 资源，则类型为 {@link #TRUETYPE_FONT TRUETYPE_FONT}，如果指定了 Type 1 资源，则类型为 {@link #TYPE1_FONT TYPE1_FONT}。
@param fontStream <code>InputStream</code> 对象，表示字体的输入数据。
@return 使用指定字体类型创建的新 <code>Font</code>。
@throws IllegalArgumentException 如果 <code>fontFormat</code> 不为 <code>TRUETYPE_FONT</code> 或 <code>TYPE1_FONT</code>。
@throws FontFormatException 如果 <code>fontStream</code> 数据不包含指定格式所需的字体表。
@throws IOException 如果无法完全读取 <code>fontStream</code>。
@see GraphicsEnvironment#registerFont(Font)
@since 1.3

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.awt.Font java.awt.Font.createFont(int fontFormat, File fontFile) throws java.awt.FontFormatException, java.io.IOException
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个使用指定字体类型和指定字体文件的新 <code>Font</code>。创建的新 <code>Font</code> 的磅值大小为 1，样式为 {@link #PLAIN PLAIN}。基本字体可以与此类中的 <code>deriveFont</code> 方法一起使用，从而派生出新的 <code>Font</code> 对象，这些对象具有变化的大小、样式、变换和字体特征。
@param fontFormat <code>Font</code> 的类型，如果指定了 TrueType 资源，则类型为 {@link #TRUETYPE_FONT TRUETYPE_FONT}，如果指定了 Type 1 资源，则类型为 {@link #TYPE1_FONT TYPE1_FONT}。只要引用了返回的字体，或它派生的字体，实现就可以继续访问 <code>fontFile</code> 以检索字体数据。因此，如果文件被更改，或变成不可访问的，其结果是不确定的。
<p>
 为了使 <code>Font</code> 可用于 Font 构造方法，必须通过调用 {@link GraphicsEnvironment#registerFont(Font) registerFont(Font)} 在 <code>GraphicsEnviroment</code> 中注册返回的 <code>Font</code>。
@param fontFile <code>File</code> 对象，表示字体的输入数据。
@return 使用指定字体类型创建的新 <code>Font</code>。
@throws IllegalArgumentException 如果 <code>fontFormat</code> 不为  <code>TRUETYPE_FONT</code>or<code>TYPE1_FONT</code>。
@throws NullPointerException 如果 <code>fontFile</code> 为 null。
@throws IOException 如果无法读取 <code>fontFile</code>。
@throws FontFormatException 如果 <code>fontFile</code> 不包含指定格式所需的字体表。
@throws SecurityException 如果正在执行的代码没有从文件中读取的权限。
@see GraphicsEnvironment#registerFont(Font)
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.geom.AffineTransform java.awt.Font.getTransform()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回与此 <code>Font</code> 相关的变换的副本。此转换对于用于构造字体的方法而言是没必要的。如果字体具有算法上标（algorithmic superscripting）或宽度调整，那么这将合并到返回的 <code>AffineTransform</code> 中。
 <p>
通常不会转换字体。客户机通常应该先调用 {@link #isTransformed}，如果 <code>isTransformed</code> 返回 true，则只调用此方法。
@return {@link AffineTransform} 对象，表示此 <code>Font</code> 对象的变换属性。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.awt.Font.getFamily()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Font</code> 的系列名称。  
 
<p>字体的系列名称是特定于字体的。两个字体 Helvetica Italic 和 Helvetica Bold 具有相同的系列名称 <i>Helvetica</i>，但它们的字体外观名称是 <i>Helvetica Bold</i> 和 <i>Helvetica Italic</i>。可用的系列名称列表可以通过使用 {@link GraphicsEnvironment#getAvailableFontFamilyNames()} 方法得到。
 
<p>使用 <code>getName</code> 可以获取字体的逻辑名称。使用 <code>getFontName</code> 可以获取字体的字体外观名称。
@return 一个 <code>String</code>，此 <code>Font</code> 的系列名称。
 
@see #getName
@see #getFontName
@since JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.awt.Font.getFamily(Locale l)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Font</code> 的系列名称（已经针对指定语言环境进行了本地化）。
 
<p>字体的系列名称是特定于字体的。两个字体 Helvetica Italic 和 Helvetica Bold 具有相同的系列名称 <i>Helvetica</i>，但它们的字体外观名称是 <i>Helvetica Bold</i> 和 <i>Helvetica Italic</i>。可用的系列名称列表可以通过使用 {@link GraphicsEnvironment#getAvailableFontFamilyNames()} 方法得到。
 
<p>使用 <code>getFontName</code> 可以获取字体的字体外观名称。
@param l 语言环境，要获得该语言环境的系列名称
@return 一个 <code>String</code>，表示字体的系列名称（已经针对指定语言环境进行了本地化）。
@see #getFontName
@see java.util.Locale
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.awt.Font.getPSName()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Font</code> 的 postscript 名称。使用 <code>getFamily</code> 可以获取字体的系列名称。使用 <code>getFontName</code> 可以获取字体的字体外观名称。
@return 一个 <code>String</code>，表示此 <code>Font</code> 的 postscript 名称。
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.awt.Font.getName()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Font</code> 的逻辑名称。使用 <code>getFamily</code> 可以获取字体的系列名称。使用 <code>getFontName</code> 可以获取字体的字体外观名称。
@return 一个 <code>String</code>，表示此 <code>Font</code> 的逻辑名称。
@see #getFamily
@see #getFontName
@since JDK1.0

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.awt.Font.getFontName()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Font</code> 的字体外观名称。例如，Helvetica Bold 可以作为字体外观名称返回。使用 <code>getFamily</code> 可以获取字体的系列名称。使用 <code>getName</code> 可以获取字体的逻辑名称。
@return 一个 <code>String</code>，表示此 <code>Font</code> 的字体外观名称。
@see #getFamily
@see #getName
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.awt.Font.getFontName(Locale l)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Font</code> 的字体外观名称（已经针对指定语言环境进行了本地化）。例如，Helvetica Fett 可以作为字体外观名称返回。使用 <code>getFamily</code> 可以获取字体的系列名称。
@param l 语言环境，要获得该语言环境的字体外观名称
@return 一个 <code>String</code>，表示字体外观名称（已经针对指定语言环境进行了本地化）。
@see #getFamily
@see java.util.Locale

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.awt.Font.getStyle()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Font</code> 的样式。样式可以为 PLAIN、BOLD、ITALIC 或 BOLD+ITALIC。
@return 此 <code>Font</code> 的样式
@see #isPlain
@see #isBold
@see #isItalic
@since JDK1.0

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.awt.Font.getSize()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Font</code> 的磅值大小，舍入为整数。大多数用户都熟悉使用<i>磅值大小</i> 的概念，它用于指定字体中字形的大小。磅值大小定义了单间距文本文档中某行的基线到下一行的基线之间的测量。磅值大小是基于<i>排字磅值</i> 的，大约为 1/72 英寸。
 <p>
Java(tm)2D API 规定：1 磅等于用户坐标中的 1 个单位。当使用规范化变换将用户空间坐标转换为设备空间坐标时，72 个用户空间单位等于设备空间中的 1 英寸。在这种情况下，1 磅就是 1/72 英寸。
@return <code>Font</code> 的磅值大小（以 1/72 英寸为单位）。
@see #getSize2D
@see GraphicsConfiguration#getDefaultTransform
@see GraphicsConfiguration#getNormalizingTransform
@since JDK1.0

<!-- END DATA -->
<!-- BEGIN KEY -->
public float java.awt.Font.getSize2D()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Font</code> 的磅值大小（以 <code>float</code> 值表示）。
@return <code>Font</code> 的磅值大小（以 <code>float</code> 值表示）。
@see #getSize
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Font.isPlain()
<!-- END KEY -->
<!-- BEGIN DATA -->
指示此 <code>Font</code> 对象的样式是否为 PLAIN。
@return    如果此 <code>Font</code> 样式为 PLAIN，则返回 <code>true</code>；否则返回 <code>false</code>。
@see       java.awt.Font#getStyle
@since     JDK1.0

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Font.isBold()
<!-- END KEY -->
<!-- BEGIN DATA -->
指示此 <code>Font</code> 对象的样式是否为 BOLD。
@return    如果此 <code>Font</code> 对象的样式为 BOLD，则返回 <code>true</code>；否则返回 <code>false</code>。
@see       java.awt.Font#getStyle
@since     JDK1.0

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Font.isItalic()
<!-- END KEY -->
<!-- BEGIN DATA -->
指示此 <code>Font</code> 对象的样式是否为 ITALIC。
@return    如果此 <code>Font</code> 对象的样式为 ITALIC，则返回 <code>true</code>；否则返回 <code>false</code>。
@see       java.awt.Font#getStyle
@since     JDK1.0

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Font.isTransformed()
<!-- END KEY -->
<!-- BEGIN DATA -->
指示此 <code>Font</code> 对象是否具有影响其大小以及 Size 属性的变换。
@return	如果此 <code>Font</code> 对象具有无标识的 AffineTransform 属性，则返回 <code>true</code>；否则返回 <code>false</code>。
@see	java.awt.Font#getTransform
@since	1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Font.hasLayoutAttributes()
<!-- END KEY -->
<!-- BEGIN DATA -->
如果此 Font 包含需要额外布局处理的属性，则返回 true。
 @return 如果该字体已经具有布局属性，则返回 true
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.awt.Font java.awt.Font.getFont(String nm)
<!-- END KEY -->
<!-- BEGIN DATA -->
从系统属性列表返回一个 <code>Font</code> 对象。<code>nm</code> 被视为要获得的系统属性的名称。然后，根据 <code>Font.decode(String)</code> 规范，将此属性的 <code>String</code> 值解释为一个 <code>Font</code> 对象。如果无法找到指定属性，或者执行代码没有读取该属性的权限，则返回 null。
 
@param nm 属性名称
@return 属性名称描述的 <code>Font</code> 对象，如果没有这样的属性存在，则返回 null。
@throws NullPointerException 如果 nm 为 null。
@since 1.2
@see #decode(String)

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.awt.Font java.awt.Font.decode(String str)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>str</code> 参数所描述的 <code>Font</code>。为了确保此方法返回所需的 Font，可以使用以下方式之一格式化 <code>str</code> 参数。
 <p>
 <ul>
 <li><em>fontname-style-pointsize</em>
 <li><em>fontname-pointsize</em>
 <li><em>fontname-style</em>
 <li><em>fontname</em>
 <li><em>fontname style pointsize</em>
 <li><em>fontname pointsize</em>
 <li><em>fontname style</em>
 <li><em>fontname</em>
 </ul>
其中，<i>style</i> 是以下四个区分大小写的字符串之一：<code>&quot;PLAIN&quot;</code>、<code>&quot;BOLD&quot;</code>、<code>&quot;BOLDITALIC&quot;</code> 和 <code>&quot;ITALIC&quot;</code>，pointsize 是磅值大小的正十进制整数表示形式。例如，如果想要的字体是 Arial、粗体、磅值大小为 18，则按以下方式调用此方法：&quot;Arial-BOLD-18&quot;。这等同于调用以下 Font 构造方法：<code>new Font(&quot;Arial&quot;, Font.BOLD, 18);</code>，值被解释为构造方法所指定的形式。
 <p>
有效的尾部十进制字段总是被解释为 pointsize。因此，后跟十进制值的 fontname 不应该在只在 fontname 的格式中使用。
 <p>
如果样式名称字段不是有效的样式字符串，则它被解释为样式名称的一部分，并且使用默认样式。
 <p>
只有 ' ' 或 '-' 可以用来分隔输入中的字段。所标识的分隔符是最接近字符串末尾的字符，它将有效的 pointsize 或有效的样式名称与字符串的其余部分分隔开来。Null（空）pointsize 和样式字段被视为有效字段，具有该字段的默认值。 
<p>
有些字体名称可以包括分隔符 ' ' 或 '-'。如果 <code>str</code> 不是由三部分构成，例如，<code>style</code> 或 <code>pointsize</code> 字段不出现在 <code>str</code> 中，并且 <code>fontname</code> 还包含确定为分隔符的字符，则这些打算作为 <code>fontname</code> 一部分出现的字符也可以解释为分隔符，因此字体名称无法正确识别。
 
 <p>
默认大小为 12，默认样式为 PLAIN。如果 <code>str</code> 没有指定有效大小，则返回的 <code>Font</code> 大小为 12。如果 <code>str</code> 没有指定有效样式，则返回的 Font 样式为 PLAIN。如果没有在 <code>str</code> 参数中指定有效的字体名称，则此方法将返回系列名称为 &quot;Dialog&quot; 的字体。要确定系统上可以使用哪些字体系列名称，可以使用 {@link GraphicsEnvironment#getAvailableFontFamilyNames()} 方法。如果 <code>str</code> 为 <code>null</code>，则返回的新 <code>Font</code> 的系列名称为 &quot;Dialog&quot;，大小为 12，样式为 PLAIN。
@param str 字体名称，或 <code>null</code>
@return <code>str</code> 描述的 <code>Font</code> 对象，如果 <code>str</code> 为 <code>null</code>，则返回新的默认 <code>Font</code>。
@see #getFamily
@since JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.awt.Font java.awt.Font.getFont(String nm, Font font)
<!-- END KEY -->
<!-- BEGIN DATA -->
从系统属性列表获取指定的 <code>Font</code>。在 <code>System</code> 的 <code>getProperty</code> 方法中，第一个参数被视为要获取的系统属性的名称。接着将此属性的 <code>String</code> 值解释为 <code>Font</code> 对象。 
 <p>
属性值应该是 <code>Font.decode(String)</code> 所接受的形式之一。如果无法找到指定属性，或者执行代码没有读取该属性的权限，则返回 <code>font</code> 参数。
@param nm 不区分大小写的属性名称
@param font 如果没有定义属性 <code>nm</code>，则为要返回的默认 <code>Font</code>
@return    属性的 <code>Font</code> 值。
@throws NullPointerException 如果 nm 为 null。
@see #decode(String)

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.awt.Font.hashCode()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Font</code> 的哈希码。
@return     此 <code>Font</code> 的哈希码值。
@since      JDK1.0

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Font.equals(Object obj)
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>Font</code> 对象与指定 <code>Object</code> 进行比较。
@param obj 要比较的 <code>Object</code>
@return 如果对象相同，或参数是 <code>Font</code> 对象，且描述的字体与此对象相同，则返回 <code>true</code>；否则，返回 <code>false</code>。
@since JDK1.0

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.awt.Font.toString()
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>Font</code> 对象转换为 <code>String</code> 表示形式。
@return     此 <code>Font</code> 对象的 <code>String</code> 表示形式。
@since      JDK1.0

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.awt.Font.getNumGlyphs()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Font</code> 中的字形数量。此 <code>Font</code> 的字形代码，范围从 0 到 <code>getNumGlyphs()</code> - 1。
@return 此 <code>Font</code> 的字形数量。
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.awt.Font.getMissingGlyphCode()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Font</code> 不具有指定的 unicode 字形时所使用的 glyphCode 代码点。
@return 此 <code>Font</code> 的 glyphCode。
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public byte java.awt.Font.getBaselineFor(char c)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回适合用来显示此字符的基线。
 <p>
大字体可以支持不同的书写系统，并且每个系统都可以使用不同的基线。字符参数确定要使用的书写系统。客户不应该假定所有字符都使用相同的基线。

@param c 用来标识书写系统的字符
@return 适合于指定字符的基线。
@see LineMetrics#getBaselineOffsets
@see #ROMAN_BASELINE
@see #CENTER_BASELINE
@see #HANGING_BASELINE
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Map<java.awt.font.TextAttribute, ?> java.awt.Font.getAttributes()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Font</code> 中可用的字体属性的映射。属性包括诸如连字和字形替换之类的事情。
@return 此 <code>Font</code> 的属性映射。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.text.AttributedCharacterIterator.Attribute[] java.awt.Font.getAvailableAttributes()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回由此 <code>Font</code> 支持的所有属性的键。这些属性可以用来派生其他字体。
@return 一个数组，包含受此 <code>Font</code> 支持的所有属性的键。
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Font java.awt.Font.deriveFont(int style, float size)
<!-- END KEY -->
<!-- BEGIN DATA -->
通过复制此 <code>Font</code> 对象并应用新样式和大小，创建一个新 <code>Font</code> 对象。
@param style 新 <code>Font</code> 的样式
@param size 新 <code>Font</code> 的大小
@return 新 <code>Font</code> 对象。
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Font java.awt.Font.deriveFont(int style, AffineTransform trans)
<!-- END KEY -->
<!-- BEGIN DATA -->
通过复制此 <code>Font</code> 对象并应用新样式和变换，创建一个新 <code>Font</code> 对象。
@param style 新 <code>Font</code> 的样式
@param trans 与新 <code>Font</code> 相关的 <code>AffineTransform</code>
@return 一个新 <code>Font</code> 对象。
@throws IllegalArgumentException 如果 <code>trans</code> 为 <code>null</code>
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Font java.awt.Font.deriveFont(float size)
<!-- END KEY -->
<!-- BEGIN DATA -->
通过复制当前 <code>Font</code> 对象并应用新的大小，创建一个新 <code>Font</code> 对象。
@param size 新 <code>Font</code> 的大小。
@return 新 <code>Font</code> 对象。
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Font java.awt.Font.deriveFont(AffineTransform trans)
<!-- END KEY -->
<!-- BEGIN DATA -->
通过复制当前 <code>Font</code> 对象并应用新的变换，创建一个新  <code>Font</code> 对象。
@param trans 与新 <code>Font</code> 相关的 <code>AffineTransform</code>
@return 一个新的 <code>Font</code> 对象。
@throws IllegalArgumentException 如果 <code>trans</code> 为 <code>null</code>
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Font java.awt.Font.deriveFont(int style)
<!-- END KEY -->
<!-- BEGIN DATA -->
通过复制当前的 <code>Font</code> 对象，并应用新的样式，创建一个新 <code>Font</code> 对象。
@param style 新 <code>Font</code> 的样式
@return 新 <code>Font</code> 对象。
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Font java.awt.Font.deriveFont(java.util.Map<? extends java.text.AttributedCharacterIterator.Attribute, ?> attributes)
<!-- END KEY -->
<!-- BEGIN DATA -->
通过复制当前 <code>Font</code> 对象并应用新的字体属性集，创建一个新 <code>Font</code> 对象。
@param attributes 为新 <code>Font</code> 所启用的属性映射
@return 新 <code>Font</code> 对象。
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Font.canDisplay(char c)
<!-- END KEY -->
<!-- BEGIN DATA -->
检查此 <code>Font</code> 是否具有指定字符的字形。

<p><b>注：</b>此方法无法处理<a
 href="../../java/lang/Character.html#supplementary">增补字符</a>。要支持所有 Unicode 字符，包括增补字符，可以使用 {@link #canDisplay(int)} 方法或 <code>canDisplayUpTo</code> 方法。

@param c 需要字形的字符
@return 如果此 <code>Font</code> 具有该字符的字形，则返回 <code>true</code>；否则返回 <code>false</code>。
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Font.canDisplay(int codePoint)
<!-- END KEY -->
<!-- BEGIN DATA -->
检查此 <code>Font</code> 是否具有指定字符的字形。

@param codePoint 需要字形的字符（Unicode 代码点）。
@return 如果此 <code>Font</code> 具有该字符的字形，则返回 <code>true</code>；否则返回 <code>false</code>。
@throws IllegalArgumentException 如果代码点不是一个有效的 Unicode 代码点。
@see Character#isValidCodePoint(int)
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.awt.Font.canDisplayUpTo(String str)
<!-- END KEY -->
<!-- BEGIN DATA -->
指示此 <code>Font</code> 是否可以显示指定的 <code>String</code>。对于使用 Unicode 编码的字符串，知道特定字体是否可以显示该字符串是很重要的。此方法返回 <code>String</code> <code>str</code> 中的一个偏移量，这是此 <code>Font</code> 不使用缺少的字形代码就无法显示的第一个字符。如果 <code>Font</code> 可以显示所有字符，则返回 -1。
@param str 一个 <code>String</code> 对象
@return <code>str</code> 中的一个偏移量，指向 <code>str</code> 中此 <code>Font</code> 无法显示的第一个字符；如果此 <code>Font</code> 可以显示 <code>str</code> 中的所有字符，则返回 <code>-1</code>。
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.awt.Font.canDisplayUpTo(char[] text, int start, int limit)
<!-- END KEY -->
<!-- BEGIN DATA -->
指示此 <code>Font</code> 是否可以显示指定 <code>text</code> 中从 <code>start</code> 开始至 <code>limit</code> 结束的所有字符。此方法是一次方便的重载。
@param text 指定 <code>char</code> 值的数组
@param start 指定 <code>char</code> 值数组中的指定起始偏移量 (in <code>char</code>)
@param limit 指定 <code>char</code> 值数组中的指定结束偏移量 (in <code>char</code>)
@return  <code>text</code> 中的偏移量，指向此 <code>Font</code> 无法显示的 <code>text</code> 中的第一个字符；如果此 <code>Font</code> 可以显示 <code>text</code> 中的所有字符，则返回 <code>-1</code>。
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.awt.Font.canDisplayUpTo(CharacterIterator iter, int start, int limit)
<!-- END KEY -->
<!-- BEGIN DATA -->
指示此 <code>Font</code> 是否可以显示由 <code>iter</code> 指定的文本（从 <code>start</code> 开始至 <code>limit</code> 结束）。

@param iter  {@link CharacterIterator} 对象
@param start 指定 <code>CharacterIterator</code> 中的指定起始偏移量。
@param limit 指定 <code>CharacterIterator</code> 中的指定结束偏移量。
@return <code>iter</code> 中的偏移量，它指向 <code>iter</code> 中此 <code>Font</code> 无法显示的第一个字符；如果此 <code>Font</code> 可以显示 <code>iter</code> 中的所有字符，则返回 <code>-1</code>。
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public float java.awt.Font.getItalicAngle()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Font</code> 的斜角。斜角是与此 <code>Font</code> 的动作最匹配的 caret 的反斜面。
@see TextAttribute#POSTURE
@return 此 <code>Font</code> 的 ITALIC 样式的角度

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Font.hasUniformLineMetrics()
<!-- END KEY -->
<!-- BEGIN DATA -->
检查此 <code>Font</code> 是否具有统一的行规格。逻辑 <code>Font</code> 可以是复合字体，这意味着它由不同的物理字体组成，可以覆盖不同的代码范围。其中每一种字体都可能有不同的 <code>LineMetrics</code>。如果逻辑 <code>Font</code> 是单一字体，则规格将是统一的。
@return 如果此 <code>Font</code> 具有统一的行规格，则返回 <code>true</code>；否则返回 <code>false</code>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.font.LineMetrics java.awt.Font.getLineMetrics(String str, FontRenderContext frc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个使用指定 <code>String</code> 和 {@link FontRenderContext} 创建的 {@link LineMetrics} 对象。
@param str 指定的 <code>String</code>
@param frc 指定的 <code>FontRenderContext</code>
@return 使用指定 <code>String</code> 和 {@link FontRenderContext} 创建的 <code>LineMetrics</code> 对象。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.font.LineMetrics java.awt.Font.getLineMetrics(String str, int beginIndex, int limit, FontRenderContext frc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回使用指定参数创建的 <code>LineMetrics</code> 对象。
@param str 指定的 <code>String</code>
@param beginIndex <code>str</code> 的初始偏移量
@param limit <code>str</code> 的结束偏移量
@param frc 指定的 <code>FontRenderContext</code>
@return 使用指定参数创建的 <code>LineMetrics</code> 对象。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.font.LineMetrics java.awt.Font.getLineMetrics(char[] chars, int beginIndex, int limit, FontRenderContext frc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回使用指定参数创建的 <code>LineMetrics</code> 对象。
@param chars 字符数组
@param beginIndex <code>chars</code> 的初始偏移量
@param limit <code>chars</code> 的结束偏移量
@param frc 指定的 <code>FontRenderContext</code>
@return 使用指定参数创建的 <code>LineMetrics</code> 对象。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.font.LineMetrics java.awt.Font.getLineMetrics(CharacterIterator ci, int beginIndex, int limit, FontRenderContext frc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回使用指定参数创建的 <code>LineMetrics</code> 对象。
@param ci 指定的 <code>CharacterIterator</code>
@param beginIndex <code>ci</code> 中的初始偏移量
@param limit <code>ci</code> 的结束偏移量
@param frc 指定的 <code>FontRenderContext</code>
@return 使用指定参数创建的 <code>LineMetrics</code> 对象。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.geom.Rectangle2D java.awt.Font.getStringBounds(String str, FontRenderContext frc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定 <code>FontRenderContext</code> 中指定 <code>String</code> 的逻辑边界。逻辑边界包含 origin、ascent、advance 和 height，其中包括了 leading。逻辑边界并不总是包围所有文本。例如，在某些语言和字体中，accent 标记可以位于 ascent 之上，或 descent 之下。要得到可视的边界框（它包围了所有文本），可以使用 <code>TextLayout</code> 的 {@link TextLayout#getBounds() getBounds} 方法。
<p>注：返回的边界在相对于基线的坐标中（请参阅 {@link java.awt.Font class notes}）。
@param str 指定的 <code>String</code>
@param frc 指定的 <code>FontRenderContext</code>
@return 一个 {@link Rectangle2D}，它是指定 <code>FontRenderContext</code> 中指定 <code>String</code> 的边界框。
@see FontRenderContext
@see Font#createGlyphVector
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.geom.Rectangle2D java.awt.Font.getStringBounds(String str, int beginIndex, int limit, FontRenderContext frc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定 <code>FontRenderContext</code> 中指定 <code>String</code> 的逻辑边界。逻辑边界包含 origin、ascent、advance 和 height，其中包括了 leading。逻辑边界并不总是包围所有文本。例如，在某些语言和字体中，accent 标记可以位于 ascent 之上，或 descent 之下。要得到可视的边界框（它包围了所有文本），可以使用 <code>TextLayout</code> 的 {@link TextLayout#getBounds() getBounds} 方法。
<p>注：返回的边界在相对于基线的坐标中（请参阅 {@link java.awt.Font class notes}）。
@param str 指定的 <code>String</code>
@param beginIndex <code>str</code> 的初始偏移量
@param limit <code>str</code> 的结束偏移量
@param frc 指定的 <code>FontRenderContext</code>
@return 一个 <code>Rectangle2D</code>，它是指定 <code>FontRenderContext</code> 中指定 <code>String</code> 的边界框。
@throws IndexOutOfBoundsException 如果 <code>beginIndex</code> 小于零，或 <code>limit</code> 大于 <code>str</code> 的长度，或 <code>beginIndex</code> 大于 <code>limit</code>。
@see FontRenderContext
@see Font#createGlyphVector
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.geom.Rectangle2D java.awt.Font.getStringBounds(char[] chars, int beginIndex, int limit, FontRenderContext frc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定 <code>FontRenderContext</code> 指定字符数组的逻辑边界。逻辑边界包含 origin、ascent、advance 和 height，其中包括了 leading。逻辑边界并不总是包围所有文本。例如，在某些语言和字体中，accent 标记可以位于 ascent 之上，或 descent 之下。要得到可视的边界框（它包围了所有文本），可以使用 <code>TextLayout</code> 的 {@link TextLayout#getBounds() getBounds} 方法。
<p>注：返回的边界在相对于基线的坐标中（请参阅 {@link java.awt.Font class notes}）。
@param chars 字符数组
@param beginIndex 字符数组的初始偏移量
@param limit 字符数组的结束偏移量
@param frc 指定的 <code>FontRenderContext</code>
@return 一个 <code>Rectangle2D</code>，它是指定 <code>FontRenderContext</code> 中指定字符数组的边界框。
@throws IndexOutOfBoundsException 如果 <code>beginIndex</code> 小于零，或 <code>limit</code> 大于 <code>chars</code> 的长度，或 <code>beginIndex</code> 大于 <code>limit</code>。
@see FontRenderContext
@see Font#createGlyphVector
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.geom.Rectangle2D java.awt.Font.getStringBounds(CharacterIterator ci, int beginIndex, int limit, FontRenderContext frc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定 <code>FontRenderContext</code> 中针对指定 {@link CharacterIterator} 进行索引的字符的逻辑边界。逻辑边界包含 origin、ascent、advance 和 height，其中包括了 leading。逻辑边界并不总是包围所有文本。例如，在某些语言和字体中，accent 标记可以位于 ascent 之上，或 descent 之下。要得到可视的边界框（它包围了所有文本），可以使用 <code>TextLayout</code> 的 {@link TextLayout#getBounds() getBounds} 方法。
<p>注：返回的边界在相对于基线的坐标中（请参阅 {@link java.awt.Font class notes}）。
@param ci 指定的 <code>CharacterIterator</code>
@param beginIndex <code>ci</code> 中的初始偏移量
@param limit <code>ci</code> 中的结束偏移量
@param frc 指定的 <code>FontRenderContext</code>
@return 一个 <code>Rectangle2D</code>，它是指定 <code>FontRenderContext</code> 中针对指定 <code>CharacterIterator</code> 进行索引的字符的边界框。
@see FontRenderContext
@see Font#createGlyphVector
@since 1.2
@throws IndexOutOfBoundsException 如果 <code>beginIndex</code> 小于 <code>ci</code> 的起始索引，或 <code>limit</code> 大于 <code>ci</code> 的结束索引，或 <code>beginIndex</code> 大于 <code>limit</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.geom.Rectangle2D java.awt.Font.getMaxCharBounds(FontRenderContext frc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回最大边界定义在 <code>FontRenderContext</code> 中的字符的边界。
<p>注：返回的边界在相对于基线的坐标中（请参阅 {@link java.awt.Font class notes}）。
@param frc 指定的 <code>FontRenderContext</code>
@return 一个 <code>Rectangle2D</code>，它是具有最大边界的字符的边界框。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.font.GlyphVector java.awt.Font.createGlyphVector(FontRenderContext frc, String str)
<!-- END KEY -->
<!-- BEGIN DATA -->
根据此 <code>Font</code> 中的 Unicode cmap 将字符一一映射到字形，从而创建一个 {@link java.awt.font.GlyphVector GlyphVector}。除了字形到字符的映射之外，此方法不做任何其他处理。这意味着，此方法对于某些脚本是无用的，如 Arabic、Hebrew、Thai 和 Indic，它们要求进行重排序、整形或连字替换。
@param frc 指定的 <code>FontRenderContext</code>
@param str 指定的 <code>String</code>
@return 使用指定 <code>String</code> 和指定 <code>FontRenderContext</code> 创建的新 <code>GlyphVector</code>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.font.GlyphVector java.awt.Font.createGlyphVector(FontRenderContext frc, char[] chars)
<!-- END KEY -->
<!-- BEGIN DATA -->
根据此 <code>Font</code> 中的 Unicode cmap 将字符一一映射到字形，从而创建一个 {@link java.awt.font.GlyphVector GlyphVector}。除了字形到字符的映射之外，此方法不做任何其他处理。这意味着，此方法对于某些脚本是无用的，如 Arabic、Hebrew、Thai 和 Indic，它们要求进行重排序、整形或连字替换。
@param frc 指定的 <code>FontRenderContext</code>
@param chars 指定的字符数组
@return 使用指定字符数组和指定 <code>FontRenderContext</code> 创建的 <code>GlyphVector</code>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.font.GlyphVector java.awt.Font.createGlyphVector(FontRenderContext frc, CharacterIterator ci)
<!-- END KEY -->
<!-- BEGIN DATA -->
根据此 <code>Font</code> 中的 Unicode cmap 将指定字符一一映射到字形，从而创建一个 {@link java.awt.font.GlyphVector GlyphVector}。除了字形到字符的映射之外，此方法不做任何其他处理。这意味着，此方法对于某些脚本是无用的，如 Arabic、Hebrew、Thai 和 Indic，它们要求进行重排序、整形或连字替换。
@param frc 指定的 <code>FontRenderContext</code>
@param ci 指定的 <code>CharacterIterator</code>
@return 使用指定 <code>CharacterIterator</code> 和指定 <code>FontRenderContext</code> 创建的 <code>GlyphVector</code>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.font.GlyphVector java.awt.Font.createGlyphVector(FontRenderContext frc, int[] glyphCodes)
<!-- END KEY -->
<!-- BEGIN DATA -->
根据此 <code>Font</code> 中的 Unicode cmap 将字符一一映射到字形，从而创建一个 {@link java.awt.font.GlyphVector GlyphVector}。除了字形到字符的映射之外，此方法不做任何其他处理。这意味着，此方法对于某些脚本是无用的，如 Arabic、Hebrew、Thai 和 Indic，它们要求进行重排序、整形或连字替换。
@param frc 指定的 <code>FontRenderContext</code>
@param glyphCodes 指定的整数数组
@return 使用指定整数数组和指定 <code>FontRenderContext</code> 创建的 <code>GlyphVector</code>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.font.GlyphVector java.awt.Font.layoutGlyphVector(FontRenderContext frc, char[] text, int start, int limit, int flags)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个新 <code>GlyphVector</code> 对象，执行完整的文本布局（如有可能）。复杂文本要求有完整布局，如 Arabic 或 Hindi。对不同脚本的支持取决于字体和实现。  
<p>
 Layout requires bidi analysis, as performed by 
 <code>Bidi</code> 只应该在具有统一方向的文本上执行。用 flags 参数来指示方向，通过使用 LAYOUT_RIGHT_TO_LEFT 来指示从右到左（Arabic 和 Hebrew）的运行方向，或通过使用 LAYOUT_LEFT_TO_RIGHT 来指示从左到右 (English) 的运行方向。
 <p>
此外，有些操作（比如 Arabic 整形）需要上下文，这样在开始和结束处的字符才会有合适的形状。有时，在所提供范围之外的缓冲区中的数据并不是有效数据。可以将值 LAYOUT_NO_START_CONTEXT 和 LAYOUT_NO_LIMIT_CONTEXT 添加到 flags 参数中，分别指示在 start 之前或 limit 之后的文本不应该作为上下文进行检查。
 <p>
flags 参数的所有其他值均被保留。
 
@param frc 指定的 <code>FontRenderContext</code>
@param text 要布局的文本
@param start <code>GlyphVector</code> 所要使用的文本的起始处
@param limit <code>GlyphVector</code> 所要使用的文本的结束处
@param flags 如上所述的控制标志
@return 一个新 <code>GlyphVector</code>，表示 start 和 limit 之间的文本，具有经过选择和定位的字形，以便以最佳方式表示文本
@throws ArrayIndexOutOfBoundsException 如果 start 或 limit 超出了边界
@see java.text.Bidi
@see #LAYOUT_LEFT_TO_RIGHT
@see #LAYOUT_RIGHT_TO_LEFT
@see #LAYOUT_NO_START_CONTEXT
@see #LAYOUT_NO_LIMIT_CONTEXT
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void java.awt.Font.finalize() throws java.lang.Throwable
<!-- END KEY -->
<!-- BEGIN DATA -->
移除本机 <code>Font</code> 对象。

<!-- END DATA -->
<!-- BEGIN KEY -->
private void java.awt.Font.readObject(ObjectInputStream s) throws java.lang.ClassNotFoundException, java.io.IOException
<!-- END KEY -->
<!-- BEGIN DATA -->
读取 <code>ObjectInputStream</code>。未识别的密钥或值将被忽略。

@param s 要读取的 <code>ObjectInputStream</code>
@serial
@see #writeObject(java.io.ObjectOutputStream)

<!-- END DATA -->
<!-- BEGIN KEY -->
private void java.awt.Font.writeObject(ObjectOutputStream s) throws java.lang.ClassNotFoundException, java.io.IOException
<!-- END KEY -->
<!-- BEGIN DATA -->
将默认的可序列化字段写入流中。

@param s 要写入的 <code>ObjectOutputStream</code>
@see AWTEventMulticaster#save(ObjectOutputStream, String, EventListener)
@see #readObject(java.io.ObjectInputStream)

<!-- END DATA -->
