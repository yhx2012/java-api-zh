<!-- BEGIN KEY -->
public abstract class java.awt.Toolkit extends java.lang.Object
<!-- END KEY -->
<!-- BEGIN DATA -->
此类是所有 Abstract Window Toolkit 实际实现的抽象超类。<code>Toolkit</code> 的子类被用于将各种组件绑定到特定本机工具包实现。
 <p>
许多 GUI 操作可以异步执行。这意味着如果设置某一组件的状态，随后立刻查询该状态，则返回的值可能并没有反映所请求的更改。这包括但不局限于以下操作：
 <ul>
<li>滚动到指定位置。<br>例如，如果原始请求没有被处理，那么调用 <code>ScrollPane.setScrollPosition</code> 并随后调用 <code>getScrollPosition</code> 可能返回一个不正确的值。
 <p>
<li>将焦点从一个组件移动到另一个组件。<br>有关更多信息，请参阅 <a href="http://java.sun.com/docs/books/tutorial/uiswing/">The Swing Tutorial</a> 的 <a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html#transferTiming">Timing Focus Transfers</a> 一节。
 <p>
<li>使顶层容器可见。<br>对 <code>Window</code>、<code>Frame</code> 或 <code>Dialog</code> 调用 <code>setVisible(true)</code> 可能异步发生。
 <p>
<li>设置顶层容器的大小或位置。<br>对 <code>Window</code>、<code>Frame</code> 或 <code>Dialog</code> 调用 <code>setSize</code>、<code>setBounds</code> 或 <code>setLocation</code> 将被转发到底层窗口管理系统，并可能被忽略或修改。有关更多信息，请参阅 {@link java.awt.Window}。
 </ul>
 <p>
大多数应用程序不应直接调用该类中的任何方法。<code>Toolkit</code> 定义的方法是一种&ldquo;胶水&rdquo;，将 <code>java.awt</code> 包中与平台无关的类与 <code>java.awt.peer</code> 中的对应物连接起来。<code>Toolkit</code> 定义的一些方法能直接查询本机操作系统。

@version 	1.203, 12/19/03
@author	Sami Shaio
@author	Arthur van Hoff
@author	Fred Ecks
@since       JDK1.0

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.DesktopPeer java.awt.Toolkit.createDesktopPeer(Desktop target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定的同位体接口创建此工具包的 <code>Desktop</code> 实现。
 @param     target 要实现的 Desktop
 @return    此工具包的 <code>Desktop</code> 实现
 @exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
 @see       java.awt.GraphicsEnvironment#isHeadless
 @see       java.awt.Desktop
 @see       java.awt.peer.DesktopPeer
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.ButtonPeer java.awt.Toolkit.createButton(Button target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>Button</code> 实现。
@param     target 要实现的按钮。
@return    此工具包的 <code>Button</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.Button
@see       java.awt.peer.ButtonPeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.TextFieldPeer java.awt.Toolkit.createTextField(TextField target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>TextField</code> 实现。
@param     target 要实现的文本字段。
@return    此工具包的 <code>TextField</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.TextField
@see       java.awt.peer.TextFieldPeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.LabelPeer java.awt.Toolkit.createLabel(Label target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>Label</code> 实现。
@param     target 要实现的标签。
@return    此工具包的 <code>Label</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.Label
@see       java.awt.peer.LabelPeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.ListPeer java.awt.Toolkit.createList(List target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>List</code> 实现。
@param     target 要实现的列表。
@return    此工具包的 <code>List</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.List
@see       java.awt.peer.ListPeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.CheckboxPeer java.awt.Toolkit.createCheckbox(Checkbox target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>Checkbox</code> 实现。
@param     target 要实现的复选框。
@return    此工具包的 <code>Checkbox</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.Checkbox
@see       java.awt.peer.CheckboxPeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.ScrollbarPeer java.awt.Toolkit.createScrollbar(Scrollbar target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>Scrollbar</code> 实现。
@param     target 要实现的滚动条。
@return    此工具包的 <code>Scrollbar</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.Scrollbar
@see       java.awt.peer.ScrollbarPeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.ScrollPanePeer java.awt.Toolkit.createScrollPane(ScrollPane target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>ScrollPane</code> 实现。
@param     target 要实现的滚动窗格。
@return    此工具包的 <code>ScrollPane</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.ScrollPane
@see       java.awt.peer.ScrollPanePeer
@since     JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.TextAreaPeer java.awt.Toolkit.createTextArea(TextArea target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>TextArea</code> 实现。
@param     target 要实现的文本字区域。
@return    此工具包的 <code>TextArea</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.TextArea
@see       java.awt.peer.TextAreaPeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.ChoicePeer java.awt.Toolkit.createChoice(Choice target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>Choice</code> 实现。
@param     target 要实现的选择。
@return    此工具包的 <code>Choice</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.Choice
@see       java.awt.peer.ChoicePeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.FramePeer java.awt.Toolkit.createFrame(Frame target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>Frame</code> 实现。
@param     target 要实现的窗体。
@return    此工具包的 <code>Frame</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.Frame
@see       java.awt.peer.FramePeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.CanvasPeer java.awt.Toolkit.createCanvas(Canvas target)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>Canvas</code> 实现。
@param     target 要实现的画布。
@return    此工具包的 <code>Canvas</code> 实现。
@see       java.awt.Canvas
@see       java.awt.peer.CanvasPeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.PanelPeer java.awt.Toolkit.createPanel(Panel target)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>Panel</code> 实现。
@param     target 要实现的面板。
@return    此工具包的 <code>Panel</code> 实现。
@see       java.awt.Panel
@see       java.awt.peer.PanelPeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.WindowPeer java.awt.Toolkit.createWindow(Window target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>Window</code> 实现。
@param     target 要实现的窗口。
@return    此工具包的 <code>Window</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.Window
@see       java.awt.peer.WindowPeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.DialogPeer java.awt.Toolkit.createDialog(Dialog target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>Dialog</code> 实现。
@param     target 要实现的对话框。
@return    此工具包的 <code>Dialog</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.Dialog
@see       java.awt.peer.DialogPeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.MenuBarPeer java.awt.Toolkit.createMenuBar(MenuBar target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>MenuBar</code> 实现。
@param     target 要实现的菜单栏。
@return    此工具包的 <code>MenuBar</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.MenuBar
@see       java.awt.peer.MenuBarPeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.MenuPeer java.awt.Toolkit.createMenu(Menu target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>Menu</code> 实现。
@param     target 要实现的菜单。
@return    此工具包的 <code>Menu</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.Menu
@see       java.awt.peer.MenuPeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.PopupMenuPeer java.awt.Toolkit.createPopupMenu(PopupMenu target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>PopupMenu</code> 实现。
@param     target 要实现的弹出菜单。
@return    此工具包的 <code>PopupMenu</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.PopupMenu
@see       java.awt.peer.PopupMenuPeer
@since     JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.MenuItemPeer java.awt.Toolkit.createMenuItem(MenuItem target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>MenuItem</code> 实现。
@param     target 要实现的菜单项。
@return    此工具包的 <code>MenuItem</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.MenuItem
@see       java.awt.peer.MenuItemPeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.FileDialogPeer java.awt.Toolkit.createFileDialog(FileDialog target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>FileDialog</code> 实现。
@param     target 要实现的文件对话框。
@return    此工具包的 <code>FileDialog</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.FileDialog
@see       java.awt.peer.FileDialogPeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.CheckboxMenuItemPeer java.awt.Toolkit.createCheckboxMenuItem(CheckboxMenuItem target) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>CheckboxMenuItem</code> 实现。
@param     target 要实现的复选菜单项。
@return    此工具包的 <code>CheckboxMenuItem</code> 实现。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.CheckboxMenuItem
@see       java.awt.peer.CheckboxMenuItemPeer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.awt.peer.MouseInfoPeer java.awt.Toolkit.getMouseInfoPeer()
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>MouseInfo</code> 实现。
@return    此工具包的 <code>MouseInfo</code> 的帮助器实现
@throws    UnsupportedOperationException 如果没有实现此操作
@see       java.awt.peer.MouseInfoPeer
@see       java.awt.MouseInfo
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.awt.peer.LightweightPeer java.awt.Toolkit.createComponent(Component target)
<!-- END KEY -->
<!-- BEGIN DATA -->
创建组件或容器的同位体。此同位体是无窗口的，允许直接扩展 Component 和 Container 类，以创建完全在 Java 中定义的无窗口组件。

@param     target 要创建的 Component。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.peer.FontPeer java.awt.Toolkit.getFontPeer(String name, int style)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定同位体接口创建此工具包的 <code>Font</code> 实现。
@param     name 要实现的字体
@param     style 字体样式，比如 <code>PLAIN</code>、<code>BOLD</code>、<code>ITALIC</code> 或它们的组合
@return    此工具包的 <code>Font</code> 实现
@see       java.awt.Font
@see       java.awt.peer.FontPeer
@see       java.awt.GraphicsEnvironment#getAllFonts
@deprecated  请参阅 java.awt.GraphicsEnvironment#getAllFonts

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void java.awt.Toolkit.loadSystemColors(int[] systemColors) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用当前系统颜色值填充作为参数提供的整数数组。

@param   systemColors 一个整数数组。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@since     JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Toolkit.setDynamicLayout(boolean dynamic) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
控制 Container 的布局是在调整大小期间动态地生效，还是在完成调整大小后静态地生效。注意，并非所有平台都支持此功能，反之，在某些平台上不能关闭此功能。在不支持（或总是支持）调整大小期间动态布局的平台上设置此属性无效。注意，在某些平台上，此功能可以作为操作系统或窗口管理器的一个属性来设置或取消设置。在这种平台上，在此方法生效前，必须在操作系统或窗口管理器级别上设置动态调整大小的属性。此方法不能改变底层操作系统或窗口管理器的支持或设置。使用 getDesktopProperty(&quot;awt.dynamicLayoutSupported&quot;) 可以查询 OS/WM 支持。

@param     dynamic  如果该参数为 true，则在调整 Container 大小时重新布置其组件。如果该参数为 false，则布局将在重新调整大小后生效。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       #isDynamicLayoutSet()
@see       #isDynamicLayoutActive()
@see       #getDesktopProperty(String propertyName)
@see       java.awt.GraphicsEnvironment#isHeadless
@since     1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
protected boolean java.awt.Toolkit.isDynamicLayoutSet() throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 Container 的布局是在调整大小期间动态地生效，还是在完成调整大小后静态地生效。注：此方法返回的值是以编程方式设置的，不会影响调整大小时对动态布局的操作系统或窗口管理器级的支持，也不会影响当前操作系统或窗口管理器设置。使用 getDesktopProperty(&quot;awt.dynamicLayoutSupported&quot;) 可以查询 OS/WM 支持。

@return    如果动态地使 Container 有效，则返回 true，如果在结束对大小的调整后使 Containers 有效，则返回 false。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       #setDynamicLayout(boolean dynamic)
@see       #isDynamicLayoutActive()
@see       #getDesktopProperty(String propertyName)
@see       java.awt.GraphicsEnvironment#isHeadless
@since     1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Toolkit.isDynamicLayoutActive() throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
返回当前是否激活了调整大小时的动态布局（以编程方式设置，并受底层操作系统和/或窗口管理器支持）。使用 getDesktopProperty(&quot;awt.dynamicLayoutSupported&quot;) 可以查询 OS/WM 支持。

@return    如果当前激活了调整大小时的动态布局，则返回 true；否则返回 false。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       #setDynamicLayout(boolean dynamic)
@see       #isDynamicLayoutSet()
@see       #getDesktopProperty(String propertyName)
@see       java.awt.GraphicsEnvironment#isHeadless
@since     1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract java.awt.Dimension java.awt.Toolkit.getScreenSize() throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取屏幕的大小。在具有多个显示屏的系统上，使用主显示屏。从 <code>GraphicsConfiguration</code> 和 <code>GraphicsDevice</code> 可以获得多屏幕感知显示尺寸。
@return    此工具包的屏幕大小，以像素为单位。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsConfiguration#getBounds
@see       java.awt.GraphicsDevice#getDisplayMode
@see       java.awt.GraphicsEnvironment#isHeadless

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract int java.awt.Toolkit.getScreenResolution() throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
返回屏幕分辨率，以每英寸的点数为单位。
@return    此工具包的屏幕分辨率，以每英寸的点数为单位。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Insets java.awt.Toolkit.getScreenInsets(GraphicsConfiguration gc) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
获得屏幕的 insets。
@param     gc 一个 <code>GraphicsConfiguration</code>
@return    此工具包屏幕的 insets，以像素为单位。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@since     1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract java.awt.image.ColorModel java.awt.Toolkit.getColorModel() throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
确定此工具包屏幕的颜色模型。
 <p>
<code>ColorModel</code> 是一个抽象类，封装了图像的像素值及其红色、绿色、蓝色和 alpha 组件之间的转换能力。
 <p>
此工具包方法由 <code>Component</code> 类的 <code>getColorModel</code> 方法调用。
@return    此工具包屏幕的颜色模型。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.image.ColorModel
@see       java.awt.Component#getColorModel

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract java.lang.String[] java.awt.Toolkit.getFontList()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此工具包中可用字体的名称。<p>
在 1.1 中，以下字体名称已经过时，括号内是替代名称：
 <ul>
<li>TimesRoman（使用 Serif 替代）
<li>Helvetica（使用 SansSerif 替代）
<li>Courier（使用 Monospaced 替代）
 </ul><p>
在 1.1 中字体名称 ZapfDingbats 也已经过时，但 Unicode 中定义的字符从 0x2700 开始。从 1.1 开始，Java 支持这些字符。
@return    此工具包中可用字体的名称。
@deprecated 请参阅 {@link java.awt.GraphicsEnvironment#getAvailableFontFamilyNames()}
@see java.awt.GraphicsEnvironment#getAvailableFontFamilyNames()

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract java.awt.FontMetrics java.awt.Toolkit.getFontMetrics(Font font)
<!-- END KEY -->
<!-- BEGIN DATA -->
获取呈现字体的屏幕设备规格。
@param     font   字体
@return    此工具包中指定字体的屏幕规格
@deprecated  从 JDK version 1.2 开始，由 <code>Font</code> 方法 <code>getLineMetrics</code> 取代。
@see java.awt.font.LineMetrics
@see java.awt.Font#getLineMetrics
@see java.awt.GraphicsEnvironment#getScreenDevices

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract void java.awt.Toolkit.sync()
<!-- END KEY -->
<!-- BEGIN DATA -->
同步此工具包的图形状态。某些窗口系统可能会缓存图形事件。
 <p>
此方法确保显示是最新的。这在动画制作时很有用。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static synchronized java.awt.Toolkit java.awt.Toolkit.getDefaultToolkit()
<!-- END KEY -->
<!-- BEGIN DATA -->
获取默认工具包。
 <p>
如果名为 <code>"java.awt.headless"</code> 的系统属性被设置为 <code>true</code>，则使用 <code>Toolkit</code> 的 headless 实现。
 <p>
 如果不存在 <code>"java.awt.headless"</code> 或 <code>"java.awt.headless"</code> 被设置为 <code>false</code>，且存在名为 <code>"awt.toolkit"</code> 的系统属性，则该属性将被视为 <code>Toolkit</code> 子类的名称；否则将使用特定于平台的默认 <code>Toolkit</code> 实现。
 <p>
还可以使用 Sun 引用实现中指定的属性 'assistive_technologies' 将其他类加载到 VM 中，该属性是在 'accessibility.properties' 文件的一个行中指定的。形式是 &quot;assistive_technologies=...&quot;，其中 &quot;...&quot; 是以逗号分隔的、要加载的辅助技术类的列表。每个类都以给定的顺序加载，并且要使用 Class.forName(class).newInstance() 创建每个类的单独实例。此操作在创建 AWT 工具包之后进行。所有错误都通过 AWTError 异常来处理。
@return    默认工具包。
@exception  AWTError 如果不能找到工具包，或者不能访问或实例化工具包。

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract java.awt.Image java.awt.Toolkit.getImage(String filename)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一幅图像，该图像从指定文件中获取像素数据，图像格式可以是 GIF、JPEG 或 PNG。底层工具包试图对具有相同文件名的多个请求返回相同的 Image。
 <p>
因为便利 <code>Image</code> 对象共享所需的机制可能在一段不明确的时间内继续保存不再使用的图像，所以鼓励开发者在所有可能的地方使用 {@link #createImage(java.lang.String) createImage} 变体实现自己的图像缓存。
如果包含在指定文件中的图像数据发生了更改，则此方法返回的 <code>Image</code> 对象仍然包含前一个调用之后从该文件加载的旧信息。
通过对返回的 <code>Image</code> 调用 {@link Image#flush flush} 方法，可以手动丢弃以前加载的信息。
 <p>
 此方法首先检查是否安装了安全管理器。
如果安装了安全管理器，则该方法使用指定的文件调用安全管理器的 <code>checkRead</code> 方法，以确保允许访问该图像。
@param     filename   以可识别文件格式包含像素数据的文件名。
@return   从指定文件中获取像素数据的图像。
@throws SecurityException  如果存在安全管理器且其 checkListen 方法不允许该操作。
@see #createImage(java.lang.String)

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract java.awt.Image java.awt.Toolkit.getImage(URL url)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一幅图像，该图像从指定 URL 获取像素数据。通过指定 URL 引用的像素数据必须使用以下格式之一：GIF、JPEG 或 PNG。底层工具包试图对具有相同 URL 的多个请求返回相同的 Image。
<p>
因为便利 <code>Image</code> 对象共享所需的机制可能在一段不明确的时间内继续保存不再使用的图像，所以鼓励开发者在所有可能的地方使用 {@link #createImage(java.net.URL) createImage} 变体实现自己的图像缓存。
如果包含在指定 URL 中的图像数据发生了更改，则此方法返回的 <code>Image</code> 对象仍然包含前一个调用之后从该 URL 加载的旧信息。
通过对返回的 <code>Image</code> 调用 {@link Image#flush flush} 方法，可以手动丢弃以前加载的信息。
 <p>
 此方法首先检查是否安装了安全管理器。
如果安装了安全管理器，则该方法通过 url.openConnection().getPermission() 权限调用安全管理器的 <code>checkRead</code> 方法，以确保允许访问该图像。为了与 1.2 以前的安全管理器兼容，如果通过 <code>FilePermission</code> 或 <code>SocketPermission</code> 的访问被拒绝，而对应的 1.1 样式的 SecurityManager.checkXXX 也拒绝访问，则该方法抛出 <code>SecurityException</code>。
@param     url   用来获取像素数据的 URL。
@return    从指定 URL 获取像素数据的图像。
@throws SecurityException  如果存在安全管理器且其 checkPermission 方法不允许该操作。
@see #createImage(java.net.URL)

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract java.awt.Image java.awt.Toolkit.createImage(String filename)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回从指定文件获取像素数据的图像。返回的 Image 是一个新对象，该对象不再由此方法的其他任何调用者或其 getImage 变体共享。
 <p>
此方法首先检查是否安装了安全管理器。如果安装了安全管理器，则该方法使用指定的文件调用安全管理器的 <code>checkRead</code> 方法，以确保允许创建该图像。
@param     filename   以可识别文件格式包含像素数据的文件名。
@return    从指定文件获取像素数据的图像。
@throws SecurityException  如果存在安全管理器且其 checkRead 方法不允许该操作。
@see #getImage(java.lang.String)

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract java.awt.Image java.awt.Toolkit.createImage(URL url)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一幅图像，该图像从指定 URL 获取像素数据。返回的 Image 是一个新对象，该对象不再由此方法的其他任何调用者或其 getImage 变体共享。
 <p>
此方法首先检查是否安装了安全管理器。如果安装了安全管理器，则该方法通过 url.openConnection().getPermission() 权限调用安全管理器的 <code>checkPermission</code> 方法，以确保允许创建图像。为了与 1.2 以前的安全管理器兼容，如果通过 <code>FilePermission</code> 或 <code>SocketPermission</code> 的访问被拒绝，而对应的 1.1 样式的 SecurityManager.checkXXX 也拒绝访问，则该方法抛出 <code>SecurityException</code>。
@param     url   用来获取像素数据的 URL。
@return    从指定 URL 获取像素数据的图像。
@throws SecurityException  如果存在安全管理器且其 checkPermission 方法不允许该操作。
@see #getImage(java.net.URL)

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract boolean java.awt.Toolkit.prepareImage(Image image, int width, int height, ImageObserver observer)
<!-- END KEY -->
<!-- BEGIN DATA -->
准备一个用于呈现的图像。
 <p>
如果 width 和 height 参数的值均为 <code>-1</code>，则此方法在默认屏幕上准备一个用于呈现的图像；否则此方法在默认屏幕上以指定宽度和高度准备一个用于呈现的图像。
 <p>
图像数据由另一个线程异步下载，并将生成适当缩放的图像屏幕表示形式。
 <p>
此方法由组件的 <code>prepareImage</code> 方法调用。
 <p>
可在 <code>ImageObserver</code> 接口的定义中找到有关此方法返回的标志的信息。

@param     image      准备屏幕显示的图像。
@param     width      需要的屏幕显示宽度，或为 <code>-1</code>。
@param     height      需要的屏幕显示高度，或为 <code>-1</code>。
@param     observer   在准备图像时要通知的 <code>ImageObserver</code> 对象。
@return    如果已完全准备好了图像，则返回 <code>true</code>；否则返回 <code>false</code>。
@see       java.awt.Component#prepareImage(java.awt.Image, java.awt.image.ImageObserver)
@see       java.awt.Component#prepareImage(java.awt.Image, int, int, java.awt.image.ImageObserver)
@see       java.awt.image.ImageObserver

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract int java.awt.Toolkit.checkImage(Image image, int width, int height, ImageObserver observer)
<!-- END KEY -->
<!-- BEGIN DATA -->
指示正准备显示的指定图像的构造状态。
 <p>
如果 width 和 height 参数的值均为 <code>-1</code>，则此方法返回此工具包中指定图像屏幕表示形式的构造状态。否则，此方法以指定宽度和高度返回图像缩放表示形式的构造状态。
 <p>
此方法不会导致开始加载图像。应用程序必须调用 <code>prepareImage</code> 来强制加载图像。
 <p>
此方法由组件的 <code>checkImage</code> 方法调用。
 <p>
可在 <code>ImageObserver</code> 接口的定义中找到有关此方法返回的标志的信息。
@param     image   要检查状态的图像。
@param     width   要检查状态的图像的缩放宽度，或为 <code>-1</code>。
@param     height   要检查状态的图像的缩放高度，或为 <code>-1</code>。
@param     observer   在准备图像时要通知的 <code>ImageObserver</code> 对象。
@return    当前可用图像数据的 <code>ImageObserver</code> 标志的逐位 <strong>OR</strong>。
@see       java.awt.Toolkit#prepareImage(java.awt.Image, int, int, java.awt.image.ImageObserver)
@see       java.awt.Component#checkImage(java.awt.Image, java.awt.image.ImageObserver)
@see       java.awt.Component#checkImage(java.awt.Image, int, int, java.awt.image.ImageObserver)
@see       java.awt.image.ImageObserver

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract java.awt.Image java.awt.Toolkit.createImage(ImageProducer producer)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定的图像生成器创建一幅图像。
@param     producer 要使用的图像生成器。
@return    使用指定图像生成器创建的图像。
@see       java.awt.Image
@see       java.awt.image.ImageProducer
@see       java.awt.Component#createImage(java.awt.image.ImageProducer)

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Image java.awt.Toolkit.createImage(byte[] imagedata)
<!-- END KEY -->
<!-- BEGIN DATA -->
创建一幅图像，该图像对存储在指定字节数组中的图像进行解码。
 <p>
数据必须使用此工具包支持的图像格式存储，比如 GIF 或 JPEG。
@param     imagedata   字节数组，表示用受支持图像格式存储的图像数据。
@return    一幅图像。
@since     JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract java.awt.Image java.awt.Toolkit.createImage(byte[] imagedata, int imageoffset, int imagelength)
<!-- END KEY -->
<!-- BEGIN DATA -->
创建一幅图像，该图像对存储在指定字节数组中指定偏移量和长度处的图像进行解码。数据必须用受此工具包支持的图像格式存储，比如  GIF 或 JPEG。
@param     imagedata   字节数组，表示用受支持图像格式存储的图像。
@param     imageoffset  数组中数据开始的偏移量。
@param     imagelength  数组中数据的长度。
@return    一幅图像。
@since     JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract java.awt.PrintJob java.awt.Toolkit.getPrintJob(Frame frame, String jobtitle, Properties props)
<!-- END KEY -->
<!-- BEGIN DATA -->
获取一个 <code>PrintJob</code> 对象，该对象是在工具包平台上初始化某个打印操作的结果。
 <p>
此方法的每个实际实现都应该先检查是否安装了安全管理器。如果安装了安全管理器，则该方法应该调用安全管理器的 <code>checkPrintJobAccess</code> 方法，以确保允许初始化打印操作。如果使用 <code>checkPrintJobAccess</code> 的默认实现（即未重写该方法），则将导致使用 <code>RuntimePermission(&quot;queuePrintJob&quot;)</code> 权限调用安全管理器的 <code>checkPermission</code> 方法。

@param	frame 打印对话框的父容器。不能为 null。
@param	jobtitle PrintJob 的标题。null 标题等同于 &quot;&quot;。
@param	props 包含零个或更多属性的 Properties 对象。这些属性没有被标准化，并且在各个实现之间不一致。因此，要求作业和页面控制的 PrintJob 应该使用此方法带有 JobAttributes 和 PageAttributes 对象的版本。可以更新此对象来反映用户离开时的作业选择。可以为 null。

@return	一个 <code>PrintJob</code> 对象；如果用户取消打印作业，则返回 <code>null</code>。
@throws	NullPointerException 如果 frame 为 null。GraphicsEnvironment.isHeadless() 返回 true 时总是抛出此异常。
@throws	SecurityException 如果此线程不允许初始化打印作业请求
@see     java.awt.GraphicsEnvironment#isHeadless
@see	java.awt.PrintJob
@see	java.lang.RuntimePermission
@since	JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.PrintJob java.awt.Toolkit.getPrintJob(Frame frame, String jobtitle, JobAttributes jobAttributes, PageAttributes pageAttributes)
<!-- END KEY -->
<!-- BEGIN DATA -->
获取一个 <code>PrintJob</code> 对象，该对象是在工具包平台上初始化某个打印操作的结果。
 <p>
此方法的每个实际实现都应该先检查是否安装了安全管理器。如果安装了安全管理器，则该方法应该调用安全管理器的 <code>checkPrintJobAccess</code> 方法，以确保允许初始化打印操作。如果使用 <code>checkPrintJobAccess</code> 的默认实现（即未重写该方法），则将导致使用 <code>RuntimePermission(&quot;queuePrintJob&quot;)</code> 权限调用安全管理器的 <code>checkPermission</code> 方法。

@param	frame 打印对话框的父级。当且仅当 jobAttributes 不为 null 且 jobAttributes.getDialog() 返回	JobAttributes.DialogType.NONE 或 JobAttributes.DialogType.COMMON 时，该参数可为 null。
@param	jobtitle PrintJob 的标题。null 标题等同于 &quot;&quot;。
@param	jobAttributes 控制 PrintJob 的作业属性集合。这些属性将被更新，以反映用户的选择，这概括在 JobAttributes 文档中。可以为 null。
@param	pageAttributes 控制 PrintJob 的页面属性集合。这些属性将应用于作业中的每个页面。这些属性将被更新，以反映用户的选择，这概括在 PageAttributes 文档中。可以为 null。

@return	一个 <code>PrintJob</code> 对象；如果用户取消打印作业，则返回 <code>null</code>。
@throws	NullPointerException 如果 frame 为 null，并且 jobAttributes 为 null 或者 jobAttributes.getDialog() 返回 JobAttributes.DialogType.NATIVE。
@throws	IllegalArgumentException 如果 pageAttributes 通过馈送然后解析馈送这一过程来指定不同之处。如果此线程可访问文件系统且 jobAttributes 指定打印到文件，则出现以下情况时也将抛出该异常：指定目标文件存在但它是一个目录而不是常规文件；指定目标文件不存在但不能创建；指定目标文件由于某些其他原因无法打开。但是，在指定打印到文件的情况下，如果同时请求了显示对话框，那么用户将有机会选择一个文件并继续打印。在从此方法返回前，该对话框将保证选择的输出文件有效。
          <p>
GraphicsEnvironment.isHeadless() 返回 true 时总是抛出此异常。
@throws	SecurityException 如果此线程不允许初始化打印作业请求，或者 jobAttributes 指定打印到文件，并且此线程不允许访问该文件系统
@see	java.awt.PrintJob
@see   java.awt.GraphicsEnvironment#isHeadless
@see	java.lang.RuntimePermission
@see	java.awt.JobAttributes
@see	java.awt.PageAttributes
@since	1.3

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract void java.awt.Toolkit.beep()
<!-- END KEY -->
<!-- BEGIN DATA -->
发出一个音频嘟嘟声。
@since     JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract java.awt.datatransfer.Clipboard java.awt.Toolkit.getSystemClipboard() throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取系统 Clipboard 的一个实例，该 Clipboard 可作为本机平台提供的剪贴板工具的接口。该剪贴板使数据能够在 Java 应用程序和使用本机剪贴板工具的本机应用程序之间传输。
 <p>
除了 flavormap.properties 文件（或 <code>AWT.DnD.flavorMapFileURL</code> Toolkit 属性指定的其他文件）中指定的所有格式之外，系统 Clipboard 的 <code>getTransferData()</code> 方法返回的文本在以下 flavor 中是可用的：
 <ul>
 <li>DataFlavor.stringFlavor</li>
<li>DataFlavor.plainTextFlavor（<b>已过时</b>）</li>
 </ul>
在使用 <code>java.awt.datatransfer.StringSelection</code> 时，如果要求的 flavor 是 <code>DataFlavor.plainTextFlavor</code> 或等价 flavor，则返回一个 Reader。<b>注：</b>系统 Clipboard 针对 <code>DataFlavor.plainTextFlavor</code> 和等价 DataFlavor 的 <code>getTransferData()</code> 方法的行为与 <code>DataFlavor.plainTextFlavor</code> 的定义是不一致的。因此，对 <code>DataFlavor.plainTextFlavor</code> 和等价 flavor 的支持<b>已过时</b>。
 <p>
此方法的每个实际实现都应该先检查是否安装了安全管理器。如果安装了安全管理器，则此方法应该调用安全管理器的 <code>checkSystemClipboardAccess</code> 方法，以确保可以访问系统剪贴板。如果使用 <code>checkSystemClipboardAccess</code> 的默认实现（即未重写该方法），则将导致使用 <code>AWTPermission(&quot;accessClipboard&quot;)</code> 权限调用安全管理器的 <code>checkPermission</code> 方法。
 
@return    系统 Clipboard
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.datatransfer.Clipboard
@see       java.awt.datatransfer.StringSelection
@see       java.awt.datatransfer.DataFlavor#stringFlavor
@see       java.awt.datatransfer.DataFlavor#plainTextFlavor
@see       java.io.Reader
@see       java.awt.AWTPermission
@since     JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.datatransfer.Clipboard java.awt.Toolkit.getSystemSelection() throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
以 <code>Clipboard</code> 对象的形式获取系统选择的一个实例。这使应用程序能够读取和修改当前系统范围内的选择。
 <p>
无论用户在何时使用鼠标或键盘选择了文本，应用程序都要负责更新系统选择。通常，实现方式是在所有支持文本选择的 <code>Component</code> 上，以及传递给该 <code>Component</code> 的 <code>FOCUS_GAINED</code> 和 <code>FOCUS_LOST</code> 事件之间安装一个 <code>FocusListener</code>，并在 <code>Component</code> 内的选择发生更改时更新系统选择 <code>Clipboard</code>。恰当地更新系统选择确保了 Java 应用程序与本机应用程序和同时运行在系统上的其他 Java 应用程序正确交互。注意，<code>java.awt.TextComponent</code> 和 <code>javax.swing.text.JTextComponent</code> 已支持此策略。在使用这些类及其子类时，开发人员不需要编写任何额外的代码。
 <p>
一些平台不支持系统选择 <code>Clipboard</code>。在这些平台上，此方法将返回 <code>null</code>。在这种情况下，应用程序不再有责任更新系统选择 <code>Clipboard</code>（如上所述）。
 <p>
此方法的每个实际实现都应该先检查是否安装了 <code>SecurityManager</code>。如果是安装了 <code>SecurityManager</code>，则应调用 <code>SecurityManager</code> 的 <code>checkSystemClipboardAccess</code> 方法，以确保可以访问系统剪贴板。如果使用 <code>checkSystemClipboardAccess</code> 的默认实现（即如果未重写该方法），则将导致使用 <code>AWTPermission(&quot;accessClipboard&quot;)</code> 权限调用 <code>SecurityManager</code> 的 <code>checkPermission</code> 方法。
 
@return 以 <code>Clipboard</code> 形式返回系统选择，如果本机平台不支持系统选择 <code>Clipboard</code>，则返回 <code>null</code>
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true

@see java.awt.datatransfer.Clipboard
@see java.awt.event.FocusListener
@see java.awt.event.FocusEvent#FOCUS_GAINED
@see java.awt.event.FocusEvent#FOCUS_LOST
@see TextComponent
@see javax.swing.text.JTextComponent
@see AWTPermission
@see GraphicsEnvironment#isHeadless
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.awt.Toolkit.getMenuShortcutKeyMask() throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
确定哪一个修改键是菜单快捷方式的适当加速键。
 <p>
菜单快捷方式嵌入在 <code>MenuShortcut</code> 类中，由 <code>MenuBar</code> 类处理。
 <p>
默认情况下，此方法返回 <code>Event.CTRL_MASK</code>。如果 <b>Control</b> 键不是正确的加速键，则工具包实现应该重写此方法。
@return    此工具包中用于菜单快捷方式的 <code>Event</code> 类的修饰符掩码。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@see       java.awt.MenuBar
@see       java.awt.MenuShortcut
@since     JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Toolkit.getLockingKeyState(int keyCode) throws java.lang.UnsupportedOperationException
<!-- END KEY -->
<!-- BEGIN DATA -->
返回键盘上给定锁定键是否处于 &quot;on&quot; 状态。有效键代码是 {@link java.awt.event.KeyEvent#VK_CAPS_LOCK VK_CAPS_LOCK}、{@link java.awt.event.KeyEvent#VK_NUM_LOCK VK_NUM_LOCK}、{@link java.awt.event.KeyEvent#VK_SCROLL_LOCK VK_SCROLL_LOCK} 和 {@link java.awt.event.KeyEvent#VK_KANA_LOCK VK_KANA_LOCK}。

@exception java.lang.IllegalArgumentException 如果 <code>keyCode</code> 不是有效键代码之一
@exception java.lang.UnsupportedOperationException 如果主机系统不允许以编程方式获取此键的状态，或者键盘没有此键
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@since 1.3

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Toolkit.setLockingKeyState(int keyCode, boolean on) throws java.lang.UnsupportedOperationException
<!-- END KEY -->
<!-- BEGIN DATA -->
设置键盘上给定锁定键的状态。有效键代码是 {@link java.awt.event.KeyEvent#VK_CAPS_LOCK VK_CAPS_LOCK}、{@link java.awt.event.KeyEvent#VK_NUM_LOCK VK_NUM_LOCK}、{@link java.awt.event.KeyEvent#VK_SCROLL_LOCK VK_SCROLL_LOCK} 和 {@link java.awt.event.KeyEvent#VK_KANA_LOCK VK_KANA_LOCK}。
 <p>
根据不同的平台，设置锁定键的状态可能涉及事件处理，因此不能立即通过 getLockingKeyState 观察到。

@exception java.lang.IllegalArgumentException 如果 <code>keyCode</code> 不是有效键代码之一
@exception java.lang.UnsupportedOperationException 如果主机系统不允许以编程方式设置此键的状态，或者键盘没有此键
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@since 1.3

<!-- END DATA -->
<!-- BEGIN KEY -->
protected static java.awt.Container java.awt.Toolkit.getNativeContainer(Component c)
<!-- END KEY -->
<!-- BEGIN DATA -->
使本机同位体能够查询给定本机组件的本机容器（例如，直接父组件可以是轻量级的）。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Cursor java.awt.Toolkit.createCustomCursor(Image cursor, Point hotSpot, String name) throws java.lang.IndexOutOfBoundsException, java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
创建一个新的自定义光标对象。如果要显示的图像无效，则隐藏光标（使其完全透明），并将热点 (hotspot) 设置为（0，0）。 

<p>注意，多帧图像是无效的，可能造成此方法被挂起。

@param cursor 激活光标时要显示的图像
@param hotSpot 大光标热点的 X 和 Y 坐标；hotSpot 值必须小于 <code>getBestCursorSize</code> 返回的 Dimension
@param     name 光标的本地化描述，用于 Java Accessibility
@exception IndexOutOfBoundsException 如果 hotSpot 值超出光标边界
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@since     1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Dimension java.awt.Toolkit.getBestCursorSize(int preferredWidth, int preferredHeight) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
返回最接近所需大小的受支持光标尺寸。无论所需的大小如何，只支持单个光标大小的系统将返回该大小。不支持自定义光标的系统返回的尺寸将是 0, 0。 <p>
注：如果使用的图像尺寸不符合受支持的大小（由此方法返回的尺寸），则 Toolkit 实现会试着将图像的大小调整为受支持的大小。因为转换低分辨率图像存在一些困难，所以不保证不受支持大小的光标图像的质量。因此建议调用此方法并使用合适的图像，从而不需要转换图像。

@param     preferredWidth 组件将使用的首选光标宽度。
@param     preferredHeight 组件将使用的首选光标高度。
@return    最接近的受支持光标大小；如果 Toolkit 实现不支持自定义光标，则返回的尺寸为 0,0。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@since     1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.awt.Toolkit.getMaximumCursorColors() throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
返回自定义光标调色板中 Toolkit 支持的最大颜色数。<p>
注：如果图像调色板中使用的颜色超过所支持的最大颜色数，则 Toolkit 实现会试图将调色板所用颜色调整为最大颜色数。因为转换低分辨率图像存在一些困难，所以不保证颜色多于系统支持颜色的那些图像的质量。因此建议调用此方法并使用合适的图像，从而不需要转换图像。

@return    最大颜色数；如果 Toolkit 实现不支持自定义光标，则返回零。
@exception HeadlessException 如果 GraphicsEnvironment.isHeadless() 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@since     1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Toolkit.isFrameStateSupported(int state) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 Toolkit 是否支持 <code>Frame</code> 状态。此方法判断是否支持最大化或图标化的 <em>UI</em>。对于 <code>Frame.ICONIFIED|Frame.MAXIMIZED_VERT</code> 之类的&ldquo;复合&rdquo;状态，该方法总是返回 false。换句话说，根据经验只有使用单窗体状态常量作为参数的查询才是有意义的。

@param state 指定的窗体状态常量之一。
@return 如果此 Toolkit 实现支持窗体状态，则返回 <code>true</code>；否则返回 <code>false</code>。
@exception HeadlessException 如果 <code>GraphicsEnvironment.isHeadless()</code> 返回 <code>true</code>。
@see	java.awt.Frame#setExtendedState
@since	1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.lang.String java.awt.Toolkit.getProperty(String key, String defaultValue)
<!-- END KEY -->
<!-- BEGIN DATA -->
获取具有指定键和默认值的属性。如果未找到属性，此方法将返回 defaultValue。

<!-- END DATA -->
<!-- BEGIN KEY -->
public final java.awt.EventQueue java.awt.Toolkit.getSystemEventQueue()
<!-- END KEY -->
<!-- BEGIN DATA -->
获取应用程序或 applet 的 EventQueue 实例。根据 Toolkit 实现，对于不同的 applet，可能返回不同的 EventQueue。所以 applet 不能假设此方法返回的 EventQueue 实例将由其他 applet 或系统共享。
 
<p>如果存在安全管理器，则首先调用其 <code>checkAwtEventQueueAccess</code> 方法。如果使用 <code>checkAwtEventQueueAccess</code> 的默认实现（即未重写该方法），则将导致使用 <code>AWTPermission(&quot;accessEventQueue&quot;)</code> 权限调用安全管理器的 <code>checkPermission</code> 方法。
 
@return  <code>EventQueue</code> 对象
@throws  SecurityException 如果存在安全管理器且其 <code>{@link java.lang.SecurityManager#checkAwtEventQueueAccess}</code> 方法拒绝访问 <code>EventQueue</code>
@see     java.awt.AWTPermission

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract java.awt.EventQueue java.awt.Toolkit.getSystemEventQueueImpl()
<!-- END KEY -->
<!-- BEGIN DATA -->
获取应用程序或 applet 的 <code>EventQueue</code> 实例，不检查访问权。出于安全原因，只能从 <code>Toolkit</code> 子类调用此方法。
@return <code>EventQueue</code> 对象

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract java.awt.dnd.peer.DragSourceContextPeer java.awt.Toolkit.createDragSourceContextPeer(DragGestureEvent dge) throws java.awt.dnd.InvalidDnDOperationException
<!-- END KEY -->
<!-- BEGIN DATA -->
创建 DragSourceContext 的同位体。如果 GraphicsEnvironment.isHeadless() 返回 true，则总是抛出 InvalidDndOperationException。
@see java.awt.GraphicsEnvironment#isHeadless

<!-- END DATA -->
<!-- BEGIN KEY -->
public T extends java.awt.dnd.DragGestureRecognizer java.awt.Toolkit.createDragGestureRecognizer(java.lang.Class<T> abstractRecognizerClass, DragSource ds, Component c, int srcActions, DragGestureListener dgl)
<!-- END KEY -->
<!-- BEGIN DATA -->
创建所请求的抽象 DragGestureRecognizer 类的具体的、与平台有关的子类，并将它与指定的 DragSource、Component 和 DragGestureListener 关联。子类应该重写此方法，以提供自己的实现。

@param abstractRecognizerClass 所需识别器的抽象类
@param ds		      DragSource
@param c		      DragGestureRecognizer 的 Component 目标
@param srcActions	      允许用于该动作的操作
@param dgl		      DragGestureListener

@return 新的对象或 null。如果 GraphicsEnvironment.isHeadless() 返回 true，则总是返回 null。
@see java.awt.GraphicsEnvironment#isHeadless

<!-- END DATA -->
<!-- BEGIN KEY -->
public final synchronized java.lang.Object java.awt.Toolkit.getDesktopProperty(String propertyName)
<!-- END KEY -->
<!-- BEGIN DATA -->
获取指定桌面属性的值。桌面属性是作为 Toolkit 全局变量资源的惟一指定值。通常它也是与底层平台有关的桌面设置的抽象表示形式。 有关 AWT 支持的桌面属性的更多信息，请参阅 <a href="doc-files/DesktopProperties.html">AWT Desktop Properties</a>。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected final void java.awt.Toolkit.setDesktopProperty(String name, Object newValue)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定桌面属性设置为指定值，并触发一个属性更改事件，以通知所有侦听器该值已更改。 

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.lang.Object java.awt.Toolkit.lazilyLoadDesktopProperty(String name)
<!-- END KEY -->
<!-- BEGIN DATA -->
一个对桌面属性值延迟计算的机会。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void java.awt.Toolkit.initializeDesktopProperties()
<!-- END KEY -->
<!-- BEGIN DATA -->
initializeDesktopProperties

<!-- END DATA -->
<!-- BEGIN KEY -->
public synchronized void java.awt.Toolkit.addPropertyChangeListener(String name, PropertyChangeListener pcl)
<!-- END KEY -->
<!-- BEGIN DATA -->
为指定的桌面属性添加指定的属性更改侦听器。如果 pcl 为 null，则不抛出任何异常，且不执行任何操作。

@param	name 要监听的属性的名称
@param	pcl 属性更改侦听器
@since	1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public synchronized void java.awt.Toolkit.removePropertyChangeListener(String name, PropertyChangeListener pcl)
<!-- END KEY -->
<!-- BEGIN DATA -->
为指定的桌面属性移除指定的属性更改侦听器。如果 pcl 为 null，则不抛出任何异常，且不执行任何操作。

@param	name 要移除的属性的名称
@param	pcl 属性更改侦听器
@since	1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.beans.PropertyChangeListener[] java.awt.Toolkit.getPropertyChangeListeners()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回在此工具包上所有已注册的属性更改侦听器所组成的数组。

@return 此工具包的所有 <code>PropertyChangeListener</code>；如果当前没有注册的属性更改侦听器，则返回一个空数组

@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public synchronized java.beans.PropertyChangeListener[] java.awt.Toolkit.getPropertyChangeListeners(String propertyName)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回与指定属性关联的所有 <code>PropertyChangeListener</code> 所组成的数组。

@param  propertyName 指定的属性
@return 与指定属性关联的所有 <code>PropertyChangeListener</code>；如果没有添加这样的侦听器，则返回一个空数组
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Toolkit.isAlwaysOnTopSupported()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此工具包是否支持 always-on-top 模式。要检测特定窗口是否支持 always-on-top 模式，请使用 {@link Window#isAlwaysOnTopSupported}。
@return 如果当前工具包支持 always-on-top 模式，则返回 <code>true</code>；否则返回 <code>false</code>
@see Window#isAlwaysOnTopSupported
@see Window#setAlwaysOnTop(boolean)
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract boolean java.awt.Toolkit.isModalityTypeSupported(Dialog.ModalityType modalityType)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此工具包是否支持给定的模式类型。如果创建了带有不受支持的模式类型的对话框，则使用 <code>Dialog.ModalityType.MODELESS</code>。

@param modalityType 要检测是否受此工具包支持的模式类型

@return 如果当前工具包支持给定模式类型，则返回 <code>true</code>；否则返回 <code>false</code>

@see java.awt.Dialog.ModalityType
@see java.awt.Dialog#getModalityType
@see java.awt.Dialog#setModalityType

@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract boolean java.awt.Toolkit.isModalExclusionTypeSupported(Dialog.ModalExclusionType modalExclusionType)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此工具包是否支持给定的模式排斥类型。如果在窗口上设置了不受支持的模式排斥类型，则使用 <code>Dialog.ModalExclusionType.NO_EXCLUDE</code>。

 @param modalExclusionType 要检测是否受此工具包支持的模式排斥类型

 @return 如果当前工具包支持给定模式排斥类型，则返回 <code>true</code>；否则返回 <code>false</code>

 @see java.awt.Dialog.ModalExclusionType
 @see java.awt.Window#getModalExclusionType
 @see java.awt.Window#setModalExclusionType

 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Toolkit.addAWTEventListener(AWTEventListener listener, long eventMask)
<!-- END KEY -->
<!-- BEGIN DATA -->
添加一个 AWTEventListener，以接收与给定 <code>eventMask</code> 一致的系统范围内指派的所有 AWTEvent。
 <p>
首先，如果存在安全管理器，则使用 <code>AWTPermission(&quot;listenToAllAWTEvents&quot;)</code> 权限调用 <code>checkPermission</code> 方法。这可能导致 SecurityException 异常。 
 <p>
<code>eventMask</code> 是要接收的事件类型的位掩码。它是通过对 <code>AWTEvent</code> 中定义的事件掩码进行逐位 OR 得到的。
 <p>
注：对于一般的应用程序，不推荐使用事件侦听器，它只用于支持特定目的工具，包括支持可访问性、事件记录/回放和诊断跟踪。如果 listener 为 null，则不抛出任何异常，且不执行任何操作。

@param    listener   事件侦听器。
@param    eventMask 要接收的事件类型的位掩码
@throws  SecurityException 如果存在安全管理器且其 <code>checkPermission</code> 方法不允许进行此操作。
@see      #removeAWTEventListener
@see      #getAWTEventListeners
@see      SecurityManager#checkPermission
@see      java.awt.AWTEvent
@see      java.awt.AWTPermission
@see      java.awt.event.AWTEventListener
@see      java.awt.event.AWTEventListenerProxy
@since    1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Toolkit.removeAWTEventListener(AWTEventListener listener)
<!-- END KEY -->
<!-- BEGIN DATA -->
从正接收的指派 AWTEvent 中移除一个 AWTEventListener。
 <p>
首先，如果存在安全管理器，则使用 <code>AWTPermission(&quot;listenToAllAWTEvents&quot;)</code> 权限调用 <code>checkPermission</code> 方法。这可能导致 SecurityException 异常。 
 <p>
注：对于一般的应用程序，不推荐使用事件侦听器，它只用于支持特定目的工具，包括支持可访问性、事件记录/回放和诊断跟踪。如果 listener 为 null，则不抛出任何异常，且不执行任何操作。

@param    listener   事件侦听器。
@throws  SecurityException 如果存在安全管理器且其 <code>checkPermission</code> 方法不允许进行此操作。
@see      #addAWTEventListener
@see      #getAWTEventListeners
@see      SecurityManager#checkPermission
@see      java.awt.AWTEvent
@see      java.awt.AWTPermission
@see      java.awt.event.AWTEventListener
@see      java.awt.event.AWTEventListenerProxy
@since    1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.event.AWTEventListener[] java.awt.Toolkit.getAWTEventListeners()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回在此工具包上所有已注册 <code>AWTEventListener</code> 所组成的数组。如果存在安全管理器，则使用 {@code AWTPermission("listenToAllAWTEvents")} 权限调用它的 {@code checkPermission} 方法。这可能导致 SecurityException 异常。侦听器可以在 <code>AWTEventListenerProxy</code> 对象中返回，该对象还包含给定侦听器的事件掩码。注意，多次添加的侦听器对象在返回数组中只出现一次。

@return 所有 <code>AWTEventListener</code>；如果当前没有已注册侦听器，则返回一个空数组
@throws SecurityException 如果存在安全管理器且其 <code>checkPermission</code> 方法不允许进行此操作。
@see      #addAWTEventListener
@see      #removeAWTEventListener
@see      SecurityManager#checkPermission
@see      java.awt.AWTEvent
@see      java.awt.AWTPermission
@see      java.awt.event.AWTEventListener
@see      java.awt.event.AWTEventListenerProxy
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.event.AWTEventListener[] java.awt.Toolkit.getAWTEventListeners(long eventMask)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回已在此工具包上注册的所有 <code>AWTEventListener</code> 所组成的数组，这些侦听器侦听用 {@code eventMask} 参数指定的所有事件类型。如果存在安全管理器，则使用 {@code AWTPermission("listenToAllAWTEvents")} 权限调用它的 {@code checkPermission} 方法。这可能导致 SecurityException 异常。侦听器可以在 <code>AWTEventListenerProxy</code> 对象中返回，该对象还包含给定侦听器的事件掩码。注意，多次添加的侦听器对象在返回数组中只出现一次。

@param  eventMask 要监听的事件类型的位掩码
@return 已在此工具包上为指定事件类型注册的所有 <code>AWTEventListener</code>；如果当前没有这样的已注册侦听器，则返回一个空数组
@throws SecurityException 如果存在安全管理器且其 <code>checkPermission</code> 方法不允许该操作。
@see      #addAWTEventListener
@see      #removeAWTEventListener
@see      SecurityManager#checkPermission
@see      java.awt.AWTEvent
@see      java.awt.AWTPermission
@see      java.awt.event.AWTEventListener
@see      java.awt.event.AWTEventListenerProxy
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract java.util.Map<java.awt.font.TextAttribute, ?> java.awt.Toolkit.mapInputMethodHighlight(InputMethodHighlight highlight) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
返回给定输入方法高亮区的抽象级别描述的可视属性映射，如果不存在映射关系，则返回 null。输入方法高亮区的样式字段被忽略。返回的映射是不可修改的。
@param highlight 输入方法高亮区
@return 样式属性映射，或者返回 <code>null</code>
@exception HeadlessException 如果 <code>GraphicsEnvironment.isHeadless</code> 返回 true
@see       java.awt.GraphicsEnvironment#isHeadless
@since 1.3

<!-- END DATA -->
