<!-- BEGIN KEY -->
public abstract class java.util.Calendar extends java.lang.Object implements java.io.Serializable, java.lang.Cloneable, java.lang.Comparable
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>Calendar</code> 类是一个抽象类，它为特定瞬间与一组诸如 <code>YEAR</code>、<code>MONTH</code>、<code>DAY_OF_MONTH</code>、<code>HOUR</code> 等 {@link #fields 日历字段}之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。瞬间可用毫秒值来表示，它是距<a name="Epoch"><em>历元</em></a>（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。

<p>该类还为实现包范围外的具体日历系统提供了其他字段和方法。这些字段和方法被定义为 <code>protected</code>。

 <p>
与其他语言环境敏感类一样，<code>Calendar</code> 提供了一个类方法 <code>getInstance</code>，以获得此类型的一个通用的对象。<code>Calendar</code> 的 <code>getInstance</code> 方法返回一个 <code>Calendar</code> 对象，其日历字段已由当前日期和时间初始化：
 <blockquote>
 <pre>
     Calendar rightNow = Calendar.getInstance();
 </pre>
 </blockquote>

<p><code>Calendar</code> 对象能够生成为特定语言和日历风格实现日期-时间格式化所需的所有日历字段值，例如，日语-格里高里历，日语-传统日历。<code>Calendar</code> 定义了某些日历字段返回值的范围，以及这些值的含义。例如，对于所有日历，日历系统第一个月的值是 <code>MONTH == JANUARY</code>。其他值是由具体子类（例如 <code>ERA</code>）定义的。有关此内容的细节，请参阅每个字段的文档和子类文档。

<h4>获得并设置日历字段值</h4>

<p>可以通过调用 <code>set</code> 方法来设置日历字段值。在需要计算时间值（距历元所经过的毫秒）或日历字段值之前，不会解释 <code>Calendar</code> 中的所有字段值设置。调用 <code>get</code>、<code>getTimeInMillis</code>、<code>getTime</code>、<code>add</code> 和 <code>roll</code> 涉及此类计算。

<h4>宽松性</h4>

<p><code>Calendar</code> 有两种解释日历字段的模式，即 <em>lenient</em> 和 <em>non-lenient</em>。当 <code>Calendar</code> 处于 lenient 模式时，它可接受比它所生成的日历字段范围更大范围内的值。当 <code>Calendar</code> 重新计算日历字段值，以便由 <code>get()</code> 返回这些值时，所有日历字段都被标准化。例如，lenient 模式下的 <code>GregorianCalendar</code> 将 <code>MONTH == JANUARY</code>、<code>DAY_OF_MONTH == 32</code> 解释为 February 1。

<p>当 <code>Calendar</code> 处于 non-lenient 模式时，如果其日历字段中存在任何不一致性，它都会抛出一个异常。例如，<code>GregorianCalendar</code> 总是在 1 与月份的长度之间生成 <code>DAY_OF_MONTH</code> 值。如果已经设置了任何超出范围的字段值，那么在计算时间或日历字段值时，处于 non-lenient 模式下的 <code>GregorianCalendar</code> 会抛出一个异常。

<h4>第一个星期</h4>

<code>Calendar</code> 使用两个参数定义了特定于语言环境的 7 天制星期：星期的第一天和第一个星期中的最小一天（从 1 到 7）。这些数字取自构造 <code>Calendar</code> 时的语言环境资源数据。还可以通过为其设置值的方法来显式地指定它们。

<p>在设置或获得 <code>WEEK_OF_MONTH</code> 或 <code>WEEK_OF_YEAR</code> 字段时，<code>Calendar</code> 必须确定一个月或一年的第一个星期，以此作为参考点。一个月或一年的第一个星期被确定为开始于 <code>getFirstDayOfWeek()</code> 的最早七天，它最少包含那一个月或一年的 <code>getMinimalDaysInFirstWeek()</code> 天数。第一个星期之前的各星期编号为 ...、-1、0；之后的星期编号为 2、3、...。注意，<code>get()</code> 返回的标准化编号方式可能有所不同。例如，特定 <code>Calendar</code> 子类可能将某一年第 1 个星期之前的那个星期指定为前一年的第 <code><i>n</i></code> 个星期。

<h4>日历字段解析</h4>

在计算日历字段中的日期和时间时，可能没有足够的信息用于计算（例如只有年和月，但没有日），或者可能有不一致的信息( 例如 &quot;Tuesday, July 15, 1996&quot;（格林威治时间）&mdash;&mdash;实际上，1996 年 7 月 15 日是星期一 )。<code>Calendar</code> 将解析日历字段值，以便用以下方式确定日期和时间。

<p>如果日历字段值中存在任何冲突，则 <code>Calendar</code> 将为最近设置的日历字段提供优先权。以下是日历字段的默认组合。将使用由最近设置的单个字段所确定的最近组合。

<p><a name="date_resolution">对于日期字段</a>：
 <blockquote>
 <pre>
 YEAR + MONTH + DAY_OF_MONTH
 YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK
 YEAR + MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK
 YEAR + DAY_OF_YEAR
 YEAR + DAY_OF_WEEK + WEEK_OF_YEAR
 </pre></blockquote>

<a name="time_resolution">对于时间字段</a>：
 <blockquote>
 <pre>
 HOUR_OF_DAY
 AM_PM + HOUR
 </pre></blockquote>

<p>如果在选定的字段组合中，还有尚未设置值的任一日历字段，那么 <code>Calendar</code> 将使用其默认值。每个字段的默认值可能依据具体的日历系统而有所不同。例如，在 <code>GregorianCalendar</code> 中，字段的默认值与历元起始部分的字段值相同：即 <code>YEAR = 1970</code>、<code>MONTH = JANUARY</code>、<code>DAY_OF_MONTH = 1</code>，等等。

 <p>
<strong>注：</strong> 对于某些特别时间的解释可能会有某些歧义，可以用下列方式解决：
 <ol>
<li> 23:59 是一天中的最后一分钟，而 00:00 是下一天的第一分钟。因此，1999 年 12 月 31 日的 23:59 &lt; 2000 年 1 月 1 日的 00:00。

<li> 尽管从历史上看不够精确，但午夜也属于 "am",，中午属于 "pm"，所以在同一天，12:00 am ( 午夜 ) &lt; 12:01 am，12:00 pm ( 中午 ) &lt; 12:01 pm。
 </ol>

 <p>
日期或时间格式字符串不是日历定义的一部分，因为在运行时，用户必须能够修改或重写它们。可以使用 {@link DateFormat} 格式化日期。

<h4>字段操作</h4>
 
可以使用三种方法更改日历字段：<code>set()</code>、<code>add()</code> 和 <code>roll()</code>。</p>
 
<p><strong><code>set(f, value)</code></strong> 将日历字段 <code>f</code> 更改为 <code>value</code>。此外，它设置了一个内部成员变量，以指示日历字段 <code>f</code> 已经被更改。尽管日历字段 <code>f</code> 是立即更改的，但是直到下次调用 <code>get()</code>、<code>getTime()</code>、<code>getTimeInMillis()</code>、<code>add()</code> 或 <code>roll()</code> 时才会重新计算日历的时间值（以毫秒为单位）。因此，多次调用 <code>set()</code> 不会触发多次不必要的计算。使用 <code>set()</code> 更改日历字段的结果是，其他日历字段也可能发生更改，这取决于日历字段、日历字段值和日历系统。此外，在重新计算日历字段之后，<code>get(f)</code> 没必要通过调用 <code>set</code> 方法返回 <code>value</code> 集合。具体细节是通过具体的日历类确定的。</p>
 
<p><em>示例</em>：假定 <code>GregorianCalendar</code> 最初被设置为 1999 年 8 月 31 日。调用 <code>set(Calendar.MONTH, Calendar.SEPTEMBER)</code> 将该日期设置为 1999 年 9 月 31 日。如果随后调用 <code>getTime()</code>，那么这是解析 1999 年 10 月 1 日的一个暂时内部表示。但是，在调用 <code>getTime()</code> 之前调用 <code>set(Calendar.DAY_OF_MONTH, 30)</code> 会将该日期设置为 1999 年 9 月 30 日，因为在调用 <code>set()</code> 之后没有发生重新计算。</p>
 
<p><strong><code>add(f, delta)</code></strong> 将 <code>delta</code> 添加到 <code>f</code> 字段中。这等同于调用 <code>set(f, get(f) + delta)</code>，但要带以下两个调整：</p>
 
<blockquote>
<p><strong>Add 规则 1</strong>。调用后 <code>f</code> 字段的值减去调用前 <code>f</code> 字段的值等于 <code>delta</code>，以字段 <code>f</code> 中发生的任何溢出为模。溢出发生在字段值超出其范围时，结果，下一个更大的字段会递增或递减，并将字段值调整回其范围内。</p>
 
<p><strong>Add 规则 2</strong>。如果期望某一个更小的字段是不变的，但让它等于以前的值是不可能的，因为在字段 <code>f</code> 发生更改之后，或者在出现其他约束之后，比如时区偏移量发生更改，它的最大值和最小值也在发生更改，然后它的值被调整为尽量接近于所期望的值。更小的字段表示一个更小的时间单元。<code>HOUR</code> 是一个比 <code>DAY_OF_MONTH</code> 小的字段。对于不期望是不变字段的更小字段，无需进行任何调整。日历系统会确定期望不变的那些字段。</p>
 </blockquote>
 
<p>此外，与 <code>set()</code> 不同，<code>add()</code> 强迫日历系统立即重新计算日历的毫秒数和所有字段。</p>
 
<p><em>示例</em>：假定 <code>GregorianCalendar</code> 最初被设置为 1999 年 8 月 31 日。调用 <code>add(Calendar.MONTH, 13)</code> 将日历设置为 2000 年 9 月 30 日。<strong>Add 规则 1</strong> 将 <code>MONTH</code> 字段设置为 September，因为向 August 添加 13 个月得出的就是下一年的 September。因为在 <code>GregorianCalendar</code> 中，<code>DAY_OF_MONTH</code> 不可能是 9 月 31 日，所以 <strong>add 规则 2</strong> 将 <code>DAY_OF_MONTH</code> 设置为 30，即最可能的值。尽管它是一个更小的字段，但不能根据规则 2 调整 <code>DAY_OF_WEEK</code>，因为在 <code>GregorianCalendar</code> 中的月份发生变化时，该值也需要发生变化。</p>
 
<p><strong><code>roll(f, delta)</code></strong> 将 <code>delta</code> 添加到 <code>f</code> 字段中，但不更改更大的字段。这等同于调用 <code>add(f, delta)</code>，但要带以下调整：</p>
 
 <blockquote>
<p><strong>Roll 规则</strong>。在完成调用后，更大的字段无变化。更大的字段表示一个更大的时间单元。<code>DAY_OF_MONTH</code> 是一个比 <code>HOUR</code> 大的字段。</p>
 </blockquote>
 
<p><em>示例</em>：请参阅 {@link java.util.GregorianCalendar#roll(int, int)}。
 
<p><strong>使用模型</strong>。为了帮助理解 <code>add()</code> 和 <code>roll()</code> 的行为，假定有一个用户界面组件，它带有用于月、日、年和底层 <code>GregorianCalendar</code> 的递增或递减按钮。如果从界面上读取的日期为 1999 年 1 月 31 日，并且用户按下月份的递增按钮，那么应该得到什么？如果底层实现使用 <code>set()</code>，那么可以将该日期读为 1999 年 3 月 3 日。更好的结果是 1999 年 2 月 28 日。此外，如果用户再次按下月份的递增按钮，那么该日期应该读为 1999 年 3 月 31 日，而不是 1999 年 3 月 28 日。通过保存原始日期并使用 <code>add()</code> 或 <code>roll()</code>，根据是否会影响更大的字段，用户界面可以像大多数用户所期望的那样运行。</p>

@see          java.lang.System#currentTimeMillis()
@see          Date
@see          GregorianCalendar
@see          TimeZone
@see          java.text.DateFormat
@version      1.80, 03/09/04
@author Mark Davis, David Goldsmith, Chen-Lieh Huang, Alan Liu
@since JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.ERA
<!-- END KEY -->
<!-- BEGIN DATA -->
指示年代的 <code>get</code> 和 <code>set</code> 的字段数字，比如罗马儒略历中的 AD 或 BC。这是一个特定于日历的值；请参阅子类文档。

@see GregorianCalendar#AD
@see GregorianCalendar#BC

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.YEAR
<!-- END KEY -->
<!-- BEGIN DATA -->
指示年的 <code>get</code> 和 <code>set</code> 的字段数字。这是一个特定于日历的值；请参阅子类文档。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.MONTH
<!-- END KEY -->
<!-- BEGIN DATA -->
指示月份的 <code>get</code> 和 <code>set</code> 的字段数字。这是一个特定于日历的值。在格里高利历和罗马儒略历中一年中的第一个月是 <code>JANUARY</code>，它为 0；最后一个月取决于一年中的月份数。

@see #JANUARY
@see #FEBRUARY
@see #MARCH
@see #APRIL
@see #MAY
@see #JUNE
@see #JULY
@see #AUGUST
@see #SEPTEMBER
@see #OCTOBER
@see #NOVEMBER
@see #DECEMBER
@see #UNDECIMBER

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.WEEK_OF_YEAR
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>get</code> 和 <code>set</code> 的字段数字，指示当前年中的星期数。正如 <code>getFirstDayOfWeek()</code> 和 <code>getMinimalDaysInFirstWeek()</code> 所定义的那样，一年中第一个星期的值为 1。子类定义一年第一个星期之前的天数，即 <code>WEEK_OF_YEAR</code> 的值。

@see #getFirstDayOfWeek
@see #getMinimalDaysInFirstWeek

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.WEEK_OF_MONTH
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>get</code> 和 <code>set</code> 的字段数字，指示当前月中的星期数。正如 <code>getFirstDayOfWeek()</code> 和 <code>getMinimalDaysInFirstWeek()</code> 所定义的那样，一个月中第一个星期的值为 1。子类定义一个月第一个星期之前的天数，即 <code>WEEK_OF_MONTH</code> 的值。

@see #getFirstDayOfWeek
@see #getMinimalDaysInFirstWeek

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.DATE
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>get</code> 和 <code>set</code> 的字段数字，指示一个月中的某天。它与 <code>DAY_OF_MONTH</code> 是同义词。一个月中第一天的值为 1。

@see #DAY_OF_MONTH

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.DAY_OF_MONTH
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>get</code> 和 <code>set</code> 的字段数字，指示一个月中的某天。它与 <code>DATE</code> 是同义词。一个月中第一天的值为 1。

@see #DATE

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.DAY_OF_YEAR
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>get</code> 和 <code>set</code> 的字段数字，指示当前年中的天数。一年中第一天的值为 1。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.DAY_OF_WEEK
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>get</code> 和 <code>set</code> 的字段数字，指示一个星期中的某天。该字段可取的值为 <code>SUNDAY</code>、<code>MONDAY</code>、<code>TUESDAY</code>、<code>WEDNESDAY</code>、<code>THURSDAY</code>、<code>FRIDAY</code> 和 <code>SATURDAY</code>。

@see #SUNDAY
@see #MONDAY
@see #TUESDAY
@see #WEDNESDAY
@see #THURSDAY
@see #FRIDAY
@see #SATURDAY

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.DAY_OF_WEEK_IN_MONTH
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>get</code> 和 <code>set</code> 的字段数字，指示当前月中的第几个星期。与 <code>DAY_OF_WEEK</code> 字段一起使用时，就可以唯一地指定某月中的某一天。与 <code>WEEK_OF_MONTH</code> 和 <code>WEEK_OF_YEAR</code> 不同，该字段的值并<em>不</em> 取决于 <code>getFirstDayOfWeek()</code> 或 <code>getMinimalDaysInFirstWeek()</code>。<code>DAY_OF_MONTH </code>1 到 <code>7</code> 总是对应于 <code>DAY_OF_WEEK_IN_MONTH 1</code>；<code>8</code> 到 <code>14</code> 总是对应于 <code>DAY_OF_WEEK_IN_MONTH 2</code>，依此类推。<code>DAY_OF_WEEK_IN_MONTH 0</code> 表示 <code>DAY_OF_WEEK_IN_MONTH 1</code> 之前的那个星期。负值是从一个月的末尾开始逆向计数，因此，一个月的最后一个星期天被指定为 <code>DAY_OF_WEEK = SUNDAY, DAY_OF_WEEK_IN_MONTH = -1</code>。因为负值是逆向计数的，所以它们在月份中的对齐方式通常与正值的不同。例如，如果一个月有 31 天，那么 <code>DAY_OF_WEEK_IN_MONTH -1</code> 将与 <code>DAY_OF_WEEK_IN_MONTH 5</code> 和 <code>DAY_OF_WEEK_IN_MONTH 4</code> 的末尾相重叠。

@see #DAY_OF_WEEK
@see #WEEK_OF_MONTH

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.AM_PM
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>get</code> 和 <code>set</code> 的字段数字，指示 <code>HOUR</code> 是在中午之前还是在中午之后。例如，在 10:04:15.250 PM 这一时刻，<code>AM_PM</code> 为 <code>PM</code>。

@see #AM
@see #PM
@see #HOUR

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.HOUR
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>get</code> 和 <code>set</code> 的字段数字，指示上午或下午的小时。<code>HOUR</code> 用于 12 小时制时钟 (0 - 11)。中午和午夜用 0 表示，不用 12 表示。例如，在 10:04:15.250 PM 这一时刻，<code>HOUR</code> 为 10。

@see #AM_PM
@see #HOUR_OF_DAY

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.HOUR_OF_DAY
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>get</code> 和 <code>set</code> 的字段数字，指示一天中的小时。<code>HOUR_OF_DAY</code> 用于 24 小时制时钟。例如，在 10:04:15.250 PM 这一时刻，<code>HOUR_OF_DAY</code> 为 22。

@see #HOUR

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.MINUTE
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>get</code> 和 <code>set</code> 的字段数字，指示一小时中的分钟。例如，在 10:04:15.250 PM 这一时刻，<code>MINUTE</code> 为 4。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.SECOND
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>get</code> 和 <code>set</code> 的字段数字，指示一分钟中的秒。例如，在 10:04:15.250 PM 这一时刻，<code>SECOND</code> 为 15。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.MILLISECOND
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>get</code> 和 <code>set</code> 的字段数字，指示一秒中的毫秒。例如，在 10:04:15.250 PM 这一时刻，<code>MILLISECOND</code> 为 250。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.ZONE_OFFSET
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>get</code> 和 <code>set</code> 的字段数字，以毫秒为单位指示距 GMT 的大致偏移量。
 <p>
如果 <code>TimeZone</code> 实现子类支持历史上用过的 GMT 偏移量更改，则此字段可反应此 <code>Calendar</code> 时区的正确 GMT 偏移量值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.DST_OFFSET
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>get</code> 和 <code>set</code> 的字段数字，以毫秒为单位指示夏令时的偏移量。
 <p>
如果 <code>TimeZone</code> 实现子类支持历史上用过的 Daylight Saving Time 时间表更改，则此字段可反应此 <code>Calendar</code> 时区的正确夏令时偏移量值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.FIELD_COUNT
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>get</code> 和 <code>set</code> 可识别的不同字段的数量。字段编号的范围是从 0 到 <code>FIELD_COUNT-1</code>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.SUNDAY
<!-- END KEY -->
<!-- BEGIN DATA -->
指示 Sunday 的 {@link #DAY_OF_WEEK} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.MONDAY
<!-- END KEY -->
<!-- BEGIN DATA -->
指示 Monday 的 {@link #DAY_OF_WEEK} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.TUESDAY
<!-- END KEY -->
<!-- BEGIN DATA -->
指示 Tuesday 的 {@link #DAY_OF_WEEK} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.WEDNESDAY
<!-- END KEY -->
<!-- BEGIN DATA -->
指示 Wednesday 的 {@link #DAY_OF_WEEK} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.THURSDAY
<!-- END KEY -->
<!-- BEGIN DATA -->
指示 Thursday 的 {@link #DAY_OF_WEEK} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.FRIDAY
<!-- END KEY -->
<!-- BEGIN DATA -->
指示 Friday 的 {@link #DAY_OF_WEEK} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.SATURDAY
<!-- END KEY -->
<!-- BEGIN DATA -->
指示 Saturday 的 {@link #DAY_OF_WEEK} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.JANUARY
<!-- END KEY -->
<!-- BEGIN DATA -->
指示在格里高利历和罗马儒略历中一年中第一个月的 {@link #MONTH} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.FEBRUARY
<!-- END KEY -->
<!-- BEGIN DATA -->
指示在格里高利历和罗马儒略历中一年中第二个月的 {@link #MONTH} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.MARCH
<!-- END KEY -->
<!-- BEGIN DATA -->
指示在格里高利历和罗马儒略历中一年中第三个月的 {@link #MONTH} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.APRIL
<!-- END KEY -->
<!-- BEGIN DATA -->
指示在格里高利历和罗马儒略历中一年中第四个月的 {@link #MONTH} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.MAY
<!-- END KEY -->
<!-- BEGIN DATA -->
指示在格里高利历和罗马儒略历中一年中第五个月的 {@link #MONTH} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.JUNE
<!-- END KEY -->
<!-- BEGIN DATA -->
指示在格里高利历和罗马儒略历中一年中第六个月的 {@link #MONTH} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.JULY
<!-- END KEY -->
<!-- BEGIN DATA -->
指示在格里高利历和罗马儒略历中一年中第七个月的 {@link #MONTH} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.AUGUST
<!-- END KEY -->
<!-- BEGIN DATA -->
指示在格里高利历和罗马儒略历中一年中第八个月的 {@link #MONTH} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.SEPTEMBER
<!-- END KEY -->
<!-- BEGIN DATA -->
指示在格里高利历和罗马儒略历中一年中第九个月的 {@link #MONTH} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.OCTOBER
<!-- END KEY -->
<!-- BEGIN DATA -->
指示在格里高利历和罗马儒略历中一年中第十个月的 {@link #MONTH} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.NOVEMBER
<!-- END KEY -->
<!-- BEGIN DATA -->
指示在格里高利历和罗马儒略历中一年中第十一个月的 {@link #MONTH} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.DECEMBER
<!-- END KEY -->
<!-- BEGIN DATA -->
指示在格里高利历和罗马儒略历中一年中第十二个月的 {@link #MONTH} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.UNDECIMBER
<!-- END KEY -->
<!-- BEGIN DATA -->
指示一年中第十三个月的 {@link #MONTH} 字段值。尽管 <code>GregorianCalendar</code> 没有使用该值，但阴历会使用。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.AM
<!-- END KEY -->
<!-- BEGIN DATA -->
指示从午夜到中午之前这段时间的 {@link #AM_PM} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.PM
<!-- END KEY -->
<!-- BEGIN DATA -->
指示从中午到午夜之前这段时间的 {@link #AM_PM} 字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.ALL_STYLES
<!-- END KEY -->
<!-- BEGIN DATA -->
指示所有风格名称的 {@link #getDisplayNames(int, int, Locale)
 getDisplayNames} 的风格说明符，比如 "January" 和 "Jan"。

 @see #SHORT
 @see #LONG
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.SHORT
<!-- END KEY -->
<!-- BEGIN DATA -->
 指示短名称的 {@link #getDisplayName(int, int, Locale)
 getDisplayName} 和 {@link #getDisplayNames(int, int, Locale)
 getDisplayNames} 的风格说明符，比如 "Jan"。

 @see #LONG
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.util.Calendar.LONG
<!-- END KEY -->
<!-- BEGIN DATA -->
 指示长名称的 {@link #getDisplayName(int, int, Locale)
 getDisplayName} 和 {@link #getDisplayNames(int, int, Locale)
 getDisplayNames} 的风格说明符，比如 "January"。

 @see #SHORT
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
protected int[] java.util.Calendar.fields
<!-- END KEY -->
<!-- BEGIN DATA -->
此日历当前设置时间的日历字段值。这是一个 <code>FIELD_COUNT</code> 整数数组，索引值为 ERA 到 <code>DST_OFFSET</code>。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
protected boolean[] java.util.Calendar.isSet
<!-- END KEY -->
<!-- BEGIN DATA -->
通知是否设置了该日历某一指定日历字段的标志。新的对象没有设置任何字段。在第一次调用生成该字段的某一方法后，这些字段都将保留调用之后的设置。这是一个 <code>FIELD_COUNT</code> 布尔值数组，索引值为 ERA 到 <code>DST_OFFSET</code>。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
protected long java.util.Calendar.time
<!-- END KEY -->
<!-- BEGIN DATA -->
日历的当前设置时间，以毫秒为单位，表示自格林威治标准时间 1970 年 1月 1 日 0:00:00 后经过的时间。
@see #isTimeSet
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
protected boolean java.util.Calendar.isTimeSet
<!-- END KEY -->
<!-- BEGIN DATA -->
如果 <code>time</code> 值是一个有效值，则返回 true。通过更改 <code>field[]</code> 的项，可以使时间无效。
@see #time
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
protected boolean java.util.Calendar.areFieldsSet
<!-- END KEY -->
<!-- BEGIN DATA -->
如果 <code>fields[]</code> 与当前的设置时间同步，则返回 true。如果返回 false，则在下一次试图获得某一字段的值时，将强行重新计算 <code>time</code> 当前值中的所有字段。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private boolean java.util.Calendar.lenient
<!-- END KEY -->
<!-- BEGIN DATA -->
如果此日历允许在计算 <code>fields[]</code> 中的 <code>time</code> 时使用超出范围的字段值，则返回 <code>True</code>。
@see #setLenient
@see #isLenient
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private java.util.TimeZone java.util.Calendar.zone
<!-- END KEY -->
<!-- BEGIN DATA -->
此日历使用的 <code>TimeZone</code>。<code>Calendar</code> 使用时区数据来实现语言环境与 GMT 时间的转换。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private int java.util.Calendar.firstDayOfWeek
<!-- END KEY -->
<!-- BEGIN DATA -->
一星期中的第一天，可能的值是 <code>SUNDAY</code>、<code>MONDAY</code>，等等。这是一个同语言环境有关的值。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private int java.util.Calendar.minimalDaysInFirstWeek
<!-- END KEY -->
<!-- BEGIN DATA -->
一月或一年中第一个星期所需的天数，可能的值是从 1 到 7。这是一个同语言环境有关的值。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private int java.util.Calendar.nextStamp
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>stamp[]</code>（一个内部数组）的下一个可用值。实际上不应该将该方法写出到流中，在以后，可能从流中将其移除。同时，应该使用 <code>MINIMUM_USER_STAMP</code> 值。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private int java.util.Calendar.serialVersionOnStream
<!-- END KEY -->
<!-- BEGIN DATA -->
流中序列化数据的版本。可能的值是：
<dl>
<dt><b>0</b> 或流中不存在该数据</dt>
<dd>
JDK 1.1.5 或更早的版本。
</dd>
<dt><b>1</b></dt>
<dd>
JDK 1.1.6 或更高的版本。为其他字段编写一个正确的 'time' 值以及兼容的值。这是一种过渡格式。
</dd>
</dl>
在流出此类时，编写最新格式和所允许的最高 <code>serialVersionOnStream</code>。
@serial
@since JDK1.1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.util.Calendar()
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个带有默认时区和语言环境的 Calendar。
@see     TimeZone#getDefault

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.util.Calendar(TimeZone zone, Locale aLocale)
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个带有指定时区和语言环境的 Calendar。

@param zone 要使用的时区
@param aLocale 用于星期数据的语言环境

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.util.Calendar java.util.Calendar.getInstance()
<!-- END KEY -->
<!-- BEGIN DATA -->
使用默认时区和语言环境获得一个日历。返回的 <code>Calendar</code> 基于当前时间，使用了默认时区和默认语言环境。

@return 一个 Calendar。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.util.Calendar java.util.Calendar.getInstance(TimeZone zone)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定时区和默认语言环境获得一个日历。返回的 <code>Calendar</code> 基于当前时间，使用了给定时区和默认语言环境。 

@param zone 要使用的时区
@return 一个 Calendar。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.util.Calendar java.util.Calendar.getInstance(Locale aLocale)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用默认时区和指定语言环境获得一个日历。返回的 <code>Calendar</code> 基于当前时间，使用了默认时区和给定的语言环境。

@param aLocale 用于星期数据的语言环境
@return 一个 Calendar。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.util.Calendar java.util.Calendar.getInstance(TimeZone zone, Locale aLocale)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定时区和语言环境获得一个日历。返回的 <code>Calendar</code> 基于当前时间，使用了给定的时区和给定的语言环境。

@param zone 要使用的时区
@param aLocale 用于星期数据的语言环境
@return 一个 Calendar。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static synchronized java.util.Locale[] java.util.Calendar.getAvailableLocales()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回所有语言环境的数组，此类的 <code>getInstance</code> 方法可以为其返回本地化的实例。返回的数组必须至少包含一个 <code>Locale</code> 实例，它等同 {@link java.util.Locale#US Locale.US}。

@return 语言环境的数组，对于该数组，本地化的 <code>Calendar</code> 实例是可用的。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract void java.util.Calendar.computeTime()
<!-- END KEY -->
<!-- BEGIN DATA -->
将 {@link #fields fields[]} 中的当前日历字段值转换为毫秒时间值 {@link #time}。

@see #complete()
@see #computeFields()

<!-- END DATA -->
<!-- BEGIN KEY -->
protected abstract void java.util.Calendar.computeFields()
<!-- END KEY -->
<!-- BEGIN DATA -->
将当前毫秒时间值 {@link #time} 转换为 {@link #fields fields[]} 中的日历字段值。这允许您将该日历字段值与为日历设置的新时间同步。并<em>不</em> 首先重新计算该时间；为了重新计算时间和字段，请调用 {@link #complete()} 方法。

@see #computeTime()

<!-- END DATA -->
<!-- BEGIN KEY -->
public final java.util.Date java.util.Calendar.getTime()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个表示此 <code>Calendar</code> 时间值（从<a href="#Epoch">历元</a>至现在的毫秒偏移量）的 <code>Date</code> 对象。

@return 表示时间值的 <code>Date</code>。
@see #setTime(Date)
@see #getTimeInMillis()

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.util.Calendar.setTime(Date date)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用给定的 <code>Date</code> 设置此 Calendar 的时间。
<p>
注：使用 <code>Date(Long.MAX_VALUE)</code> 或 <code>Date(Long.MIN_VALUE)</code> 调用 <code>setTime()</code> 可能产生来自 <code>get()</code> 的错误字段值。

@param date 给定的 Date。
@see #getTime()
@see #setTimeInMillis(long)

<!-- END DATA -->
<!-- BEGIN KEY -->
public long java.util.Calendar.getTimeInMillis()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 Calendar 的时间值，以毫秒为单位。 

@return 当前时间，以从历元至现在所经过的 UTC 毫秒数形式。
@see #getTime()
@see #setTimeInMillis(long)

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.util.Calendar.setTimeInMillis(long millis)
<!-- END KEY -->
<!-- BEGIN DATA -->
用给定的 long 值设置此 Calendar 的当前时间值。

@param millis 新时间，以从历元至现在所经过的 UTC 毫秒数形式。
@see #setTime(Date)
@see #getTimeInMillis()

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.util.Calendar.get(int field)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回给定日历字段的值。在 lenient 模式下，所有日历字段都被标准化。在 non-lenient 模式下，所有日历字段都是经过验证的，如果任何日历字段有超出范围的值，则此方法抛出一个异常。标准化和验证都是通过 {@link #complete()} 方法处理的，这个过程与日历系统有关。

@param field 给定的日历字段。
@return 给定日历字段的值。
@throws ArrayIndexOutOfBoundsException 如果指定字段超出范围 (<code>field &lt; 0 || field &gt;= FIELD_COUNT</code>)。
@see #set(int,int)
@see #complete()

<!-- END DATA -->
<!-- BEGIN KEY -->
protected final int java.util.Calendar.internalGet(int field)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回给定日历字段的值。此方法不涉及字段值的标准化或验证。

@param field 给定的日历字段。
@return 给定日历字段的值。
@see #get(int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.util.Calendar.set(int field, int value)
<!-- END KEY -->
<!-- BEGIN DATA -->
将给定的日历字段设置为给定值。不管处于何种宽松性模式下，该值都不由此方法进行解释。

@param field 给定的日历字段。
@param value 给定日历字段所要设置的值。
@throws ArrayIndexOutOfBoundsException 如果指定字段超出范围 (<code>field &lt; 0 || field &gt;= FIELD_COUNT</code>)，并且处于 non-lenient 模式下。
@see #set(int,int,int)
@see #set(int,int,int,int,int)
@see #set(int,int,int,int,int,int)
@see #get(int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.util.Calendar.set(int year, int month, int date)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置日历字段 <code>YEAR</code>、<code>MONTH</code> 和 <code>DAY_OF_MONTH</code> 的值。保留其他日历字段以前的值。如果不需要这样做，则先调用 {@link #clear()}。

@param year 用来设置 <code>YEAR</code> 日历字段的值。
@param month 用来设置 <code>MONTH</code> 日历字段的值。Month 值是基于 0 的。例如，0 表示 January。
@param date 用来设置 <code>DAY_OF_MONTH</code> 日历字段的值。
@see #set(int,int)
@see #set(int,int,int,int,int)
@see #set(int,int,int,int,int,int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.util.Calendar.set(int year, int month, int date, int hourOfDay, int minute)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置日历字段 <code>YEAR</code>、<code>MONTH</code>、<code>DAY_OF_MONTH</code>、<code>HOUR_OF_DAY</code> 和 <code>MINUTE</code> 的值。保留其他字段以前的值。如果不需要这样做，则先调用 {@link #clear()}。

@param year 用来设置 <code>YEAR</code> 日历字段的值。
@param month 用来设置 <code>MONTH</code> 日历字段的值。Month 值是基于 0 的。例如，0 表示 January。
@param date 用来设置 <code>DAY_OF_MONTH</code> 日历字段的值。
@param hourOfDay 用来设置 <code>HOUR_OF_DAY</code> 日历字段的值。
@param minute 用来设置 <code>MINUTE</code> 日历字段的值。
@see #set(int,int)
@see #set(int,int,int)
@see #set(int,int,int,int,int,int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.util.Calendar.set(int year, int month, int date, int hourOfDay, int minute, int second)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置字段 <code>YEAR</code>、<code>MONTH</code>、<code>DAY_OF_MONTH</code>、<code>HOUR</code>、<code>MINUTE</code> 和 <code>SECOND</code> 的值。保留其他字段以前的值。如果不需要这样做，则先调用 {@link #clear()}。

@param year 用来设置 <code>YEAR</code> 日历字段的值。
@param month 用来设置 <code>MONTH</code> 日历字段的值。Month 值是基于 0 的。例如，0 表示 January。
@param date 用来设置 <code>DAY_OF_MONTH</code> 日历字段的值。
@param hourOfDay 用来设置 <code>HOUR_OF_DAY</code> 日历字段的值。
@param minute 用来设置 <code>MINUTE</code> 日历字段的值。
@param second 用来设置 <code>SECOND</code> 日历字段的值。
@see #set(int,int)
@see #set(int,int,int)
@see #set(int,int,int,int,int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.util.Calendar.clear()
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>Calendar</code> 的所日历字段值和时间值（从<a href="#Epoch">历元</a>至现在的毫秒偏移量）设置成未定义。这意味着 {@link #isSet(int) isSet()} 对于所有的日历字段都将返回 <code>false</code>，并且日期和时间计算会将这些字段作为从未设置的字段对待。<code>Calendar</code> 实现类可能对日期/时间计算使用字段的特定默认值。例如，如果未定义 <code>YEAR</code> 字段值，则 <code>GregorianCalendar</code> 会使用 1970。

@see #clear(int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.util.Calendar.clear(int field)
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>Calendar</code> 的给定日历字段值和时间值（从<a  href="#Epoch">历元</a>至现在的毫秒偏移量）设置成未定义。这意味着 {@link #isSet(int) isSet(field)} 将返回 <code>false</code>，并且日期和时间计算会将该字段作为从未设置的字段对待。<code>Calendar</code> 实现类可能对日期和时间计算使用字段的特定默认值。

<p>{@link #HOUR_OF_DAY}、{@link #HOUR} 和 {@link #AM_PM} 字段都是单独处理的，并且应用了<a href="#time_resolution">一天中时间的解析规则</a>。清除其中的一个字段不会重置此 <code>Calendar</code> 中的小时值。使用 {@link #set(int,int) set(Calendar.HOUR_OF_DAY, 0)} 重置小时值。

@param field 要清除的日历字段。
@see #clear()

<!-- END DATA -->
<!-- BEGIN KEY -->
public final boolean java.util.Calendar.isSet(int field)
<!-- END KEY -->
<!-- BEGIN DATA -->
确定给定日历字段是否已经设置了一个值，其中包括因为调用 <code>get</code> 方法触发内部字段计算而导致已经设置该值的情况。

@return  如果给定日历字段已经设置了一个值，则返回 <code>true</code>；否则返回 <code>false</code>。


<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.util.Calendar.getDisplayName(int field, int style, Locale locale)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回给定 <code>style</code> 和 <code>locale</code> 下的日历 <code>field</code> 值的字符串表示形式。如果没有可用的字符串表示形式，则返回 <code>null</code>。如果字符串表示形式可用于给定的日历 <code>field</code>，则此方法调用 {@link Calendar#get(int) get(field)} 来获取日历 <code>field</code> 值。 

<p>例如，如果此 <code>Calendar</code> 是 <code>GregorianCalendar</code> 并且其日期是 2005-01-01，那么 {@link #MONTH} 字段的字符串表示形式在英语语言环境中将是 long 类型的 "January" 或者 short 类型的 "Jan"。然而，{@link #DAY_OF_MONTH} 字段没有可用的字符串表示形式，并且此方法将返回 <code>null</code>。

<p>默认实现支持日历字段，{@link DateFormatSymbols} 在给定 <code>locale</code> 中具有此类名称。

 @param field 其字符串表示形式返回的日历字段
 @param style 应用于字符串表示形式的类型；{@link #SHORT} 或 {@link #LONG} 之一。
 @param locale 字符串表示形式的语言环境 
 @return 给定 <code>style</code> 中给定 <code>field</code> 的字符串表示形式；如果没有可用的字符串表示形式，则返回 <code>null</code>。
 @exception IllegalArgumentException 如果 <code>field</code> 或 <code>style</code> 无效，如果此 <code>Calendar</code> 处于 non-lenient 模式并且所有日历字段都有无效值 
@exception NullPointerException 如果 <code>locale</code> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Map<java.lang.String, java.lang.Integer> java.util.Calendar.getDisplayNames(int field, int style, Locale locale)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回给定 <code>style</code> 和 <code>locale</code> 下包含日历 <code>field</code> 所有名称的 <code>Map</code> 及其相应字段值。例如，如果此 <code>Calendar</code> 是 {@link GregorianCalendar}，则在英语语言环境的 {@linkplain #SHORT short} 类型中的返回映射将包含 "Jan" 到 {@link #JANUARY}，"Feb" 到 {@link #FEBRUARY} 诸如此类。 

<p>可以考虑用其他日历字段值来确定显示名称集。例如，如果此 <code>Calendar</code> 是月与日的日历系统并且由 {@link #YEAR} 字段给定的年值有闰月，此方法将返回包含闰月名称的月名称，并且月名称被映射到该年中其指定值。

<p>默认实现支持 {@link DateFormatSymbols} 中包含的显示名称。例如，如果 <code>field</code> 是 {@link #MONTH} 并且 <code>style</code> 是 {@link #ALL_STYLES}，则此方法返回包含 {@link DateFormatSymbols#getShortMonths()} 和 {@link DateFormatSymbols#getMonths()} 返回的所有字符串的 <code>Map</code>。

 @param field 其返回显示名称的日历字段
 @param style 应用于显示名称的风格；{@link #SHORT}、{@link #LONG} 或 {@link #ALL_STYLES} 之一。
 @param locale 显示名称的语言环境
 @return 包含 <code>style</code> 和 <code>locale</code> 下的所有显示名称的 <code>Map</code> 及其字段值；如果没有显示名称，则返回 <code>null</code>
 @exception IllegalArgumentException 如果 <code>field</code> 或 <code>style</code> 无效，如果此 <code>Calendar</code> 处于 non-lenient 模式并且所有日历字段都有无效值
 @exception NullPointerException 如果 <code>locale</code> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void java.util.Calendar.complete()
<!-- END KEY -->
<!-- BEGIN DATA -->
填充日历字段中所有未设置的字段。首先，如果已经从日历字段值中计算出了时间值（从<a  href="#Epoch">历元</a>至现在的毫秒偏移量），则调用 {@link #computeTime()} 方法。然后调用 {@link #computeFields()} 方法来计算所有的日历字段值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.util.Calendar.equals(Object obj)
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>Calendar</code> 与指定 <code>Object</code> 比较。当且仅当参数是同一日历系统的 <code>Calendar</code> 对象时，结果才为 <code>true</code>，该日历系统将同一 <code>Calendar</code> 参数下的同一时间值（从<a  href="#Epoch">历元</a>至现在的毫秒偏移量）表示为此对象。

<p><code>Calendar</code> 参数是通过 <code>isLenient</code>、<code>getFirstDayOfWeek</code>、<code>getMinimalDaysInFirstWeek</code> 和 <code>getTimeZone</code> 方法表示的值。如果在两个 <code>Calendar</code> 之间这些参数中存在任何不同之处，则此方法返回 <code>false</code>。

<p>使用 {@link #compareTo(Calendar) compareTo} 方法来仅对时间值进行比较。

@param   obj   要与之比较的对象。
@return  如果此对象等于 <code>obj</code>，则返回 <code>true</code>；否则返回 <code>false</code>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.util.Calendar.hashCode()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回该此日历的哈希码。

@return  此对象的哈希码值。
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.util.Calendar.before(Object when)
<!-- END KEY -->
<!-- BEGIN DATA -->
判断此 <code>Calendar</code> 表示的时间是否在指定 <code>Object</code> 表示的时间之前，返回判断结果。此方法等效于：
 <pre><blockquote>
         compareTo(when) < 0
 </blockquote></pre>
当且仅当 <code>when</code> 是一个 <code>Calendar</code> 实例时才返回 true。否则该方法返回 <code>false</code>。

@param when 要比较的 <code>Object</code>
@return 如果此 <code>Calendar</code> 的时间在 <code>when</code> 表示的时间之前，则返回 <code>true</code>；否则返回 <code>false</code>。
@see	#compareTo(Calendar)

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.util.Calendar.after(Object when)
<!-- END KEY -->
<!-- BEGIN DATA -->
判断此 <code>Calendar</code> 表示的时间是否在指定 <code>Object</code> 表示的时间之后，返回判断结果。此方法等效于：
 <pre><blockquote>
         compareTo(when) > 0
 </blockquote></pre>
当且仅当 <code>when</code> 是一个 <code>Calendar</code> 实例时才返回 true。否则该方法返回 <code>false</code>。

@param when 要比较的 <code>Object</code>
@return 如果此 <code>Calendar</code> 的时间在 <code>when</code> 表示的时间之后，则返回 <code>true</code>；否则返回 <code>false</code>。
@see	#compareTo(Calendar)

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.util.Calendar.compareTo(Calendar anotherCalendar)
<!-- END KEY -->
<!-- BEGIN DATA -->
比较两个 <code>Calendar</code> 对象表示的时间值（从<a href="#Epoch">历元</a>至现在的毫秒偏移量）。

@param anotherCalendar 要比较的 <code>Calendar</code>。
@return  如果参数表示的时间等于此 <code>Calendar</code> 表示的时间，则返回 <code>0</code> 值；如果此 <code>Calendar</code> 的时间在参数表示的时间之前，则返回小于 <code>0</code> 的值；如果此 <code>Calendar</code> 的时间在参数表示的时间之后，则返回大于 <code>0</code> 的值。
@exception NullPointerException 如果指定的 <code>Calendar</code> 为 <code>null</code>。
@exception IllegalArgumentException 如果因为无效的日历值而无法获得指定 <code>Calendar</code> 对象的时间值。
@since   1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract void java.util.Calendar.add(int field, int amount)
<!-- END KEY -->
<!-- BEGIN DATA -->
根据日历的规则，为给定的日历字段添加或减去指定的时间量。例如，要从当前日历时间减去 5 天，可以通过调用以下方法做到这一点：
<p><code>add(Calendar.DAY_OF_MONTH, -5)</code>。

@param field 日历字段。
@param amount 为字段添加的日期或时间量。
@see #roll(int,int)
@see #set(int,int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract void java.util.Calendar.roll(int field, boolean up)
<!-- END KEY -->
<!-- BEGIN DATA -->
在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。例如，要将当前日期向上滚动一天，可以通过调用以下方法做到这一点：
<p>roll(Calendar.DATE, true)。在 year 或 Calendar.YEAR 字段上滚动时，将在从 1 到调用 <code>getMaximum(Calendar.YEAR)</code> 的返回值之间的范围内滚动 year 值。在 month 或 Calendar.MONTH 字段上滚动时，其他字段（如 date）可能发生冲突，因此需要更改它们。例如，在日期 01/31/96 上滚动 month 将产生 02/29/96 的日期。在 hour-in-day 或 Calendar.HOUR_OF_DAY 字段上滚动时，小时值会在 0 到 23 之间的范围内滚动，它是基于 0 的。

@param field 时间字段。
@param up 指示指定时间字段的值是向上滚动还是向下滚动。如果向上滚动，则使用 true，否则使用 false。
@see Calendar#add(int,int)
@see Calendar#set(int,int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.util.Calendar.roll(int field, int amount)
<!-- END KEY -->
<!-- BEGIN DATA -->
向指定日历字段添加指定（有符号的）时间量，不更改更大的字段。负的时间量意味着向下滚动。

<p>注：<code>Calendar</code> 上的此默认实现只是重复地调用滚动一个单元的 {@link #roll(int,boolean) roll()} 版本。这可能并非总是正确的。例如，如果 <code>DAY_OF_MONTH</code> 字段为 31，则在 February 的范围内滚动会将它设置为 28。此函数的 <code>GregorianCalendar</code> 版本会小心地处理这个问题。其他子类还应该提供此函数的重写版本，以正确实现该功能。

@param field 日历字段。
@param amount 要添加到日历 <code>field</code> 中的有符号时间量。
@since 1.2
@see #roll(int,boolean)
@see #add(int,int)
@see #set(int,int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.util.Calendar.setTimeZone(TimeZone value)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用给定的时区值来设置时区。

@param value 给定的时区。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.TimeZone java.util.Calendar.getTimeZone()
<!-- END KEY -->
<!-- BEGIN DATA -->
获得时区。

@return 与此日历有关的时区对象。

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.util.Calendar.setLenient(boolean lenient)
<!-- END KEY -->
<!-- BEGIN DATA -->
指定日期/时间解释是否是宽松的。对于宽松的解释，可以将诸如 "February 942, 1996" 之类的日期视为等同于 1996 年 1 月 1 日后的第 941 天。而对于严格的（non-lenient）解释，这样的日期会导致抛出异常。默认情况下是宽松的。

@param lenient 如果开启 lenient 模式，则为 <code>true</code>；如果关闭此模式，则为 <code>false</code>。
@see #isLenient()
@see java.text.DateFormat#setLenient

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.util.Calendar.isLenient()
<!-- END KEY -->
<!-- BEGIN DATA -->
判断日期/时间的解释是否为宽松的。

@return 如果此日历的解释模式是 lenient，则返回 <code>true</code>；否则返回 <code>false</code>。
@see #setLenient(boolean)

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.util.Calendar.setFirstDayOfWeek(int value)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置一星期的第一天是哪一天；例如，在美国，这一天是 <code>SUNDAY</code>，而在法国，这一天是 <code>MONDAY</code>。

@param value 给出的一星期的第一天。
@see #getFirstDayOfWeek()
@see #getMinimalDaysInFirstWeek()

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.util.Calendar.getFirstDayOfWeek()
<!-- END KEY -->
<!-- BEGIN DATA -->
获取一星期的第一天；例如，在美国，这一天是 <code>SUNDAY</code>，而在法国，这一天是 <code>MONDAY</code>。

@return 一星期的第一天。
@see #setFirstDayOfWeek(int)
@see #getMinimalDaysInFirstWeek()

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.util.Calendar.setMinimalDaysInFirstWeek(int value)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置一年中第一个星期所需的最少天数，例如，如果定义第一个星期包含一年第一个月的第一天，则使用值 1 调用此方法。如果最少天数必须是一整个星期，则使用值 7 调用此方法。

@param value 一年中第一个星期所需的给定最少天数。
@see #getMinimalDaysInFirstWeek()

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.util.Calendar.getMinimalDaysInFirstWeek()
<!-- END KEY -->
<!-- BEGIN DATA -->
获取一年中第一个星期所需的最少天数，例如，如果定义第一个星期包含一年第一个月的第一天，则此方法将返回 1。如果最少天数必须是一整个星期，则此方法将返回 7。

@return 一年中第一个星期所需的最少天数。
@see #setMinimalDaysInFirstWeek(int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract int java.util.Calendar.getMinimum(int field)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Calendar</code> 实例给定日历字段的最小值。最小值被定义为 {@link #get(int) get} 方法为任何可能时间值返回的最小值。最小值取决于日历系统实例的特定参数。

@param field 日历字段。
@return 给定日历字段的最小值。
@see #getMaximum(int)
@see #getGreatestMinimum(int)
@see #getLeastMaximum(int)
@see #getActualMinimum(int)
@see #getActualMaximum(int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract int java.util.Calendar.getMaximum(int field)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Calendar</code> 实例给定日历字段的最大值。最大值被定义为 {@link #get(int) get} 方法为任何可能时间值返回的最大值。最大值取决于日历系统实例的特定参数。

@param field 日历字段。
@return 给定日历字段的最大值。
@see #getMinimum(int)
@see #getGreatestMinimum(int)
@see #getLeastMaximum(int)
@see #getActualMinimum(int)
@see #getActualMaximum(int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract int java.util.Calendar.getGreatestMinimum(int field)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Calendar</code> 实例给定日历字段的最高的最小值。最高的最小值被定义为 {@link #getActualMinimum(int)} 方法为任何可能时间值返回的最大值。最高的最小值取决于日历系统实例的特定参数。

@param field 日历字段。
@return 给定日历字段的最高的最小值。
@see #getMinimum(int)
@see #getMaximum(int)
@see #getLeastMaximum(int)
@see #getActualMinimum(int)
@see #getActualMaximum(int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public abstract int java.util.Calendar.getLeastMaximum(int field)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>Calendar</code> 实例给定日历字段的最低的最大值。最低的最大值被定义为 {@link #getActualMaximum(int)}  方法为任何可能时间值返回的最小值。最低的最大值取决于日历系统实例的特定参数。例如，对于格里高利历系统，<code>Calendar</code> 将为 <code>DAY_OF_MONTH</code> 字段返回 28，因为第 28 天是该日历最短那个月的最后一天，即普通年的二月。

@param field 日历字段。
@return 给定日历字段的最低的最大值。
@see #getMinimum(int)
@see #getMaximum(int)
@see #getGreatestMinimum(int)
@see #getActualMinimum(int)
@see #getActualMaximum(int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.util.Calendar.getActualMinimum(int field)
<!-- END KEY -->
<!-- BEGIN DATA -->
给定此 <code>Calendar</code> 的时间值，返回指定日历字段可能拥有的最小值。

<p>此方法的默认实现使用了一个迭代算法来确定日历字段的实际最小值。如果可能的话，子类应该使用更有效的实现来重写此方法&mdash;&mdash;在许多情况下，它们只是简单地返回 <code>getMinimum()</code>。

@param field 日历字段
@return 对于此 <code>Calendar</code> 的时间值而言，给定日历字段的最小值
@see #getMinimum(int)
@see #getMaximum(int)
@see #getGreatestMinimum(int)
@see #getLeastMaximum(int)
@see #getActualMaximum(int)
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.util.Calendar.getActualMaximum(int field)
<!-- END KEY -->
<!-- BEGIN DATA -->
给定此 <code>Calendar</code> 的时间值，返回指定日历字段可能拥有的最大值。例如，在某些年份中，<code>MONTH</code> 字段的实际最大值是 12，而在希伯来日历系统的其他年份中，该字段的实际最大值是 13。

<p>此方法的默认实现使用了一个迭代算法来确定日历字段的实际最大值。如果有可能的话，子类应该使用一个更有效的实现来重写此方法。

@param field 日历字段
@return 对于此 <code>Calendar</code> 的时间值而言，给定日历字段的最大值
@see #getMinimum(int)
@see #getMaximum(int)
@see #getGreatestMinimum(int)
@see #getLeastMaximum(int)
@see #getActualMaximum(int)
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.Object java.util.Calendar.clone()
<!-- END KEY -->
<!-- BEGIN DATA -->
创建并返回此对象的一个副本。

@return  此对象的一个副本。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.util.Calendar.toString()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此日历的字符串表示形式。此方法仅在进行调试的时候使用，不同实现之间所返回的字符串格式可能有所不同。返回的字符串可能为空，但不可能为 <code>null</code>。
 
@return  此日历的字符串表示形式。

<!-- END DATA -->
<!-- BEGIN KEY -->
private void java.util.Calendar.readObject(ObjectInputStream stream) throws java.io.IOException, java.lang.ClassNotFoundException
<!-- END KEY -->
<!-- BEGIN DATA -->
从流重构此对象（也就是将其反序列化）。

<!-- END DATA -->
<!-- BEGIN KEY -->
private void java.util.Calendar.writeObject(ObjectOutputStream stream) throws java.io.IOException
<!-- END KEY -->
<!-- BEGIN DATA -->
将此对象的状态保存到流中（也就是将其序列化）。

理想情况下，<code>Calendar</code> 将只写出其状态数据和当前时间，并且不会写出任何字段数据，比如 <code>fields[]</code>、<code>isTimeSet</code>、<code>areFieldsSet</code> 和 <code>isSet[]</code>。<code>nextStamp</code> 不应该是持久存储状态的一部分。不幸的是，在发行 JDK 1.1 之前，事情并非如此。为了与 JDK 1.1 兼容，必须总是写出字段值和状态标志。不过，可以从序列化流中移除 <code>nextStamp</code>；可能在以后会实现。

<!-- END DATA -->

