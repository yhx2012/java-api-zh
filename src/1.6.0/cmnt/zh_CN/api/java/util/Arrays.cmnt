<!-- BEGIN KEY -->
public class java.util.Arrays extends java.lang.Object
<!-- END KEY -->
<!-- BEGIN DATA -->
此类包含用来操作数组（比如排序和搜索）的各种方法。此类还包含一个允许将数组作为列表来查看的静态工厂。

<p>除非特别注明，否则如果指定数组引用为 null，则此类中的方法都会抛出 <tt>NullPointerException</tt>。

<p>此类中所含方法的文档都包括对<i>实现</i> 的简短描述。应该将这些描述视为<i>实现注意事项</i>，而不应将它们视为<i>规范</i> 的一部分。实现者应该可以随意替代其他算法，只要遵循规范本身即可。（例如，<tt>sort(Object[])</tt> 使用的算法不必是一个合并排序算法，但它必须是<i>稳定的</i>。）

<p>此类是 <a href="{@docRoot}/../technotes/guides/collections/index.html">Java Collections Framework</a> 的成员。

@author  Josh Bloch
@author  Neal Gafter
@author  John Rose
@version 1.71, 04/21/06
@since   1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(long[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
对指定的 long 型数组按数字升序进行排序。该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的 Engineering a Sort Function", Software-Practice and Experience Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。

@param a 要排序的数组

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(long[] a, int fromIndex, int toIndex)
<!-- END KEY -->
<!-- BEGIN DATA -->
对指定 long 型数组的指定范围按数字升序进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）

<p>该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的 Engineering a Sort Function", Software-Practice and Experience Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。

@param a 要排序的数组
@param fromIndex 要排序的第一个元素的索引（包括）
@param toIndex 要排序的最后一个元素的索引（不包括）
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(int[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
对指定的 int 型数组按数字升序进行排序。该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的 Engineering a Sort Function", Software-Practice and Experience Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。

@param a 要排序的数组

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(int[] a, int fromIndex, int toIndex)
<!-- END KEY -->
<!-- BEGIN DATA -->
对指定 int 型数组的指定范围按数字升序进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）<p>

该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的 Engineering a Sort Function", Software-Practice and Experience Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。

@param a 要排序的数组
@param fromIndex 要排序的第一个元素的索引（包括）
@param toIndex 要排序的最后一个元素的索引（不包括）
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(short[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
对指定的 short 型数组按数字升序进行排序。该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的 Engineering a Sort Function", Software-Practice and Experience Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。

@param a 要排序的数组

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(short[] a, int fromIndex, int toIndex)
<!-- END KEY -->
<!-- BEGIN DATA -->
对指定 short 型数组的指定范围按数字升序进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）<p>

该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的 Engineering a Sort Function", Software-Practice and Experience Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。

@param a 要排序的数组
@param fromIndex 要排序的第一个元素的索引（包括）
@param toIndex 要排序的最后一个元素的索引（不包括）
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(char[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
对指定的 char 型数组按数字升序进行排序。该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的 Engineering a Sort Function", Software-Practice and Experience Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。

@param a 要排序的数组

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(char[] a, int fromIndex, int toIndex)
<!-- END KEY -->
<!-- BEGIN DATA -->
对指定 char 型数组的指定范围按数字升序进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）<p>

该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的 Engineering a Sort Function", Software-Practice and Experience Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。

@param a 要排序的数组
@param fromIndex 要排序的第一个元素的索引（包括）
@param toIndex 要排序的最后一个元素的索引（不包括）
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(byte[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
对指定的 byte 型数组按数字升序进行排序。该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的 Engineering a Sort Function", Software-Practice and Experience Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。

@param a 要排序的数组

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(byte[] a, int fromIndex, int toIndex)
<!-- END KEY -->
<!-- BEGIN DATA -->
对指定 byte 型数组的指定范围按数字升序进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）<p>

该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的 Engineering a Sort Function", Software-Practice and Experience Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。

@param a 要排序的数组
@param fromIndex 要排序的第一个元素的索引（包括）
@param toIndex 要排序的最后一个元素的索引（不包括）
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(double[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
对指定的 double 型数组按数字升序进行排序。
 <p>
虽然 <code>&lt;</code> 关系式对不同数字 <code>-0.0 == 0.0</code> 返回的结果为 <code>true</code>，并且认为 NaN 值既不小于或大于任何浮点值，也不等于任何浮点值，甚至不等于它自身。但 <code>&lt;</code> 关系式不能提供所有浮点值的整体排序。为了允许进行排序，此方法不使用 <code>&lt;</code> 关系式来确定数字升序排序，而是利用 {@link Double#compareTo} 来完成整体排序。此排序法不同于 <code>&lt;</code> 关系式，其中 <code>-0.0</code> 被认为是小于 <code>0.0</code> 的值，并且 NaN 被认为大于其他任何浮点值。为了进行排序，所有 NaN 值都被认为是等效且相等的。
 <p>
该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的 Engineering a Sort Function", Software-Practice and Experience Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。

@param a 要排序的数组

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(double[] a, int fromIndex, int toIndex)
<!-- END KEY -->
<!-- BEGIN DATA -->
对指定 double 型数组的指定范围按数字升序进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）
 <p>
虽然 <code>&lt;</code> 关系式对不同数字 <code>-0.0 == 0.0</code> 返回的结果为 <code>true</code>，并且认为 NaN 值既不小于或大于任何浮点值，也不等于任何浮点值，甚至不等于它自身。但 <code>&lt;</code> 关系式不能提供所有浮点值的整体排序。为了允许进行排序，此方法不使用 <code>&lt;</code> 关系式来确定数字升序排序，而是利用 {@link Double#compareTo} 来完成整体排序。此排序法不同于 <code>&lt;</code> 关系式，其中 <code>-0.0</code> 被认为是小于 <code>0.0</code> 的值，并且 NaN 被认为大于其他任何浮点值。为了进行排序，所有 NaN 值都被认为是等效且相等的。
 <p>
该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的 Engineering a Sort Function", Software-Practice and Experience Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。

@param a 要排序的数组
@param fromIndex 要排序的第一个元素的索引（包括）
@param toIndex 要排序的最后一个元素的索引（不包括）
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(float[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
对指定的 float 型数组按数字升序进行排序。
 <p>
虽然 <code>&lt;</code> 关系式对不同数字 <code>-0.0f == 0.0f</code> 返回的结果为 <code>true</code>，并且认为 NaN 值既不小于或大于任何浮点值，也不等于任何浮点值，甚至不等于它自身。但 <code>&lt;</code> 关系式不能提供所有浮点值的整体排序。为了允许进行排序，此方法不使用 <code>&lt;</code> 关系式来确定数字升序排序，而是利用 {@link Float#compareTo} 来完成整体排序。此排序法不同于 <code>&lt;</code> 关系式，其中 <code>-0.0f</code> 被认为是小于 <code>0.0f</code> 的值，并且 NaN 被认为大于其他任何浮点值。为了进行排序，所有 NaN 值都被认为是等效且相等的。
 <p>
该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的 Engineering a Sort Function", Software-Practice and Experience Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。

@param a 要排序的数组

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(float[] a, int fromIndex, int toIndex)
<!-- END KEY -->
<!-- BEGIN DATA -->
对指定 float  型数组的指定范围按数字升序进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）
 <p>
虽然 <code>&lt;</code> 关系式对不同数字 <code>-0.0f == 0.0f</code> 返回的结果为 <code>true</code>，并且认为 NaN 值既不小于或大于任何浮点值，也不等于任何浮点值，甚至不等于它自身。但 <code>&lt;</code> 关系式不能提供所有浮点值的整体排序。为了允许进行排序，此方法不使用 <code>&lt;</code> 关系式来确定数字升序排序，而是利用 {@link Float#compareTo} 来完成整体排序。此排序法不同于 <code>&lt;</code> 关系式，其中 <code>-0.0f</code> 被认为是小于 <code>0.0f</code> 的值，并且 NaN 被认为大于其他任何浮点值。为了进行排序，所有 NaN 值都被认为是等效且相等的。
 <p>
该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的 Engineering a Sort Function", Software-Practice and Experience Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。

@param a 要排序的数组
@param fromIndex 要排序的第一个元素的索引（包括）
@param toIndex 要排序的最后一个元素的索引（不包括）
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(java.lang.Object[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
根据元素的{@linkplain Comparable 自然顺序}对指定对象数组按升序进行排序。数组中的所有元素都必须实现 {@link Comparable} 接口。此外，数组中的所有元素都必须是<i>可相互比较的</i>（也就是说，对于数组中的任何 <tt>e1</tt> 和 <tt>e2</tt> 元素而言，<tt>e1.compareTo(e2)</tt> 不得抛出 <tt>ClassCastException</tt>）。<p>

保证此排序是<i>稳定的</i>：不会因调用 sort 方法而对相等的元素进行重新排序。<p>

该排序算法是一个经过修改的合并排序算法（其中，如果低子列表中的最高元素小于高子列表中的最低元素，则忽略合并）。此算法提供可保证的 n*log(n) 性能。
 
@param a 要排序的数组
@throws  ClassCastException 如果数组包含不<i>可相互比较的</i> 的元素（例如，字符串和整数）。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(java.lang.Object[] a, int fromIndex, int toIndex)
<!-- END KEY -->
<!-- BEGIN DATA -->
根据元素的{@linkplain Comparable 自然顺序}对指定对象数组的指定范围按升序进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）此范围中的所有元素都必须实现 {@link Comparable} 接口。此外，此范围中的所有元素都必须是<i>可相互比较的</i>（也就是说，对于数组中的任何 <tt>e1</tt> 和 <tt>e2</tt> 元素而言，<tt>e1.compareTo(e2)</tt> 不得抛出 <tt>ClassCastException</tt>）。<p>

保证此排序是<i>稳定的</i>：不会因调用 sort 方法而对相等的元素进行重新排序。<p>

该排序算法是一个经过修改的合并排序算法（其中，如果低子列表中的最高元素小于高子列表中的最低元素，则忽略合并）。此算法提供可保证的 n*log(n) 性能。
 
@param a 要排序的数组
@param fromIndex 要排序的第一个元素的索引（包括）
@param toIndex 要排序的最后一个元素的索引（不包括）
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt> 
@throws ClassCastException 如果数组包含不<i>可相互比较的</i> 的元素（例如，字符串和整数）。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(T[] a, java.util.Comparator<? super T> c)
<!-- END KEY -->
<!-- BEGIN DATA -->
根据指定比较器产生的顺序对指定对象数组进行排序。数组中的所有元素都必须是通过指定比较器<i>可相互比较的</i>（也就是说，对于数组中的任何 <tt>e1</tt> 和 <tt>e2</tt> 元素而言，<tt>c.compare(e1, e2)</tt> 不得抛出 <tt>ClassCastException</tt>）。<p>

保证此排序是<i>稳定的</i>：不会因调用 sort 方法而对相等的元素进行重新排序。<p>

该排序算法是一个经过修改的合并排序算法（其中，如果低子列表中的最高元素小于高子列表中的最低元素，则忽略合并）。此算法提供可保证的 n*log(n) 性能。 

@param a 要排序的数组
@param c 确定数组顺序的比较器。<tt>null</tt> 值指示应该使用元素的{@linkplain Comparable 自然顺序}。
@throws  ClassCastException 如果数组包含使用指定的比较器不<i>可相互比较的</i> 的元素。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.sort(T[] a, int fromIndex, int toIndex, java.util.Comparator<? super T> c)
<!-- END KEY -->
<!-- BEGIN DATA -->
根据指定比较器产生的顺序对指定对象数组的指定范围进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）此范围内的所有元素都必须是通过指定比较器<i>可相互比较的</i>（也就是说，对于该范围中的任何 <tt>e1</tt> 和 <tt>e2</tt> 元素而言，<tt>c.compare(e1, e2)</tt> 不得抛出 <tt>ClassCastException</tt>）。<p>

保证此排序是<i>稳定的</i>：不会因调用 sort 方法而对相等的元素进行重新排序。<p>

该排序算法是一个经过修改的合并排序算法（其中，如果低子列表中的最高元素小于高子列表中的最低元素，则忽略合并）。此算法提供可保证的 n*log(n) 性能。 

@param a 要排序的数组
@param fromIndex 要排序的第一个元素的索引（包括）
@param toIndex 要排序的最后一个元素的索引（不包括）
@param c 确定数组顺序的比较器。<tt>null</tt> 值指示应该使用元素的{@linkplain Comparable 自然顺序}。
@throws  ClassCastException 如果数组包含使用指定的比较器不<i>可相互比较的</i> 的元素。
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt> 

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(long[] a, long key)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定的 long 型数组，以获得指定的值。必须在进行此调用之前对数组进行排序（通过 {@link #sort(long[])} 方法）。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。

@param a 要搜索的数组
@param  key 要搜索的值
@return 如果它包含在数组中，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即第一个大于此键的元素索引，如果数组中的所有元素都小于指定的键，则为 <tt>a.length</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(long[] a, int fromIndex, int toIndex, long key)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定的 long 型数组的范围，以获得指定的值。必须在进行此调用之前对范围进行排序（通过 {@link #sort(long[], int, int)} 方法）。如果没有对范围进行排序，则结果是不确定的。如果范围包含多个带有指定值的元素，则无法保证找到的是哪一个。

@param a 要搜索的数组
@param fromIndex 要搜索的第一个元素的索引（包括）
@param toIndex 要搜索的最后一个元素的索引（不包括）
@param key 要搜索的值
@return 如果它包含在数组的指定范围内，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即范围中第一个大于此键的元素索引，如果范围中的所有元素都小于指定的键，则为 <tt>toIndex</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。
@throws IllegalArgumentException
	       如果 {@code fromIndex > toIndex}
@throws ArrayIndexOutOfBoundsException
	       如果 {@code fromIndex < 0 或 toIndex > a.length}
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(int[] a, int key)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定的 int 型数组，以获得指定的值。必须在进行此调用之前对数组进行排序（通过 {@link #sort(int[])} 方法）。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。

@param  a 要搜索的数组
@param  key 要搜索的值
@return 如果它包含在数组中，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即第一个大于此键的元素索引，如果数组中的所有元素都小于指定的键，则为 <tt>a.length</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(int[] a, int fromIndex, int toIndex, int key)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定的 int 型数组的范围，以获得指定的值。必须在进行此调用之前对范围进行排序（通过 {@link #sort(int[], int, int)} 方法）。如果没有对范围进行排序，则结果是不确定的。如果范围包含多个带有指定值的元素，则无法保证找到的是哪一个。

@param a 要搜索的数组
@param fromIndex 要搜索的第一个元素的索引（包括）
@param toIndex 要搜索的最后一个元素的索引（不包括）
@param key 要搜索的值
@return 如果它包含在数组的指定范围内，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即范围中第一个大于此键的元素索引，如果范围中的所有元素都小于指定的键，则为 <tt>toIndex</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。
@throws IllegalArgumentException
	       如果 {@code fromIndex > toIndex}
@throws ArrayIndexOutOfBoundsException
	       如果 {@code fromIndex < 0 或 toIndex > a.length}
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(short[] a, short key)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定的 short 型数组，以获得指定的值。必须在进行此调用之前对数组进行排序（通过 {@link #sort(short[])} 方法）。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。

@param a 要搜索的数组
@param  key 要搜索的值
@return 如果它包含在数组中，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即第一个大于此键的元素索引，如果数组中的所有元素都小于指定的键，则为 <tt>a.length</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(short[] a, int fromIndex, int toIndex, short key)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定的 short 型数组的范围，以获得指定的值。必须在进行此调用之前对范围进行排序（通过 {@link #sort(short[], int, int)} 方法）。如果没有对范围进行排序，则结果是不确定的。如果范围包含多个带有指定值的元素，则无法保证找到的是哪一个。

@param a 要搜索的数组
@param fromIndex 要搜索的第一个元素的索引（包括）
@param toIndex 要搜索的最后一个元素的索引（不包括）
@param key 要搜索的值
@return 如果它包含在数组的指定范围内，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即范围中第一个大于此键的元素索引，如果范围中的所有元素都小于指定的键，则为 <tt>toIndex</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。
@throws IllegalArgumentException
	       如果 {@code fromIndex > toIndex}
@throws ArrayIndexOutOfBoundsException
	       如果 {@code fromIndex < 0 或 toIndex > a.length}
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(char[] a, char key)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定的 char 型数组，以获得指定的值。必须在进行此调用之前对数组进行排序（通过 {@link #sort(char[])} 方法）。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。

@param  a 要搜索的数组
@param  key 要搜索的值
@return 如果它包含在数组中，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即第一个大于此键的元素索引，如果数组中的所有元素都小于指定的键，则为 <tt>a.length</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(char[] a, int fromIndex, int toIndex, char key)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定的 char 型数组的范围，以获得指定的值。必须在进行此调用之前对范围进行排序（通过 {@link #sort(char[], int, int)} 方法）。如果没有对范围进行排序，则结果是不确定的。如果范围包含多个带有指定值的元素，则无法保证找到的是哪一个。

@param a 要搜索的数组
@param fromIndex 要搜索的第一个元素的索引（包括）
@param toIndex 要搜索的最后一个元素的索引（不包括）
@param key 要搜索的值
@return 如果它包含在数组的指定范围内，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即范围中第一个大于此键的元素索引，如果范围中的所有元素都小于指定的键，则为 <tt>toIndex</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。
@throws IllegalArgumentException
	       如果 {@code fromIndex > toIndex}
 @throws ArrayIndexOutOfBoundsException
	       如果 {@code fromIndex < 0 或 toIndex > a.length}
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(byte[] a, byte key)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定的 byte 型数组，以获得指定的值。必须在进行此调用之前对数组进行排序（通过 {@link #sort(byte[])} 方法）。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。

@param  a 要搜索的数组
@param  key 要搜索的值
@return 如果它包含在数组中，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即第一个大于此键的元素索引，如果数组中的所有元素都小于指定的键，则为 <tt>a.length</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(byte[] a, int fromIndex, int toIndex, byte key)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定的 byte 型数组的范围，以获得指定的值。必须在进行此调用之前对范围进行排序（通过 {@link #sort(byte[], int, int)} 方法）。如果没有对范围进行排序，则结果是不确定的。如果范围包含多个带有指定值的元素，则无法保证找到的是哪一个。

@param a 要搜索的数组
@param fromIndex 要搜索的第一个元素的索引（包括）
@param toIndex 要搜索的最后一个元素的索引（不包括）
@param key 要搜索的值
@return 如果它包含在数组的指定范围内，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即范围中第一个大于此键的元素索引，如果范围中的所有元素都小于指定的键，则为 <tt>toIndex</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。
@throws IllegalArgumentException
	       如果 {@code fromIndex > toIndex}
@throws ArrayIndexOutOfBoundsException
	       如果 {@code fromIndex < 0 或 toIndex > a.length}
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(double[] a, double key)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定的 double 型数组，以获得指定的值。必须在进行此调用之前对数组进行排序（通过 {@link #sort(double[])} 方法）。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。此方法认为所有 NaN 值都是等效且相等的。

@param  a 要搜索的数组
@param  key   要搜索的值
@return 如果它包含在数组中，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即第一个大于此键的元素索引，如果数组中的所有元素都小于指定的键，则为 <tt>a.length</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(double[] a, int fromIndex, int toIndex, double key)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定的 double 型数组的范围，以获得指定的值。必须在进行此调用之前对数组进行排序（通过 {@link #sort(double[], int, int)} 方法）。如果没有对范围进行排序，则结果是不确定的。如果范围包含多个带有指定值的元素，则无法保证找到的是哪一个。此方法认为所有 NaN 值都是等效且相等的。

@param a 要搜索的数组
@param fromIndex 要搜索的第一个元素的索引（包括）
@param toIndex 要搜索的最后一个元素的索引（不包括）
@param key 要搜索的值
@return 如果它包含在数组的指定范围内，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即范围中第一个大于此键的元素索引，如果范围中的所有元素都小于指定的键，则为 <tt>toIndex</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。
@throws IllegalArgumentException
	       如果 {@code fromIndex > toIndex}
@throws ArrayIndexOutOfBoundsException
	       如果 {@code fromIndex < 0 或 toIndex > a.length}
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(float[] a, float key)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定的 float 型数组，以获得指定的值。必须在进行此调用之前对数组进行排序（通过 {@link #sort(float[])} 方法）。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。此方法认为所有 NaN 值都是等效且相等的。

@param  a 要搜索的数组
@param  key   要搜索的值
@return 如果它包含在数组中，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即第一个大于此键的元素索引，如果数组中的所有元素都小于指定的键，则为 <tt>a.length</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(float[] a, int fromIndex, int toIndex, float key)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定的 float 型数组的范围，以获得指定的值。必须在进行此调用之前对范围进行排序（通过 {@link #sort(float[], int, int)} 方法）。如果没有对范围进行排序，则结果是不确定的。如果范围包含多个带有指定值的元素，则无法保证找到的是哪一个。此方法认为所有 NaN 值都是等效且相等的。

@param a 要搜索的数组
@param fromIndex 要搜索的第一个元素的索引（包括）
@param toIndex 要搜索的最后一个元素的索引（不包括）
@param key 要搜索的值
@return 如果它包含在数组的指定范围内，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即范围中第一个大于此键的元素索引，如果范围中的所有元素都小于指定的键，则为 <tt>toIndex</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。
@throws IllegalArgumentException
	       如果 {@code fromIndex > toIndex}
@throws ArrayIndexOutOfBoundsException
	       如果 {@code fromIndex < 0 或 toIndex > a.length}
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(java.lang.Object[] a, Object key)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定数组，以获得指定对象。在进行此调用之前，必须根据元素的{@linkplain Comparable 自然顺序}对数组进行升序排序（通过 {@link #sort(Object[])} 方法）。如果没有对数组进行排序，则结果是不确定的。（如果数组包含不可相互比较的元素（例如，字符串和整数），则<i>无法</i> 根据其元素的自然顺序对数组进行排序，因此结果是不确定的。）如果数组包含多个等于指定对象的元素，则无法保证找到的是哪一个。

@param  a 要搜索的数组
@param  key   要搜索的值
@return 如果它包含在数组中，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即第一个大于此键的元素索引，如果数组中的所有元素都小于指定的键，则为 <tt>a.length</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。
@throws ClassCastException 如果搜索的键不能与数组的元素进行比较。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(java.lang.Object[] a, int fromIndex, int toIndex, Object key)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定数组的范围，以获得指定对象。在进行此调用之前，必须根据元素的{@linkplain Comparable 自然顺序}对范围进行升序排序（通过 {@link #sort(Object[], int, int)} 方法）。如果没有对范围进行排序，则结果是不确定的。（如果范围包含不可相互比较的元素，例如，字符串和整数，则<i>无法</i> 根据其元素的自然顺序对范围进行排序，因此结果是不确定的。）如果范围包含多个等于指定对象的元素，则无法保证找到的是哪一个。

@param a 要搜索的数组
@param fromIndex 要搜索的第一个元素的索引（包括）
@param toIndex 要搜索的最后一个元素的索引（不包括）
@param key 要搜索的值
@return 如果它包含在数组的指定范围内，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即范围中第一个大于此键的元素索引，如果范围中的所有元素都小于指定的键，则为 <tt>toIndex</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。
@throws ClassCastException 如果搜索的键不能与数组的指定范围内的元素进行比较。
@throws IllegalArgumentException
	       如果 {@code fromIndex > toIndex}
@throws ArrayIndexOutOfBoundsException
	       如果 {@code fromIndex < 0 或 toIndex > a.length}
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(T[] a, T key, java.util.Comparator<? super T> c)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定数组，以获得指定对象。在进行此调用之前，必须根据指定的比较器（通过 {@link #sort(Object[], Comparator) sort(T[], Comparator)} 方法）对数组进行升序排序。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个等于指定对象的元素，则无法保证找到的是哪一个。

@param  a 要搜索的数组
@param  key   要搜索的值
@param  c 用来对数组进行排序的比较器。<tt>null</tt> 值指示应该使用元素的{@linkplain Comparable 自然顺序}。
@return 如果它包含在数组中，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即第一个大于此键的元素索引，如果数组中的所有元素都小于指定的键，则为 <tt>a.length</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。
@throws ClassCastException 如果数组包含使用指定的比较器不<i>可相互比较</i> 的元素，或者使用此比较器无法相互比较搜索键与数组的元素。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.binarySearch(T[] a, int fromIndex, int toIndex, T key, java.util.Comparator<? super T> c)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用二分搜索法来搜索指定数组的范围，以获得指定对象。在进行此调用之前，必须根据指定的比较器（通过 {@link #sort(Object[], int, int, Comparator)
 sort(T[], int, int, Comparator)} 方法）对范围进行升序排序。如果没有对范围进行排序，则结果是不确定的。如果范围包含多个等于指定对象的元素，则无法保证找到的是哪一个。

@param a 要搜索的数组
@param fromIndex 要搜索的第一个元素的索引（包括）
@param toIndex 要搜索的最后一个元素的索引（不包括）
@param key 要搜索的值
@param  c 用来对数组进行排序的比较器。<tt>null</tt> 值指示应该使用元素的{@linkplain Comparable 自然顺序}。
@return 如果它包含在数组的指定范围内，则返回搜索键的索引；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入数组的那一点：即范围中第一个大于此键的元素索引，如果范围中的所有元素都小于指定的键，则为 <tt>toIndex</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。
@throws ClassCastException 如果范围包含使用指定的比较器不<i>可相互比较</i> 的元素，或者使用此比较器无法相互比较搜索键与范围中的元素。
@throws IllegalArgumentException
	       如果 {@code fromIndex > toIndex}
@throws ArrayIndexOutOfBoundsException
	       如果 {@code fromIndex < 0 或 toIndex > a.length}
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static boolean java.util.Arrays.equals(long[] a, long[] a2)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果两个指定的 long 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>

@param a 将测试其相等性的一个数组
@param a2 将测试其相等性的另一个数组
@return 如果两个数组相等，则返回 <tt>true</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static boolean java.util.Arrays.equals(int[] a, int[] a2)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果两个指定的 int 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>

@param a 将测试其相等性的一个数组
@param a2 将测试其相等性的另一个数组
@return 如果两个数组相等，则返回 <tt>true</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static boolean java.util.Arrays.equals(short[] a, short[] a2)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果两个指定的 short 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>

@param a 将测试其相等性的一个数组
@param a2 将测试其相等性的另一个数组
@return 如果两个数组相等，则返回 <tt>true</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static boolean java.util.Arrays.equals(char[] a, char[] a2)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果两个指定的 char 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>

@param a 将测试其相等性的一个数组
@param a2 将测试其相等性的另一个数组
@return 如果两个数组相等，则返回 <tt>true</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static boolean java.util.Arrays.equals(byte[] a, byte[] a2)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果两个指定的 byte 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>

@param a 将测试其相等性的一个数组
@param a2 将测试其相等性的另一个数组
@return 如果两个数组相等，则返回 <tt>true</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static boolean java.util.Arrays.equals(boolean[] a, boolean[] a2)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果两个指定的 boolean 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>

@param a 将测试其相等性的一个数组
@param a2 将测试其相等性的另一个数组
@return 如果两个数组相等，则返回 <tt>true</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static boolean java.util.Arrays.equals(double[] a, double[] a2)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果两个指定的 double 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>

如果以下条件成立，则认为两个 double 型数组 <tt>d1</tt> 和 <tt>d2</tt> 是相等的：
 <pre>    <tt>new Double(d1).equals(new Double(d2))</tt></pre>
（与 <tt>==</tt> 操作符不同，此方法认为 <tt>NaN</tt> 等于它本身，而 0.0d 不等于 -0.0d。）

@param a 将测试其相等性的一个数组
@param a2 将测试其相等性的另一个数组
@return 如果两个数组相等，则返回 <tt>true</tt>
@see Double#equals(Object)

<!-- END DATA -->
<!-- BEGIN KEY -->
public static boolean java.util.Arrays.equals(float[] a, float[] a2)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果两个指定的 float 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>

如果以下条件成立，则认为两个 float 型数组 <tt>f1</tt> 和 <tt>f2</tt> 是相等的：
<pre>    <tt>new Float(f1).equals(new Float(f2))</tt></pre>
（与 <tt>==</tt> 操作符不同，此方法认为 <tt>NaN</tt> 等于它本身，而 0.0f 不等于 -0.0f。）

@param a 将测试其相等性的一个数组
@param a2 将测试其相等性的另一个数组
@return 如果两个数组相等，则返回 <tt>true</tt>
@see Float#equals(Object)

<!-- END DATA -->
<!-- BEGIN KEY -->
public static boolean java.util.Arrays.equals(java.lang.Object[] a, java.lang.Object[] a2)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果两个指定的 Objects 数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。如果 <tt>(e1==null ? e2==null : e1.equals(e2))</tt>，则认为 <tt>e1</tt> 和 <tt>e2</tt> 这两个对象是<i>相等的</i> 。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>

@param a 将测试其相等性的一个数组
@param a2 将测试其相等性的另一个数组
@return 如果两个数组相等，则返回 <tt>true</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(long[] a, long val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 long 值分配给指定 long 型数组的每个元素。

@param a 要填充的数组
@param val 要存储在数组所有元素中的值

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(long[] a, int fromIndex, int toIndex, long val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 long 值分配给指定 long 型数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）

@param a 要填充的数组
@param fromIndex 要使用指定值填充的第一个元素的索引（包括）
@param toIndex 要使用指定值填充的最后一个元素的索引（不包括）
@param val 要存储在数组所有元素中的值
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt>
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(int[] a, int val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 int 值分配给指定 int 型数组的每个元素。

@param a 要填充的数组
@param val 要存储在数组所有元素中的值

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(int[] a, int fromIndex, int toIndex, int val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）

@param a 要填充的数组
@param fromIndex 要使用指定值填充的第一个元素的索引（包括）
@param toIndex 要使用指定值填充的最后一个元素的索引（不包括）
@param val 要存储在数组所有元素中的值
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(short[] a, short val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 short 值分配给指定 short 型数组的每个元素。

@param a 要填充的数组
@param val 要存储在数组所有元素中的值

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(short[] a, int fromIndex, int toIndex, short val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 short 值分配给指定 short 型数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）

@param a 要填充的数组
@param fromIndex 要使用指定值填充的第一个元素的索引（包括）
@param toIndex 要使用指定值填充的最后一个元素的索引（不包括）
@param val 要存储在数组所有元素中的值
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(char[] a, char val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 char 值分配给指定 char 型数组的每个元素。

@param a 要填充的数组
@param val 要存储在数组所有元素中的值

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(char[] a, int fromIndex, int toIndex, char val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 char 值分配给指定 char 型数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）

@param a 要填充的数组
@param fromIndex 要使用指定值填充的第一个元素的索引（包括）
@param toIndex 要使用指定值填充的最后一个元素的索引（不包括）
@param val 要存储在数组所有元素中的值
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(byte[] a, byte val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 byte 值分配给指定 byte 节型数组的每个元素。

@param a 要填充的数组
@param val 要存储在数组所有元素中的值

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(byte[] a, int fromIndex, int toIndex, byte val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 byte 值分配给指定 byte 型数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）

@param a 要填充的数组
@param fromIndex 要使用指定值填充的第一个元素的索引（包括）
@param toIndex 要使用指定值填充的最后一个元素的索引（不包括）
@param val 要存储在数组所有元素中的值
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(boolean[] a, boolean val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 boolean 值分配给指定 boolean 型数组的每个元素。

@param a 要填充的数组
@param val 要存储在数组所有元素中的值

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(boolean[] a, int fromIndex, int toIndex, boolean val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 boolean 值分配给指定 boolean 型数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）

@param a 要填充的数组
@param fromIndex 要使用指定值填充的第一个元素的索引（包括）
@param toIndex 要使用指定值填充的最后一个元素的索引（不包括）
@param val 要存储在数组所有元素中的值
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(double[] a, double val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 double 值分配给指定 double 型数组的每个元素。

@param a 要填充的数组
@param val 要存储在数组所有元素中的值

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(double[] a, int fromIndex, int toIndex, double val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 double 值分配给指定 double 型数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）

@param a 要填充的数组
@param fromIndex 要使用指定值填充的第一个元素的索引（包括）
@param toIndex 要使用指定值填充的最后一个元素的索引（不包括）
@param val 要存储在数组所有元素中的值
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(float[] a, float val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 float 值分配给指定 float 型数组的每个元素。

@param a 要填充的数组
@param val 要存储在数组所有元素中的值

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(float[] a, int fromIndex, int toIndex, float val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 float 值分配给指定 float 型数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）

@param a 要填充的数组
@param fromIndex 要使用指定值填充的第一个元素的索引（包括）
@param toIndex 要使用指定值填充的最后一个元素的索引（不包括）
@param val 要存储在数组所有元素中的值
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(java.lang.Object[] a, Object val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 Object 引用分配给指定 Object 数组的每个元素。

@param a 要填充的数组
@param val 要存储在数组所有元素中的值
@throws ArrayStoreException 如果指定值不是可存储在指定数组中的运行时类型

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.util.Arrays.fill(java.lang.Object[] a, int fromIndex, int toIndex, Object val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定的 Object 引用分配给指定 Object 数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）

@param a 要填充的数组
@param fromIndex 要使用指定值填充的第一个元素的索引（包括）
@param toIndex 要使用指定值填充的最后一个元素的索引（不包括）
@param val 要存储在数组的所有元素中的值
@throws IllegalArgumentException 如果 <tt>fromIndex &gt; toIndex</tt> 
@throws ArrayIndexOutOfBoundsException 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>
@throws ArrayStoreException 如果指定值不是可存储在指定数组中的运行时类型

<!-- END DATA -->
<!-- BEGIN KEY -->
public static T[] java.util.Arrays.copyOf(T[] original, int newLength)
<!-- END KEY -->
<!-- BEGIN DATA -->
复制指定的数组，截取或用 null 填充（如有必要），以使副本具有指定的长度。对于在原数组和副本中都有效的所有索引，这两个数组将包含相同的值。对于在副本中有效而在原数组无效的所有索引，副本将包含 <tt>null</tt>。当且仅当指定长度大于原数组的长度时，这些索引存在。所得数组和原数组属于完全相同的类。

 @param original 要复制的数组
 @param newLength 要返回的副本的长度
 @return 原数组的副本，截取或用 null 填充以获得指定的长度
 @throws NegativeArraySizeException 如果 <tt>newLength</tt> 为负
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static T[] java.util.Arrays.copyOf(U[] original, int newLength, java.lang.Class<? extends T[]> newType)
<!-- END KEY -->
<!-- BEGIN DATA -->
复制指定的数组，截取或用 null 填充（如有必要），以使副本具有指定的长度。对于在原数组和副本中都有效的所有索引，这两个数组将包含相同的值。对于在副本中有效而在原数组无效的所有索引，副本将包含 <tt>null</tt>。当且仅当指定长度大于原数组的长度时，这些索引存在。所得数组属于 <tt>newType</tt> 类。

 @param original 要复制的数组
 @param newLength 要返回的副本的长度
 @param newType 要返回的副本的类
 @return 原数组的副本，截取或用 null 填充以获得指定的长度
 @throws NegativeArraySizeException 如果 <tt>newLength</tt> 为负
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @throws ArrayStoreException 如果从 <tt>original</tt> 中复制的元素不属于存储在 <tt>newType</tt> 类数组中的运行时类型
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static byte[] java.util.Arrays.copyOf(byte[] original, int newLength)
<!-- END KEY -->
<!-- BEGIN DATA -->
复制指定的数组，截取或用 0 填充（如有必要），以使副本具有指定的长度。对于在原数组和副本中都有效的所有索引，这两个数组将包含相同的值。对于在副本中有效而在原数组无效的所有索引，副本将包含 <tt>(byte)0</tt>。当且仅当指定长度大于原数组的长度时，这些索引存在。

 @param original 要复制的数组
 @param newLength 要返回的副本的长度
 @return 原数组的副本，截取或用 0 填充以获得指定的长度
 @throws NegativeArraySizeException 如果 <tt>newLength</tt> 为负
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static short[] java.util.Arrays.copyOf(short[] original, int newLength)
<!-- END KEY -->
<!-- BEGIN DATA -->
复制指定的数组，截取或用 0 填充（如有必要），以使副本具有指定的长度。对于在原数组和副本中都有效的所有索引，这两个数组将包含相同的值。对于在副本中有效而在原数组无效的所有索引，副本将包含 <tt>(short)0</tt>。当且仅当指定长度大于原数组的长度时，这些索引存在。

 @param original 要复制的数组
 @param newLength 要返回的副本的长度
 @return 原数组的副本，截取或用 0 填充以获得指定的长度
 @throws NegativeArraySizeException 如果 <tt>newLength</tt> 为负
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int[] java.util.Arrays.copyOf(int[] original, int newLength)
<!-- END KEY -->
<!-- BEGIN DATA -->
复制指定的数组，截取或用 0 填充（如有必要），以使副本具有指定的长度。对于在原数组和副本中都有效的所有索引，这两个数组将包含相同的值。对于在副本中有效而在原数组无效的所有索引，副本将包含 <tt>0</tt>。当且仅当指定长度大于原数组的长度时，这些索引存在。

 @param original 要复制的数组
 @param newLength 要返回的副本的长度
 @return 原数组的副本，截取或用 0 填充以获得指定的长度
 @throws NegativeArraySizeException 如果 <tt>newLength</tt> 为负
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static long[] java.util.Arrays.copyOf(long[] original, int newLength)
<!-- END KEY -->
<!-- BEGIN DATA -->
复制指定的数组，截取或用 0 填充（如有必要），以使副本具有指定的长度。对于在原数组和副本中都有效的所有索引，这两个数组将包含相同的值。对于在副本中有效而在原数组无效的所有索引，副本将包含 <tt>0L</tt>。当且仅当指定长度大于原数组的长度时，这些索引存在。

 @param original 要复制的数组
 @param newLength 要返回的副本的长度
 @return 原数组的副本，截取或用 0 填充以获得指定的长度
 @throws NegativeArraySizeException 如果 <tt>newLength</tt> 为负
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static char[] java.util.Arrays.copyOf(char[] original, int newLength)
<!-- END KEY -->
<!-- BEGIN DATA -->
复制指定的数组，截取或用 null 字符填充（如有必要），以使副本具有指定的长度。对于在原数组和副本中都有效的所有索引，这两个数组将包含相同的值。对于在副本中有效而在原数组无效的所有索引，副本将包含 <tt>'\\u000'</tt>。当且仅当指定长度大于原数组的长度时，这些索引存在。

 @param original 要复制的数组
 @param newLength 要返回的副本的长度
 @return 原数组的副本，截取或用 null 字符填充以获得指定的长度
 @throws NegativeArraySizeException 如果 <tt>newLength</tt> 为负
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static float[] java.util.Arrays.copyOf(float[] original, int newLength)
<!-- END KEY -->
<!-- BEGIN DATA -->
复制指定的数组，截取或用 0 填充（如有必要），以使副本具有指定的长度。对于在原数组和副本中都有效的所有索引，这两个数组将包含相同的值。对于在副本中有效而在原数组无效的所有索引，副本将包含 <tt>0f</tt>。当且仅当指定长度大于原数组的长度时，这些索引存在。

 @param original 要复制的数组
 @param newLength 要返回的副本的长度
 @return 原数组的副本，截取或用 0 填充以获得指定的长度
 @throws NegativeArraySizeException 如果 <tt>newLength</tt> 为负
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static double[] java.util.Arrays.copyOf(double[] original, int newLength)
<!-- END KEY -->
<!-- BEGIN DATA -->
复制指定的数组，截取或用 0 填充（如有必要），以使副本具有指定的长度。对于在原数组和副本中都有效的所有索引，这两个数组将包含相同的值。对于在副本中有效而在原数组无效的所有索引，副本将包含 <tt>0d</tt>。当且仅当指定长度大于原数组的长度时，这些索引存在。

 @param original 要复制的数组
 @param newLength 要返回的副本的长度
 @return 原数组的副本，截取或用 0 填充以获得指定的长度
 @throws NegativeArraySizeException 如果 <tt>newLength</tt> 为负
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static boolean[] java.util.Arrays.copyOf(boolean[] original, int newLength)
<!-- END KEY -->
<!-- BEGIN DATA -->
复制指定的数组，截取或用 <tt>false</tt> 填充（如有必要），以使副本具有指定的长度。对于在原数组和副本中都有效的所有索引，这两个数组将包含相同的值。对于在副本中有效而在原数组无效的所有索引，副本将包含 <tt>false</tt>。当且仅当指定长度大于原数组的长度时，这些索引存在。

 @param original 要复制的数组
 @param newLength 要返回的副本的长度
 @return 原数组的副本，截取或用 false 元素填充以获得指定的长度
 @throws NegativeArraySizeException 如果 <tt>newLength</tt> 为负
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static T[] java.util.Arrays.copyOfRange(T[] original, int from, int to)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定数组的指定范围复制到一个新数组。该范围的初始索引 (<tt>from</tt>) 必须位于 0 和 <tt>original.length</tt>（包括）之间。<tt>original[from]</tt> 处的值放入副本的初始元素中（除非 <tt>from == original.length</tt> 或 <tt>from == to</tt>）。原数组中后续元素的值放入副本的后续元素。该范围的最后索引 (<tt>to</tt>)（必须大于等于 <tt>from</tt>）可以大于 <tt>original.length</tt>，在这种情况下，<tt>null</tt> 被放入索引大于等于 <tt>original.length - from</tt> 的副本的所有元素中。返回数组的长度为 <tt>to - from</tt>。
 <p>
所得数组与原数组属于完全相同的类。

 @param original 将要从其复制一个范围的数组
 @param from 要复制的范围的初始索引（包括）
 @param to 要复制的范围的最后索引（不包括）。（此索引可以位于数组范围之外）。
 @return 包含取自原数组指定范围的新数组，截取或用 null 填充以获得所需长度
 @throws ArrayIndexOutOfBoundsException 如果 <tt>from &lt; 0</tt> 或 <tt>from &gt; original.length()</tt>
 @throws IllegalArgumentException 如果 <tt>from &gt; to</tt>
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static T[] java.util.Arrays.copyOfRange(U[] original, int from, int to, java.lang.Class<? extends T[]> newType)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定数组的指定范围复制到一个新数组。该范围的初始索引 (<tt>from</tt>) 必须位于 0 和 <tt>original.length</tt>（包括）之间。<tt>original[from]</tt> 处的值放入副本的初始元素中（除非 <tt>from == original.length</tt> 或 <tt>from == to</tt>）。原数组中后续元素的值放入副本的后续元素。该范围的最后索引 (<tt>to</tt>) （必须大于等于 <tt>from</tt>）可以大于 <tt>original.length</tt>，在这种情况下，<tt>null</tt> 被放入索引大于等于 <tt>original.length - from</tt> 的副本的所有元素中。返回数组的长度为 <tt>to - from</tt>。所得数组属于 <tt>newType</tt> 类。

 @param original 将要从其复制一个范围的数组
 @param from 要复制的范围的初始索引（包括）
 @param to 要复制的范围的最后索引（不包括）。（此索引可以位于数组范围之外）。
 @param newType 要返回的副本的类
 @return 包含取自原数组指定范围的新数组，截取或用 null 填充以获得所需长度
 @throws ArrayIndexOutOfBoundsException 如果 <tt>from &lt; 0</tt> 或 <tt>from &gt; original.length()</tt>
 @throws IllegalArgumentException 如果 <tt>from &gt; to</tt>
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @throws ArrayStoreException 如果从 <tt>original</tt> 复制的元素不属于可以存储在 <tt>newType</tt> 类数组中的运行时类型。
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static byte[] java.util.Arrays.copyOfRange(byte[] original, int from, int to)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定数组的指定范围复制到一个新数组。该范围的初始索引 (<tt>from</tt>) 必须位于 0 和 <tt>original.length</tt>（包括）之间。<tt>original[from]</tt> 处的值放入副本的初始元素中（除非 <tt>from == original.length</tt> 或 <tt>from == to</tt>）。原数组中后续元素的值放入副本的后续元素。该范围的最后索引 (<tt>to</tt>) （必须大于等于 <tt>from</tt>）可以大于 <tt>original.length</tt>，在这种情况下，<tt>(byte)0</tt> 被放入索引大于等于 <tt>original.length - from</tt> 的副本的所有元素中。返回数组的长度为 <tt>to - from</tt>。

 @param original 将要从其复制一个范围的数组
 @param from 要复制的范围的初始索引（包括）
 @param to 要复制的范围的最后索引（不包括）。（此索引可以位于数组范围之外）。
 @return 包含取自原数组指定范围的新数组，截取或用 0 填充以获得所需长度
 @throws ArrayIndexOutOfBoundsException 如果 <tt>from &lt; 0</tt> 或 <tt>from &gt; original.length()</tt>
 @throws IllegalArgumentException 如果 <tt>from &gt; to</tt>
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static short[] java.util.Arrays.copyOfRange(short[] original, int from, int to)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定数组的指定范围复制到一个新数组。该范围的初始索引 (<tt>from</tt>) 必须位于 0 和 <tt>original.length</tt>（包括）之间。<tt>original[from]</tt> 处的值放入副本的初始元素中（除非 <tt>from == original.length</tt> 或 <tt>from == to</tt>）。原数组中后续元素的值放入副本的后续元素。该范围的最后索引 (<tt>to</tt>)（必须大于等于 <tt>from</tt>）可以大于 <tt>original.length</tt>，在这种情况下，<tt>(short)0</tt> 被放入索引大于等于 <tt>original.length - from</tt> 的副本的所有元素中。返回数组的长度为 <tt>to - from</tt>。

 @param original 将要从其复制一个范围的数组
 @param from 要复制的范围的初始索引（包括）
 @param to 要复制的范围的最后索引（不包括）。（此索引可以位于数组范围之外）。
 @return 包含取自原数组指定范围的新数组，截取或用 0 填充以获得所需长度
 @throws ArrayIndexOutOfBoundsException 如果 <tt>from &lt; 0</tt> 或 <tt>from &gt; original.length()</tt>
 @throws IllegalArgumentException 如果 <tt>from &gt; to</tt>
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int[] java.util.Arrays.copyOfRange(int[] original, int from, int to)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定数组的指定范围复制到一个新数组。该范围的初始索引 (<tt>from</tt>) 必须位于 0 和 <tt>original.length</tt>（包括）之间。<tt>original[from]</tt> 处的值放入副本的初始元素中（除非 <tt>from == original.length</tt> 或 <tt>from == to</tt>）。原数组中后续元素的值放入副本的后续元素。该范围的最后索引 (<tt>to</tt>)（必须大于等于 <tt>from</tt>）可以大于 <tt>original.length</tt>，在这种情况下，<tt>0</tt> 被放入索引大于等于 <tt>original.length - from</tt> 的副本的所有元素中。返回数组的长度为 <tt>to - from</tt>。

 @param original 将要从其复制一个范围的数组
 @param from 要复制的范围的初始索引（包括）
 @param to 要复制的范围的最后索引（不包括）。（此索引可以位于数组范围之外）。
 @return 包含取自原数组指定范围的新数组，截取或用 0 填充以获得所需长度
 @throws ArrayIndexOutOfBoundsException 如果 <tt>from &lt; 0</tt> 或 <tt>from &gt; original.length()</tt>
 @throws IllegalArgumentException 如果 <tt>from &gt; to</tt>
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static long[] java.util.Arrays.copyOfRange(long[] original, int from, int to)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定数组的指定范围复制到一个新数组。该范围的初始索引 (<tt>from</tt>) 必须位于 0 和 <tt>original.length</tt>（包括）之间。<tt>original[from]</tt> 处的值放入副本的初始元素中（除非 <tt>from == original.length</tt> 或 <tt>from == to</tt>）。原数组中后续元素的值放入副本的后续元素。该范围的最后索引 (<tt>to</tt>)（必须大于等于 <tt>from</tt>）可以大于 <tt>original.length</tt>，在这种情况下，<tt>>0L</tt> 被放入索引大于等于 <tt>original.length - from</tt> 的副本的所有元素中。返回数组的长度为 <tt>to - from</tt>。

 @param original 将要从其复制一个范围的数组
 @param from 要复制的范围的初始索引（包括）
 @param to 要复制的范围的最后索引（不包括）。（此索引可以位于数组范围之外）。
 @return 包含取自原数组指定范围的新数组，截取或用 0 填充以获得所需长度
 @throws ArrayIndexOutOfBoundsException 如果 <tt>from &lt; 0</tt> 或 <tt>from &gt; original.length()</tt>
 @throws IllegalArgumentException 如果 <tt>from &gt; to</tt>
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static char[] java.util.Arrays.copyOfRange(char[] original, int from, int to)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定数组的指定范围复制到一个新数组。该范围的初始索引 (<tt>from</tt>) 必须位于 0 和 <tt>original.length</tt>（包括）之间。<tt>original[from]</tt> 处的值放入副本的初始元素中（除非 <tt>from == original.length</tt> 或 <tt>from == to</tt>）。原数组中后续元素的值放入副本的后续元素。该范围的最后索引 (<tt>to</tt>)（必须大于等于 <tt>from</tt>）可以大于 <tt>original.length</tt>，在这种情况下，<tt>'\\u000'</tt> 被放入索引大于等于 <tt>original.length - from</tt> 的副本的所有元素中。返回数组的长度为 <tt>to - from</tt>。

 @param original 将要从其复制一个范围的数组
 @param from 要复制的范围的初始索引（包括）
 @param to 要复制的范围的最后索引（不包括）。（此索引可以位于数组范围之外）。
 @return 包含取自原数组指定范围的新数组，截取或用 0 填充以获得所需长度
 @throws ArrayIndexOutOfBoundsException 如果 <tt>from &lt; 0</tt> 或 <tt>from &gt; original.length()</tt>
 @throws IllegalArgumentException 如果 <tt>from &gt; to</tt>
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static float[] java.util.Arrays.copyOfRange(float[] original, int from, int to)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定数组的指定范围复制到一个新数组。该范围的初始索引 (<tt>from</tt>) 必须位于 0 和 <tt>original.length</tt>（包括）之间。<tt>original[from]</tt> 处的值放入副本的初始元素中（除非 <tt>from == original.length</tt> 或 <tt>from == to</tt>）。原数组中后续元素的值放入副本的后续元素。该范围的最后索引 (<tt>to</tt>)（必须大于等于 <tt>from</tt>）可以大于 <tt>original.length</tt>，在这种情况下，<tt>0f</tt> 被放入索引大于等于 <tt>original.length - from</tt> 的副本的所有元素中。返回数组的长度为 <tt>to - from</tt>。

 @param original 将要从其复制一个范围的数组
 @param from 要复制的范围的初始索引（包括）
 @param to 要复制的范围的最后索引（不包括）。（此索引可以位于数组范围之外）。
 @return 包含取自原数组指定范围的新数组，截取或用 0 填充以获得所需长度
 @throws ArrayIndexOutOfBoundsException 如果 <tt>from &lt; 0</tt> 或 <tt>from &gt; original.length()</tt>
 @throws IllegalArgumentException 如果 <tt>from &gt; to</tt>
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static double[] java.util.Arrays.copyOfRange(double[] original, int from, int to)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定数组的指定范围复制到一个新数组。该范围的初始索引 (<tt>from</tt>) 必须位于 0 和 <tt>original.length</tt>（包括）之间。<tt>original[from]</tt> 处的值放入副本的初始元素中（除非 <tt>from == original.length</tt> 或 <tt>from == to</tt>）。原数组中后续元素的值放入副本的后续元素。该范围的最后索引 (<tt>to</tt>)（必须大于等于 <tt>from</tt>）可以大于 <tt>original.length</tt>，在这种情况下，<tt>0d</tt> 被放入索引大于等于 <tt>original.length - from</tt> 的副本的所有元素中。返回数组的长度为 <tt>to - from</tt>。

 @param original 将要从其复制一个范围的数组
 @param from 要复制的范围的初始索引（包括）
 @param to 要复制的范围的最后索引（不包括）。（此索引可能位于数组范围之外）。
 @return 包含取自原数组指定范围的新数组，截取或用 0 填充以获得所需长度
 @throws ArrayIndexOutOfBoundsException 如果 <tt>from &lt; 0</tt> 或 <tt>from &gt; original.length()</tt>
 @throws IllegalArgumentException 如果 <tt>from &gt; to</tt>
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static boolean[] java.util.Arrays.copyOfRange(boolean[] original, int from, int to)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定数组的指定范围复制到一个新数组。该范围的初始索引 (<tt>from</tt>) 必须位于 0 和 <tt>original.length</tt>（包括）之间。<tt>original[from]</tt> 处的值放入副本的初始元素中（除非 <tt>from == original.length</tt> 或 <tt>from == to</tt>）。原数组中后续元素的值放入副本的后续元素。该范围的最后索引 (<tt>to</tt>) （必须大于等于 <tt>from</tt>）可以大于 <tt>original.length</tt>，在这种情况下，<tt>false</tt> 被放入索引大于等于 <tt>original.length - from</tt> 的副本的所有元素中。返回数组的长度为 <tt>to - from</tt>。

 @param original 将要从其复制一个范围的数组
 @param from 要复制的范围的初始索引（包括）
 @param to 要复制的范围的最后索引（不包括）。（此索引可能位于数组范围之外）。
 @return 包含取自原数组指定范围的新数组，截取或用 false 元素填充以获得所需长度
 @throws ArrayIndexOutOfBoundsException 如果 <tt>from &lt; 0</tt> 或 <tt>from &gt; original.length()</tt>
 @throws IllegalArgumentException 如果 <tt>from &gt; to</tt>
 @throws NullPointerException 如果 <tt>original</tt> 为 null
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.util.List<T> java.util.Arrays.asList(T[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个受指定数组支持的固定大小的列表。（对返回列表的更改会“直接写”到数组。）此方法同 {@link Collection#toArray} 一起，充当了基于数组的 API 与基于 collection 的 API 之间的桥梁。返回的列表是可序列化的，并且实现了 {@link RandomAccess}。

<p>此方法还提供了一个创建固定长度的列表的便捷方法，该列表被初始化为包含多个元素：
 <pre>
     List&lt;String&gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);
 </pre>


@param a 支持列表的数组。
@return 指定数组的列表视图。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.hashCode(long[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
基于指定数组的内容返回哈希码。对于任何两个满足 <tt>Arrays.equals(a, b)</tt> 的 <tt>long</tt> 型数组 <tt>a</tt> 和 <tt>b</tt>，也可以说 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值与在 {@link List} 上调用 {@link List#hashCode() <tt>hashCode</tt>} 方法获得的值相同，该 List 包含以相同顺序表示 <tt>a</tt> 数组元素的 {@link Long} 实例的序列。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。

@param a 要计算其哈希值的数组
@return <tt>a</tt> 数组基于内容的哈希码
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.hashCode(int[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
基于指定数组的内容返回哈希码。对于任何两个满足 <tt>Arrays.equals(a, b)</tt> 的非 null <tt>int</tt> 型数组 <tt>a</tt> 和 <tt>b</tt>，也可以说 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值与在 {@link List} 上调用 {@link List#hashCode() <tt>hashCode</tt>} 方法获得的值相同，该 List 包含以相同顺序表示 <tt>a</tt> 数组元素的 {@link Integer} 实例的序列。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。

@param a 要计算其哈希值的数组 
@return <tt>a</tt> 数组基于内容的哈希码
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.hashCode(short[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
基于指定数组的内容返回哈希码。对于任何两个满足 <tt>Arrays.equals(a, b)</tt> 的 <tt>short</tt> 型数组 <tt>a</tt> 和 <tt>b</tt>，也可用说 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值与在 {@link List} 上调用 {@link List#hashCode() <tt>hashCode</tt>} 方法获得的值相同，该 List 包含以相同顺序表示 <tt>a</tt> 数组元素的 {@link Short} 实例的序列。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。

@param a 要计算其哈希值的数组
@return <tt>a</tt> 数组基于内容的哈希码
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.hashCode(char[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
基于指定数组的内容返回哈希码。对于任何两个满足 <tt>Arrays.equals(a, b)</tt> 的 <tt>char</tt> 型数组 <tt>a</tt> 和 <tt>b</tt>，也可用说 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值与在 {@link List} 上调用 {@link List#hashCode() <tt>hashCode</tt>} 方法获得的值相同，该 List 包含以相同顺序表示 <tt>a</tt> 数组元素的 {@link Character} 实例的序列。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。

@param a 要计算其哈希值的数组
@return <tt>a</tt> 数组基于内容的哈希码
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.hashCode(byte[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
基于指定数组的内容返回哈希码。对于任何两个满足 <tt>Arrays.equals(a, b)</tt> 的 <tt>byte</tt> 型数组 <tt>a</tt> 和 <tt>b</tt>，也可用说 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值与在 {@link List} 上调用 {@link List#hashCode() <tt>hashCode</tt>} 方法获得的值相同，该 List 包含以相同顺序表示 <tt>a</tt> 数组元素的 {@link Byte} 实例的序列。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。

@param a 要计算其哈希值的数组
@return <tt>a</tt> 数组基于内容的哈希码
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.hashCode(boolean[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
基于指定数组的内容返回哈希码。对于任何两个满足 <tt>Arrays.equals(a, b)</tt> 的 <tt>boolean</tt> 型数组 <tt>a</tt> 和 <tt>b</tt>，也可以说 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值与在 {@link List} 上调用 {@link List#hashCode() <tt>hashCode</tt>} 方法获得的值相同，该 List 包含以相同顺序表示 <tt>a</tt> 数组元素的 {@link Boolean} 实例的序列。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。

@param a 要计算其哈希值的数组
@return <tt>a</tt> 数组基于内容的哈希码
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.hashCode(float[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
基于指定数组的内容返回哈希码。对于任何两个满足  <tt>Arrays.equals(a, b)</tt> 的 <tt>float</tt> 型数组 <tt>a</tt> 和 <tt>b</tt>，也可以说  <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值与在 {@link List} 上调用 {@link List#hashCode() <tt>hashCode</tt>} 方法获得的值相同，该 List 包含以相同顺序表示 <tt>a</tt> 数组元素的 {@link Float} 实例的序列。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。

@param a 要计算其哈希值的数组
@return <tt>a</tt> 数组基于内容的哈希码
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.hashCode(double[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
基于指定数组的内容返回哈希码。对于任何两个满足 <tt>Arrays.equals(a, b)</tt> 的 <tt>double</tt> 型数组 <tt>a</tt> 和 <tt>b</tt>，也可以说  <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值与在 {@link List} 上调用 {@link List#hashCode() <tt>hashCode</tt>} 方法获得的值相同，该 List 包含以相同顺序表示 <tt>a</tt> 数组元素的 {@link Double} 实例的序列。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。

@param a 要计算其哈希值的数组
@return <tt>a</tt> 数组基于内容的哈希码
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.hashCode(java.lang.Object[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
基于指定数组的内容返回哈希码。如果数组包含作为元素的其他数组，则哈希码将基于其标识，而不是基于其内容。所以，在将自身包含为一个元素的数组上，直接或间接通过一个或多个数组级别来调用此方法是可接受的。

<p>对于任何两个满足 <tt>Arrays.equals(a, b)</tt> 的数组 <tt>a</tt> 和 <tt>b</tt>，也可以说 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值等于 <tt>Arrays.asList(a).hashCode()</tt> 返回的值，除非 <tt>a</tt> 为 <tt>null</tt>，在这种情况下返回 <tt>0</tt>。

@param a 将计算其基于内容的哈希码的数组
@return <tt>a</tt> 数组基于内容的哈希码
@see #deepHashCode(Object[])
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.util.Arrays.deepHashCode(java.lang.Object[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
基于指定数组的“深层内容”返回哈希码。如果数组包含作为元素的其他数组，则哈希码将基于其内容，并以此类推，直至无穷。所以，在将自身包含为一个元素的数组上，直接或间接通过一个或多个数组级别来调用此方法是不可接受的。这种调用的行为是不确定的。

<p>对于任何两个满足 <tt>Arrays.deepEquals(a, b)</tt> 的数组 <tt>a</tt> 和 <tt>b</tt>，也可以说 <tt>Arrays.deepHashCode(a) == Arrays.deepHashCode(b)</tt>。

<p>对此方法返回值的计算类似于对列表上的 {@link List#hashCode()} 返回值的计算，该列表以相同的顺序包含与 <tt>a</tt> 数组相同的元素，但有一点不同：如果数组 <tt>a</tt> 的 <tt>e</tt> 元素本身是一个数组，则不能通过调用 <tt>e.hashCode()</tt> 计算其哈希码，但是，如果 <tt>e</tt> 是一个基本类型数组，则可以通过调用 <tt>Arrays.hashCode(e)</tt> 的适当重载来计算其哈希码，或者，如果 <tt>e</tt> 是一个引用类型数组，则可以通过递归调用 <tt>Arrays.deepHashCode(e)</tt> 来计算其哈希码。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。

@param a 将计算其基于深层内容的哈希码的数组
@return <tt>a</tt> 数组基于深层内容的哈希码
@see #hashCode(Object[])
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static boolean java.util.Arrays.deepEquals(java.lang.Object[] a1, java.lang.Object[] a2)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果两个指定数组彼此是<i>深层相等</i> 的，则返回 <tt>true</tt>。与 {@link #equals(Object[],Object[])} 方法不同，此方法适用于任意深度的嵌套数组。

<p>如果两个数组引用均为 <tt>null</tt>，或者它们引用了包含相同元素数量的数组，并且两个数组中的所有相应元素对都是深层相等的，则认为这两个数组引用是深层相等的。

<p>如果满足以下任意条件之一，则两个 <tt>null</tt> 元素 <tt>e1</tt> 和 <tt>e2</tt> 可能是深层相等的：
 <ul>
<li> <tt>e1</tt> 和 <tt>e2</tt> 都是对象引用类型的数组，并且 <tt>Arrays.deepEquals(e1, e2)</tt> 将返回 true。
<li> <tt>e1</tt> 和 <tt>e2</tt> 都是相同基本类型的数组，并且 <tt>Arrays.equals(e1, e2)</tt> 的适当重载将返回 true。
    <li> <tt>e1 == e2</tt>
<li> <tt>e1.equals(e2)</tt> 将返回 true。
 </ul>
注意，此定义支持任意深度的 <tt>null</tt> 元素。

<p>如果指定数组中的任意一个数组，直接或间接通过一个或多个数组级别，包含数组本身作为其元素，则此方法的行为是不确定的。

@param a1 将测试其相等性的一个数组 
@param a2 将测试其相等性的另一个数组
@return 如果两个数组相等，则返回 <tt>true</tt>
@see #equals(Object[],Object[])
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.lang.String java.util.Arrays.toString(long[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定数组内容的字符串表示形式。字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(long)</tt> 转换为字符串。如果 <tt>a</tt> 为 <tt>null</tt>，则返回 <tt>"null"</tt>。

@param a 返回其字符串表示形式的数组
@return <tt>a</tt> 的字符串表示形式
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.lang.String java.util.Arrays.toString(int[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定数组内容的字符串表示形式。字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(int)</tt> 转换为字符串。如果 <tt>a</tt> 为 <tt>null</tt>，则返回 <tt>"null"</tt>。

@param  a 返回其字符串表示形式的数组
@return <tt>a</tt> 的字符串表示形式
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.lang.String java.util.Arrays.toString(short[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定数组内容的字符串表示形式。字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(short)</tt> 转换为字符串。如果 <tt>a</tt> 为 <tt>null</tt>，则返回 <tt>"null"</tt>。

@param a 返回其字符串表示形式的数组
@return <tt>a</tt> 的字符串表示形式
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.lang.String java.util.Arrays.toString(char[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定数组内容的字符串表示形式。字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(char)</tt> 转换为字符串。如果 <tt>a</tt> 为 <tt>null</tt>，则返回 <tt>"null"</tt>。

@param a 返回其字符串表示形式的数组
@return <tt>a</tt> 的字符串表示形式
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.lang.String java.util.Arrays.toString(byte[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定数组内容的字符串表示形式。字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(byte)</tt> 转换为字符串。如果 <tt>a</tt> 为 <tt>null</tt>，则返回 <tt>"null"</tt>。

@param a 返回其字符串表示形式的数组
@return <tt>a</tt> 的字符串表示形式
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.lang.String java.util.Arrays.toString(boolean[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定数组内容的字符串表示形式。字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(boolean)</tt> 转换为字符串。如果 <tt>a</tt> 为 <tt>null</tt>，则返回 <tt>"null"</tt>。

@param a 返回其字符串表示形式的数组
@return <tt>a</tt> 的字符串表示形式
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.lang.String java.util.Arrays.toString(float[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定数组内容的字符串表示形式。字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(float)</tt> 转换为字符串。如果 <tt>a</tt> 为 <tt>null</tt>，则返回 <tt>"null"</tt>。

@param a 返回其字符串表示形式的数组
@return <tt>a</tt> 的字符串表示形式
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.lang.String java.util.Arrays.toString(double[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定数组内容的字符串表示形式。字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(double)</tt> 转换为字符串。如果 <tt>a</tt> 为 <tt>null</tt>，则返回 <tt>"null"</tt>。

@param a 返回其字符串表示形式的数组
@return <tt>a</tt> 的字符串表示形式
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.lang.String java.util.Arrays.toString(java.lang.Object[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定数组内容的字符串表示形式。如果数组包含作为元素的其他数组，则通过从 <tt>Object</tt> 中继承的 {@link Object#toString} 方法将它们转换为字符串，这描述了它们的<i>标识</i>，而不是它们的内容。

<p>此方法返回的值等于 <tt>Arrays.asList(a).toString()</tt> 返回的值，除非 <tt>a</tt> 为 <tt>null</tt>，在这种情况下返回 <tt>"null"</tt>。

@param a 返回其字符串表示形式的数组
@return <tt>a</tt> 的字符串表示形式
@see #deepToString(Object[])
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.lang.String java.util.Arrays.deepToString(java.lang.Object[] a)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定数组“深层内容”的字符串表示形式。如果数组包含作为元素的其他数组，则字符串表示形式包含其内容等。此方法是为了将多维数组转换为字符串而设计的。

<p>字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(Object)</tt> 转换为字符串，除非它们是自身的数组。

<p>如果元素 <tt>e</tt> 是一个基本类型的数组，则通过调用 <tt>Arrays.toString(e)</tt> 的适当重载将它转换为字符串。如果元素 <tt>e</tt> 是一个引用类型的数组，则通过递归调用此方法将它转换为字符串。

<p>为了避免无限递归，如果指定数组包含本身作为其元素，或者包含通过一个或多个数组级别对其自身的间接引用，则将自引用转换为字符串 <tt>"[...]"</tt>。例如，只包含对自身进行引用的数组将呈现为 <tt>"[[...]]"</tt>。

<p>如果指定数组为 <tt>null</tt>，则此方法返回 <tt>"null"</tt>。

@param a 返回其字符串表示形式的数组
@return <tt>a</tt> 的字符串表示形式
@see #toString(Object[])
@since 1.5

<!-- END DATA -->


