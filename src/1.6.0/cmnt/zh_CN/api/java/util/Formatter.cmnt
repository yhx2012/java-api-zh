<!-- BEGIN KEY -->
public final class java.util.Formatter extends java.lang.Object implements java.io.Closeable, java.io.Flushable
<!-- END KEY -->
<!-- BEGIN DATA -->
printf 风格的格式字符串的解释程序。此类提供了对布局对齐和排列的支持，以及对数值、字符串和日期/时间数据的常规格式和特定于语言环境的输出的支持。支持诸如 <tt>byte</tt>、{@link java.math.BigDecimal BigDecimal} 和 {@link Calendar} 等常见 Java 类型。任意用户类型的受限格式化定制都是通过 {@link Formattable} 接口提供的。

<p> Formatter 对于多线程访问而言没必要是安全的。线程安全是可选的，它对此类中的方法用户负责。

<p> Java 语言的格式化输出在很大程度上受到 C 语言 <tt>printf</tt> 的启发。虽然一些格式字符串与 C 类似，但已进行了某些定制，以适应 Java 语言，并且利用了其中一些特性。此外，Java 的格式比 C 的格式更严格；例如，如果转换与标志不兼容，则会抛出异常。在 C 中，不适用的标志会被忽略。这样，便于 C 程序员识别这些格式字符串，而又不必与 C 中的那些标志完全兼容。

<p> 所期望用法的示例：

 <blockquote><pre>
   StringBuilder sb = new StringBuilder();
   // Send all output to the Appendable object sb
   Formatter formatter = new Formatter(sb, Locale.US);

   // Explicit argument indices may be used to re-order output.
   formatter.format("%4$2s %3$2s %2$2s %1$2s", "a", "b", "c", "d")
   // -&gt; " d  c  b  a"

   // Optional locale as the first argument can be used to get
   // locale-specific formatting of numbers.  The precision and width can be
   // given to round and align the value.
   formatter.format(Locale.FRANCE, "e = %+10.4f", Math.E);
   // -&gt; "e =    +2,7183"

   // The '(' numeric flag may be used to format negative numbers with
   // parentheses rather than a minus sign.  Group separators are
   // automatically inserted.
   formatter.format("Amount gained or lost since last statement: $ %(,.2f",
                    balanceDelta);
   // -&gt; "Amount gained or lost since last statement: $ (6,217.58)"
 </pre></blockquote>

<p> 常见格式化请求的便捷方法是按照如下调用格式来阐明的：

 <blockquote><pre>
   // Writes a formatted string to System.out.
   System.out.format("Local time: %tT", Calendar.getInstance());
   // -&gt; "Local time: 13:34:18"

   // Writes formatted output to System.err.
   System.err.printf("Unable to open file '%1$s': %2$s",
                     fileName, exception.getMessage());
   // -&gt; "Unable to open file 'food': No such file or directory"
 </pre></blockquote>

<p> 与 C 语言的 <tt>sprintf(3)</tt> 类似，可以使用静态方法 {@link String#format(String,Object...)String.format} 来格式化 Strings：

 <blockquote><pre>
   // Format a string containing a date.
   import java.util.Calendar;
   import java.util.GregorianCalendar;
   import static java.util.Calendar.*;

   Calendar c = new GregorianCalendar(1995, MAY, 23);
   String s = String.format("Duke's Birthday: %1$tm %1$te,%1$tY", c);
   // -> s == "Duke's Birthday: May 23, 1995"
 </pre></blockquote>

 <h3><a name="org">结构</a></h3>

<p> 此规范分为两部分。第一部分是<a href="#summary">摘要</a>，包括基本的格式概念。这一部分是为那些想要快速入门并熟悉其他编程语言的格式化输出的用户准备的。第二部分是<a href="#detail">详细信息</a>，包括具体的实现细节。它是为那些需要更精确格式化行为规范的用户准备的。

 <h3><a name="summary"> 摘要 </a></h3>

<p>这一部分将提供对格式概念的简单概述。有关精确的行为细节，请参阅<a href="#detail">详细信息</a>部分。

 <h4><a name="syntax"> 格式字符串语法 </a></h4>
<p> 产生格式化输出的每个方法都需要<i>格式字符串</i> 和<i>参数列表</i>。格式字符串是一个 {@link String}，它可以包含固定文本以及一个或多个嵌入的<i>格式说明符</i>。请考虑以下示例：

 <blockquote><pre>
   Calendar c = ...;
   String s = String.format("Duke's Birthday: %1$tm %1$te,%1$tY", c);
 </pre></blockquote>

此格式字符串是 <tt>format</tt> 方法的第一个参数。它包含三个格式说明符 &quot;<tt>%1$tm</tt>&quot;、&quot;<tt>%1$te</tt>&quot; 和 &quot;<tt>%1$tY</tt>&quot;，它们指出应该如何处理参数以及在文本的什么地方插入它们。格式字符串的其余部分是包括 <tt>&quot;Dukes Birthday: &quot;</tt> 和其他任何空格或标点符号的固定文本。

参数列表由传递给位于格式字符串之后的方法的所有参数组成。在上述示例中，参数列表的大小为 1，由对象 {@link java.util.Calendar Calendar} <tt>c</tt> 组成。

 <ul>

<li> 常规类型、字符类型和数值类型的格式说明符的语法如下：

 <blockquote><pre>
   %[argument_index$][flags][width][.precision]conversion
 </pre></blockquote>

<p> 可选的 <i>argument_index</i> 是一个十进制整数，用于表明参数在参数列表中的位置。第一个参数由 &quot;<tt>1$</tt>&quot; 引用，第二个参数由 &quot;<tt>2$</tt>&quot; 引用，依此类推。

<p> 可选 <i>flags</i> 是修改输出格式的字符集。有效标志集取决于转换类型。

<p> 可选 <i>width</i> 是一个非负十进制整数，表明要向输出中写入的最少字符数。

<p> 可选 <i>precision</i> 是一个非负十进制整数，通常用来限制字符数。特定行为取决于转换类型。

<p> 所需 <i>conversion</i> 是一个表明应该如何格式化参数的字符。给定参数的有效转换集取决于参数的数据类型。

<li> 用来表示日期和时间类型的格式说明符的语法如下：

 <blockquote><pre>
   %[argument_index$][flags][width]conversion
 </pre></blockquote>

<p> 可选的 <i>argument_index</i>、<i>flags</i> 和 <i>width</i> 的定义同上。

<p> 所需的 <i>conversion</i> 是一个由两字符组成的序列。第一个字符是 <tt>'t'</tt> 或 <tt>'T'</tt>。第二个字符表明所使用的格式。这些字符类似于但不完全等同于那些由 GNU <tt>date</tt> 和 POSIX <tt>strftime(3c)</tt> 定义的字符。

<li> 与参数不对应的格式说明符的语法如下：

 <blockquote><pre>
   %[flags][width]conversion
 </pre></blockquote>

<p> 可选 <i>flags</i> 和 <i>width</i> 的定义同上。

<p> 所需的 <i>conversion</i> 是一个表明要在输出中所插内容的字符。

 </ul>

<h4> 转换 </h4>

<p> 转换可分为以下几类：

 <ol>

<li> <b>常规</b> - 可应用于任何参数类型

<li> <b>字符</b> - 可应用于表示 Unicode 字符的基本类型：<tt>char</tt>、{@link Character}、<tt>byte</tt>、{@link Byte}、<tt>short</tt> 和 {@link Short}。当 {@link Character#isValidCodePoint} 返回 <tt>true</tt> 时，可将此转换应用于 <tt>int</tt> 和 {@link Integer} 类型

<li> <b>数值</b>

 <ol>

<li> <b>整数</b> - 可应用于 Java 的整数类型：<tt>byte</tt>、{@link Byte}、<tt>short</tt>、{@link Short}、<tt>int</tt>、{@link Integer}、<tt>long</tt>、{@link Long} 和 {@link java.math.BigInteger BigInteger}

<li><b>浮点</b> - 可用于 Java 的浮点类型：<tt>float</tt>、{@link Float}、<tt>double</tt>、{@link Double} 和 {@link java.math.BigDecimal BigDecimal}

 </ol>

<li> <b>日期/时间</b> - 可应用于 Java 的、能够对日期或时间进行编码的类型：<tt>long</tt>、{@link Long}、{@link Calendar} 和 {@link Date}。

<li> <b>百分比</b> - 产生字面值 <tt>'%'</tt> (<tt>'\u0025'</tt>)

<li> <b>行分隔符</b> - 产生特定于平台的行分隔符

 </ol>

<p> 下表总结了受支持的转换。由大写字符（如 <tt>'B'</tt>、<tt>'H'</tt>、<tt>'S'</tt>、<tt>'C'</tt>、<tt>'X'</tt>、<tt>'E'</tt>、<tt>'G'</tt>、<tt>'A'</tt> 和 <tt>'T'</tt>）表示的转换与由相应的小写字符的转换等同，根据流行的 {@link java.util.Locale Locale} 规则将结果转换为大写形式除外。后者等同于 {@link String#toUpperCase()} 的以下调用

 <pre>
    out.toUpperCase() </pre>

 <table cellpadding=5 summary="genConv">

<tr><th valign="bottom"> 转换
    <th valign="bottom"> 参数类别
    <th valign="bottom"> 说明

<tr><td valign="top"> <tt>'b'</tt>, <tt>'B'</tt>
    <td valign="top"> 常规
    <td> 如果参数 <i>arg</i> 为 <tt>null</tt>，则结果为 &quot;<tt>false</tt>&quot;。如果 <i>arg</i> 是一个 <tt>boolean</tt> 值或 {@link Boolean}，则结果为 {@link String#valueOf(boolean) String.valueOf()} 返回的字符串。否则结果为 &quot;true&quot;。

<tr><td valign="top"> <tt>'h'</tt>, <tt>'H'</tt>
    <td valign="top"> 常规
    <td> 如果参数 <i>arg</i> 为 <tt>null</tt>，则结果为 &quot;<tt>null</tt>&quot;。否则，结果为调用 <tt>Integer.toHexString(arg.hashCode())</tt> 得到的结果。

<tr><td valign="top"> <tt>'s'</tt>, <tt>'S'</tt>
    <td valign="top"> 常规
    <td> 如果参数 <i>arg</i> 为 <tt>null</tt>，则结果为 &quot;<tt>null</tt>&quot;。如果 <i>arg</i> 实现 {@link Formattable}，则调用 {@link Formattable#formatTo arg.formatTo}。否则，结果为调用 <tt>arg.toString()</tt> 得到的结果。

<tr><td valign="top"><tt>'c'</tt>, <tt>'C'</tt>
    <td valign="top"> 字符
    <td> 结果是一个 Unicode 字符

<tr><td valign="top"><tt>'d'</tt>
    <td valign="top"> 整数
    <td> 结果被格式化为十进制整数

<tr><td valign="top"><tt>'o'</tt>
    <td valign="top"> 整数
    <td> 结果被格式化为八进制整数

<tr><td valign="top"><tt>'x'</tt>, <tt>'X'</tt>
    <td valign="top"> 整数
    <td> 结果被格式化为十六进制整数

<tr><td valign="top"><tt>'e'</tt>, <tt>'E'</tt>
    <td valign="top"> 浮点
    <td> 结果被格式化为用计算机科学记数法表示的十进制数

<tr><td valign="top"><tt>'f'</tt>
    <td valign="top"> 浮点
    <td> 结果被格式化为十进制数

<tr><td valign="top"><tt>'g'</tt>, <tt>'G'</tt>
    <td valign="top"> 浮点
    <td> 根据精度和舍入运算后的值，使用计算机科学记数形式或十进制格式对结果进行格式化。

<tr><td valign="top"><tt>'a'</tt>, <tt>'A'</tt>
    <td valign="top"> 浮点
    <td> 结果被格式化为带有效位数和指数的十六进制浮点数

<tr><td valign="top"><tt>'t'</tt>, <tt>'T'</tt>
    <td valign="top"> 日期/时间
    <td> 日期和时间转换字符的前缀。请参阅<a href="#dt">日期/时间转换</a>。

<tr><td valign="top"><tt>'%'</tt>
    <td valign="top"> 百分比
    <td> 结果为字面值 <tt>'%'</tt> (<tt>'\u0025'</tt>)

<tr><td valign="top"><tt>'n'</tt>
    <td valign="top"> 行分隔符
    <td> 结果为特定于平台的行分隔符

</table>

<p> 任何未明确定义为转换的字符都是非法字符，并且都被保留，以供将来扩展使用。

 <h4><a name="dt"> 日期/时间转换</a></h4>

<p> 以下日期和时间转换的后缀字符是为 <tt>'t'</tt> 和 <tt>'T'</tt> 转换定义的。这些类型相似于但不完全等同于那些由 GNU <tt>date</tt> 和 POSIX <tt>strftime(3c)</tt> 定义的类型。提供其他转换类型是为了访问特定于 Java 的功能（如将 <tt>'L'</tt> 用作秒中的毫秒）。

<p> 以下转换字符用来格式化时间：

<table cellpadding=5 summary="time">

<tr><td valign="top"> <tt>'H'</tt>
    <td> 24 小时制的小时，被格式化为必要时带前导零的两位数，即 <tt>00 - 23</tt>。

<tr><td valign="top"><tt>'I'</tt>
    <td> 12 小时制的小时，被格式化为必要时带前导零的两位数，即 <tt>01 - 12</tt>。

<tr><td valign="top"><tt>'k'</tt>
    <td> 24 小时制的小时，即 <tt>0 - 23</tt>。

<tr><td valign="top"><tt>'l'</tt>
    <td> 12 小时制的小时，即 <tt>1 - 12</tt>。

<tr><td valign="top"><tt>'M'</tt>
    <td> 小时中的分钟，被格式化为必要时带前导零的两位数，即 <tt>00 - 59</tt>。

<tr><td valign="top"><tt>'S'</tt>
    <td> 分钟中的秒，被格式化为必要时带前导零的两位数，即 <tt>00 - 60</tt> （"<tt>60</tt>" 是支持闰秒所需的一个特殊值）。

<tr><td valign="top"><tt>'L'</tt>
    <td> 秒中的毫秒，被格式化为必要时带前导零的三位数，即 <tt>000 - 999</tt>。

<tr><td valign="top"><tt>'N'</tt>
    <td> 秒中的毫微秒，被格式化为必要时带前导零的九位数，即 <tt>000000000 - 999999999</tt>。

<tr><td valign="top"><tt>'p'</tt>
    <td> 特定于语言环境的 {@linkplain java.text.DateFormatSymbols#getAmPmStrings 上午或下午} 标记以小写形式表示，例如 "<tt>am</tt>" 或 "<tt>pm</tt>"。使用转换前缀 <tt>'T'</tt> 可以强行将此输出转换为大写形式。

<tr><td valign="top"><tt>'z'</tt>
    <td> 相对于 GMT 的 <a href="http://www.ietf.org/rfc/rfc0822.txt">RFC&nbsp;822</a> 格式的数字时区偏移量，例如 <tt>-0800</tt>。

<tr><td valign="top"><tt>'Z'</tt>
    <td> 表示时区缩写形式的字符串。Formatter 的语言环境将取代参数的语言环境（如果有）。

<tr><td valign="top"><tt>'s'</tt>
    <td> 自协调世界时 (UTC) 1970 年 1 月 1 日 <tt>00:00:00</tt> 至现在所经过的秒数，即 <tt>Long.MIN_VALUE/1000</tt> 与 <tt>Long.MAX_VALUE/1000</tt> 之间的差值。

<tr><td valign="top"><tt>'Q'</tt>
    <td> 自协调世界时 (UTC) 1970 年 1 月 1 日 <tt>00:00:00</tt> 至现在所经过的毫秒数，即 <tt>Long.MIN_VALUE</tt> 与 <tt>Long.MAX_VALUE</tt> 之间的差值。

 </table>

<p> 以下转换字符用来格式化日期：

 <table cellpadding=5 summary="date">

<tr><td valign="top"><tt>'B'</tt>
    <td> 特定于语言环境的{@linkplain java.text.DateFormatSymbols#getMonths 月份全称}，例如 <tt>"January"</tt> 和 <tt>"February"</tt>。

<tr><td valign="top"><tt>'b'</tt>
    <td> 特定于语言环境的{@linkplain java.text.DateFormatSymbols#getShortMonths 月份简称}，例如 <tt>"Jan"</tt> 和 <tt>"Feb"</tt>。

<tr><td valign="top"><tt>'h'</tt>
    <td> 与 <tt>'b'</tt> 相同。

<tr><td valign="top"><tt>'A'</tt>
    <td> 特定于语言环境的{@linkplain java.text.DateFormatSymbols#getWeekdays 星期几}全称，例如 <tt>"Sunday"</tt> 和 <tt>"Monday"</tt>

<tr><td valign="top"><tt>'a'</tt>
    <td> 特定于语言环境的{@linkplain java.text.DateFormatSymbols#getShortWeekdays 星期几}简称，例如 <tt>"Sun"</tt> 和 <tt>"Mon"</tt>

<tr><td valign="top"><tt>'C'</tt>
    <td> 除以 <tt>100</tt> 的四位数表示的年份，被格式化为必要时带前导零的两位数，即 <tt>00 - 99</tt>

<tr><td valign="top"><tt>'Y'</tt>
    <td> 年份，被格式化为必要时带前导零的四位数（至少），例如，<tt>0092</tt> 等于格里高利历的 <tt>92</tt> CE。

<tr><td valign="top"><tt>'y'</tt>
    <td> 年份的最后两位数，被格式化为必要时带前导零的两位数，即 <tt>00 - 99</tt>。

<tr><td valign="top"><tt>'j'</tt>
    <td> 一年中的天数，被格式化为必要时带前导零的三位数，例如，对于格里高利历是 <tt>001 - 366</tt>。

<tr><td valign="top"><tt>'m'</tt>
    <td> 月份，被格式化为必要时带前导零的两位数，即 <tt>01 - 13</tt>。

<tr><td valign="top"><tt>'d'</tt>
    <td> 一个月中的天数，被格式化为必要时带前导零两位数，即 <tt>01 - 31</tt>

<tr><td valign="top"><tt>'e'</tt>
    <td> 一个月中的天数，被格式化为两位数，即 <tt>1 - 31</tt>。

 </table>

<p> 以下转换字符用于格式化常见的日期/时间组合。

 <table cellpadding=5 summary="composites">

<tr><td valign="top"><tt>'R'</tt>
    <td> 24 小时制的时间，被格式化为 <tt>&quot;%tH:%tM&quot;</tt>

<tr><td valign="top"><tt>'T'</tt>
    <td> 24 小时制的时间，被格式化为 <tt>&quot;%tH:%tM:%tS&quot;</tt>。

<tr><td valign="top"><tt>'r'</tt>
    <td> 12 小时制的时间，被格式化为 <tt>&quot;%tI:%tM:%tS %Tp&quot;</tt>。上午或下午标记 (<tt>'%Tp'</tt>) 的位置可能与语言环境有关。

<tr><td valign="top"><tt>'D'</tt>
    <td> 日期，被格式化为 <tt>&quot;%tm/%td/%ty&quot;</tt>。

<tr><td valign="top"><tt>'F'</tt>
    <td> <a href="http://www.w3.org/TR/NOTE-datetime">ISO&nbsp;8601</a> 格式的完整日期，被格式化为 <tt>&quot;%tY-%tm-%td&quot;</tt>。

<tr><td valign="top"><tt>'c'</tt>
    <td> 日期和时间，被格式化为 <tt>&quot;%ta %tb %td %tT %tZ %tY&quot;</tt>，例如 <tt>&quot;Sun Jul 20 16:17:00 EDT 1969&quot;</tt>。

</table>

<p> 任何未明确定义为转换的字符都是非法字符，并且都被保留，以供将来扩展使用。

<h4> 标志</h4>

<p> 下表总结了受支持的标志。<i>y</i> 表示该标志受指示参数类型支持。

 <table cellpadding=5 summary="genConv">

<tr><th valign="bottom"> 标志<th valign="bottom"> 常规
    <th valign="bottom"> 字符<th valign="bottom"> 整数
    <th valign="bottom"> 浮点
    <th valign="bottom"> 日期/时间
    <th valign="bottom"> 说明

 <tr><td> '-' <td align="center" valign="top"> y
     <td align="center" valign="top"> y
     <td align="center" valign="top"> y
     <td align="center" valign="top"> y
     <td align="center" valign="top"> y
<td> 结果将是左对齐的。

 <tr><td> '#' <td align="center" valign="top"> y<sup>1</sup>
     <td align="center" valign="top"> -
     <td align="center" valign="top"> y<sup>3</sup>
     <td align="center" valign="top"> y
     <td align="center" valign="top"> -
     <td> 结果应该使用依赖于转换类型的替换形式

 <tr><td> '+' <td align="center" valign="top"> -
     <td align="center" valign="top"> -
     <td align="center" valign="top"> y<sup>4</sup>
     <td align="center" valign="top"> y
     <td align="center" valign="top"> -
     <td> 结果总是包括一个符号

 <tr><td> '&nbsp;&nbsp;' <td align="center" valign="top"> -
     <td align="center" valign="top"> -
     <td align="center" valign="top"> y<sup>4</sup>
     <td align="center" valign="top"> y
     <td align="center" valign="top"> -
     <td> 对于正值，结果中将包括一个前导空格

 <tr><td> '0' <td align="center" valign="top"> -
     <td align="center" valign="top"> -
     <td align="center" valign="top"> y
     <td align="center" valign="top"> y
     <td align="center" valign="top"> -
     <td> 结果将用零来填充

 <tr><td> ',' <td align="center" valign="top"> -
     <td align="center" valign="top"> -
     <td align="center" valign="top"> y<sup>2</sup>
     <td align="center" valign="top"> y<sup>5</sup>
     <td align="center" valign="top"> -
     <td> 结果将包括特定于语言环境的{@linkplain java.text.DecimalFormatSymbols#getGroupingSeparator 组分隔符}

 <tr><td> '(' <td align="center" valign="top"> -
     <td align="center" valign="top"> -
     <td align="center" valign="top"> y<sup>4</sup>
     <td align="center" valign="top"> y<sup>5</sup>
     <td align="center"> -
     <td> 结果将是用圆括号括起来的负数

</table>

<p> <sup>1</sup> 取决于 {@link Formattable} 的定义。

<p> <sup>2</sup> 只适用于 <tt>'d'</tt> 转换。

<p> <sup>3</sup> 只适用于 <tt>'o'</tt>、<tt>'x'</tt> 和 <tt>'X'</tt> 转换。

<p> <sup>4</sup> 对 {@link java.math.BigInteger BigInteger} 应用 <tt>'d'</tt>、<tt>'o'</tt>、<tt>'x'</tt> 和 <tt>'X'</tt> 转换时，或者对 <tt>byte</tt> 及 {@link Byte}、<tt>short</tt> 及 {@link Short}、<tt>int</tt> 及 {@link Integer}、<tt>long</tt> 及 {@link Long} 分别应用 <tt>'d'</tt> 转换时适用。

<p> <sup>5</sup> 只适用于 <tt>'e'</tt>、<tt>'E'</tt>、<tt>'f'</tt>、<tt>'g'</tt> 和 <tt>'G'</tt> 转换。

<p> 任何未显式定义为标志的字符都是非法字符，并且都被保留，以供扩展使用。

<h4> 宽度 </h4>

<p> 宽度是将向输出中写入的最少字符数。对于行分隔符转换，不适用宽度，如果提供宽度，则会抛出异常。

<h4> 精度 </h4>

<p> 对于常规参数类型，精度是将向输出中写入的最多字符数。

<p> 对于浮点转换 <tt>'e'</tt>、<tt>'E'</tt> 和 <tt>'f'</tt>，精度是小数点分隔符后的位数。如果转换是 <tt>'g'</tt> 或 <tt>'G'</tt>，那么精度是舍入计算后所得数值的所有位数。如果转换是 <tt>'a'</tt> 或 <tt>'A'</tt>，则不必指定精度。

<p> 对于字符、整数和日期/时间参数类型转换，以及百分比和行分隔符转换，精度是不适用的；如果提供精度，则会抛出异常。

<h4> 参数索引 </h4>

<p> 参数索引是一个十进制整数，用于表明参数在参数列表中的位置。第一个参数由 &quot;<tt>1$</tt>&quot; 引用，第二个参数由 &quot;<tt>2$</tt>&quot; 引用，依此类推。

<p> 根据位置引用参数的另一种方法是使用 <tt>'&lt;'</tt> (<tt>'\u003c'</tt>) 标志，这将会重用以前格式说明符的参数。例如，以下两条语句产生的字符相同：

 <blockquote><pre>
   Calendar c = ...;
   String s1 = String.format("Duke's Birthday: %1$tm %1$te,%1$tY", c);

   String s2 = String.format("Duke's Birthday: %1$tm %&lt;te,%&lt;tY", c);
 </pre></blockquote>

 <hr>
 <h3><a name="detail"> 详细信息 </a></h3>

<p> 这一部分将提供格式化行为规范方面的细节，其中包括条件和异常、受支持的数据类型、本地化以及标志、转换和数据类型之间的交互。有关格式化概念的概述，请参阅<a href="#summary">摘要</a>。

<p>任何未明确定义为转换、日期/时间转换前缀或标志的字符都是非法字符，并且这些字符都被保留，以供未来扩展使用。在格式字符串中使用这样的字符会导致抛出 {@link UnknownFormatConversionException} 或 {@link UnknownFormatFlagsException}。

<p> 如果格式说明符包含带有无效值或不受支持的其他值的宽度或精度，则将分别抛出 {@link IllegalFormatWidthException} 或 {@link IllegalFormatPrecisionException}。

<p> 如果格式说明符包含不适用于对应参数的转换字符，则将抛出 {@link IllegalFormatConversionException}。

<p> 所有指定异常都可能被 <tt>Formatter</tt> 的任何 <tt>format</tt> 方法以及任何 <tt>format</tt> 的便捷方法抛出，比如 {@link String#format(String,Object...)String.format} 和 {@link java.io.PrintStream#printf(String,Object...)PrintStream.printf}。 String.format} and {@link java.io.PrintStream#printf(String,Object...) PrintStream.printf}.

<p> 由大写字符（如 <tt>'B'</tt>、<tt>'H'</tt>、<tt>'S'</tt>、<tt>'C'</tt>、<tt>'X'</tt>、<tt>'E'</tt>、<tt>'G'</tt>、<tt>'A'</tt> 和 <tt>'T'</tt>）表示的转换与那些相应的小写字符表示的转换相同，根据流行的 {@link java.util.Locale Locale} 规则将结果转换成大写形式除外。结果等同于 {@link String#toUpperCase()} 的以下调用

 <pre>
    out.toUpperCase() </pre>

 <h4><a name="dgen"> 常规 </a></h4>

<p> 以下常规转换可应用于任何参数类型：

 <table cellpadding=5 summary="dgConv">

 <tr><td valign="top"> <tt>'b'</tt>
     <td valign="top"> <tt>'\u0062'</tt>
     <td> 将生成 &quot;<tt>true</tt>&quot; 或 &quot;<tt>false</tt>&quot;，由 {@link Boolean#toString(boolean)} 返回。

<p> 如果参数为 <tt>null</tt>，则结果为 &quot;<tt>false</tt>&quot;。如果参数是一个 <tt>boolean</tt> 值或 {@link Boolean}，那么结果是由 {@link String#valueOf(boolean) String.valueOf()} 返回的字符串。否则结果为 &quot;<tt>true</tt>&quot;。

<p> 如果给出 <tt>'#'</tt> 标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

 <tr><td valign="top"> <tt>'B'</tt>
     <td valign="top"> <tt>'\u0042'</tt>
     <td> <tt>'b'</tt> 的大写形式。

 <tr><td valign="top"> <tt>'h'</tt>
     <td valign="top"> <tt>'\u0068'</tt>
     <td> 生成一个表示对象的哈希码值的字符串。

<p> 如果参数 <i>arg</i> 为 <tt>null</tt>，则结果为 &quot;<tt>null</tt>&quot;。否则，结果为调用 <tt>Integer.toHexString(arg.hashCode())</tt> 得到的结果。

<p> 如果给出 <tt>'#'</tt> 标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

 <tr><td valign="top"> <tt>'H'</tt>
     <td valign="top"> <tt>'\u0048'</tt>
     <td> <tt>'h'</tt> 的大写形式。

 <tr><td valign="top"> <tt>'s'</tt>
     <td valign="top"> <tt>'\u0073'</tt>
     <td> 生成一个字符串。

<p> 如果参数为 <tt>null</tt>，则结果为 &quot;<tt>null</tt>&quot;。如果参数实现了 {@link Formattable}，则调用其 {@link Formattable#formatTo formatTo} 方法。否则，结果为调用参数的 <tt>toString()</tt> 方法得到的结果。

<p> 如果给出 <tt>'#'</tt> 标志，且参数不是 {@link Formattable}，则将抛出 {@link FormatFlagsConversionMismatchException}。

<tr><td valign="top"> <tt>'S'</tt>
     <td valign="top"> <tt>'\u0053'</tt>
     <td> <tt>'s'</tt> 的大写形式。

</table>

<p> 以下 <a name="dFlags"> 标志 </a> 应用于常规转换：

 <table cellpadding=5 summary="dFlags">

 <tr><td valign="top"> <tt>'-'</tt>
     <td valign="top"> <tt>'\u002d'</tt>
<td> 将输出左对齐。根据需要在转换值结尾处添加空格 (<tt>'\u0020'</tt>)，以满足字段的最小宽度要求。如果没有提供宽度，则将抛出 {@link MissingFormatWidthException}。如果没有给出此标志，则输出将是右对齐的。

 <tr><td valign="top"> <tt>'#'</tt>
     <td valign="top"> <tt>'\u0023'</tt>
     <td> 要求输出使用替换形式。此形式的定义通过转换指定。

</table>


<p> <a name="genWidth"> 宽度 </a> 是将向输出中写入的最少字符数。如果转换值的长度小于宽度，则用 <tt>'&nbsp;&nbsp;'</tt> (<tt>&#92;u0020'</tt>) 填充输出，直到字符总数等于宽度为止。默认情况下，是在左边进行填充。如果给出 <tt>'-'</tt> 标志，则在右边进行填充。如果没有指定宽度，则没有最小宽度。

<p> 精度是将向输出中写入的最多字符数。精度的应用要先于宽度，因此，即使宽度大于精度，输出也将被截取为 <tt>precision</tt> 字符。如果没有指定精度，则对字符数没有明确限制。

 <h4><a name="dchar"> 字符 </a></h4>

此转换可应用于 <tt>char</tt> 和 {@link Character}。它还可应用于类型 <tt>byte</tt>、{@link Byte}、<tt>short</tt> 和 {@link Short}、 <tt>int</tt> 和 {@link Integer}。当 {@link Character#isValidCodePoint} 返回 <tt>true</tt> 时，此转换也可应用于 <tt>int</tt> 和 {@link Integer}。如果返回 <tt>false</tt>，则将抛出 {@link IllegalFormatCodePointException}。

<table cellpadding=5 summary="charConv">

<tr><td valign="top"> <tt>'c'</tt>
    <td valign="top"> <tt>'\u0063'</tt>
    <td> 将参数格式化为 <a href="../lang/Character.html#unicode">Unicode Character Representation</a> 中描述的 Unicode 字符。在该参数表示增补字符的情况下，它可能是多个 16 位 <tt>char</tt>。

<p> 如果给出 <tt>'#'</tt> 标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

<tr><td valign="top"> <tt>'C'</tt>
    <td valign="top"> <tt>'\u0043'</tt>
    <td> <tt>'c'</tt> 的大写形式。

</table>

<p> <tt>'-'</tt> 标志是为应用<a href="#dFlags">常规转换</a>而定义的。如果给出 <tt>'#'</tt> 标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

<p> 宽度是为了实现<a href="#genWidth">常规转换</a>而定义的。

<p> 精度不适用。如果指定精度，则将抛出 {@link IllegalFormatPrecisionException}。

 <h4><a name="dnum"> 数值 </a></h4>

<p> 数值转换分为以下几类：

<ol>

<li> <a href="#dnint"><b>Byte、Short、Integer 和 Long</b></a>

<li> <a href="#dnbint"><b>BigInteger</b></a>

<li> <a href="#dndec"><b>Float 和 Double</b></a>

<li> <a href="#dndec"><b>BigDecimal</b></a>

</ol>

<p> 将根据以下算法对数值类型进行格式化：

<p><b><a name="l10n algorithm">数字本地化算法</a></b>

<p> 在获得数字的整数部分、小数部分和指数（适用于数据类型）之后，将应用以下转换：

<ol>

<li> 将字符串中的每个数字字符 <i>d</i> 都替换为特定于语言环境的数字，该数字是相对于当前语言环境的{@linkplain java.text.DecimalFormatSymbols#getZeroDigit() 零数字} <i>z</i> 来计算的；即 <i>d&nbsp;-&nbsp;</i> <tt>'0'</tt> <i>&nbsp;+&nbsp;z</i>。

<li> 如果存在小数点分隔符，则用特定于语言环境的{@linkplain java.text.DecimalFormatSymbols#getDecimalSeparator 小数点分隔符}替换。

<li> 如果给出 <tt>','</tt> (<tt>'\u002c'</tt>) <a name="l10n group">flag</a>  标志，则插入特定于语言环境的{@linkplain java.text.DecimalFormatSymbols#getGroupingSeparator 组分隔符}，这是通过从最低位到最高位浏览字符串的整数部分并不时插入该语言环境{@linkplain java.text.DecimalFormat#getGroupingSize() 组大小}定义的分隔符来实现的。

<li> 如果给出 <tt>'0'</tt> 标志，则在符号字符（如果有的话）之后、第一个非零数字前插入特定于语言环境的{@linkplain java.text.DecimalFormatSymbols#getZeroDigit() 零数字}，直到字符串长度等于所要求的字段宽度。

<li> 如果该值为负，并且给出了 <tt>'('</tt> 标志，那么预先考虑 <tt>'('</tt> (<tt>'\u0028'</tt>)，并追加一个 <tt>')'</tt> (<tt>'\u0029'</tt>)。

<li> 如果该值为负（或者为浮点负零），并且没有给出 <tt>'('</tt> 标志，那么预先考虑 <tt>'-'</tt> (<tt>'\u002d'</tt>)。

<li> 如果给出 <tt>'+'</tt> 标志，并且该值为正或零（或者为浮点正零），那么将预先考虑 <tt>'+'</tt> (<tt>'\u002b'</tt>)。

 </ol>

<p> 如果该值为 NaN 或正无穷大，则分别输出文本字符串 &quot;NaN&quot; 或 &quot;Infinity&quot;。如果该值为负无穷大，那么输出将是 &quot;(Infinity)&quot;；否则如果给出 <tt>'('</tt> 标志，那么输出将是 &quot;-Infinity&quot;。这些值都没有被本地化。

<p><a name="dnint"><b> Byte、Short、Integer 和 Long </b></a>

<p> 以下转换可应用于 <tt>byte</tt>、{@link Byte}、<tt>short</tt>、{@link Short}、<tt>int</tt>、{@link Integer}、<tt>long</tt> 和 {@link Long}。

<table cellpadding=5 summary="IntConv">

<tr><td valign="top"> <tt>'d'</tt>
    <td valign="top"> <tt>'\u0054'</tt>
    <td> 将参数格式化为十进制整数。应用<a href="#l10n algorithm">本地化算法</a>。

<p> 如果给出 <tt>'0'</tt> 标志，并且值为负，则在符号后填充零。

<p> 如果给出 <tt>'#'</tt> 标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

<tr><td valign="top"> <tt>'o'</tt>
    <td valign="top"> <tt>'\u006f'</tt>
    <td> 将参数格式化为以 8 为基数的整数。不应用本地化。

<p> 如果 <i>x</i> 为负，那么结果将是通过将 2<sup>n</sup> 添加到值中产生的一个无符号值，其中 <tt>n</tt> 是在适当时候由类 {@linkplain Byte#SIZE Byte}、{@linkplain Short#SIZE Short}、{@linkplain Integer#SIZE Integer} 或 {@linkplain Long#SIZE Long} 中的静态 <tt>SIZE</tt> 字段返回的类型中的位数。

<p> 如果给出 <tt>'#'</tt> 标志，则输出将始终以基数指示符 <tt>'0'</tt> 开始。

<p> 如果给出 <tt>'0'</tt> 标志，则使用前导零填充输出，这些零被填充到以下任意指示符号后面的字段宽度中。

<p> 如果给出 <tt>'('</tt>、<tt>'+'</tt>、'&nbsp;&nbsp;' 或 <tt>'、'</tt> 标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

<tr><td valign="top"> <tt>'x'</tt>
    <td valign="top"> <tt>'\u0078'</tt>
    <td> 将参数格式化为以 16 为基数的整数。不应用本地化。

<p> 如果 <i>x</i> 为负，那么结果将为把 2<sup>n</sup> 添加到值中产生的一个无符号值，其中 <tt>n</tt> 是在适当时候，由类 {@linkplain Byte#SIZE Byte}、{@linkplain Short#SIZE Short}、{@linkplain Integer#SIZE Integer} 或 {@linkplain Long#SIZE Long} 中的静态 <tt>SIZE</tt> 字段返回的类型中的位数。

<p> 如果给出 <tt>'#'</tt> 标志，则输出将始终以基数指示符 <tt>'0x'</tt> 开始。

<p> 如果给出 <tt>'0'</tt> 标志，则使用前导零填充输出，这些零被填充到基数指示符或符号（如果存在）后面的字段宽度中。

<p> 如果给出 <tt>'('</tt>、<tt>'&nbsp;&nbsp;'</tt>、<tt>'+'</tt> 或 <tt>'、'</tt> 标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

<tr><td valign="top"> <tt>'X'</tt>
    <td valign="top"> <tt>'\u0058'</tt>
    <td> <tt>'x'</tt> 的大写形式。将表示数字的整个字符串转换为{@linkplain String#toUpperCase 大写}，其中包括 <tt>'x'</tt> （如果有的话） 和所有十六进制数字 <tt>'a'</tt> - <tt>'f'</tt> (<tt>'\u0061'</tt> -  <tt>'\u0066'</tt>)。

</table>

<p> 如果该转换是 <tt>'o'</tt>、<tt>'x'</tt> 或 <tt>'X'</tt> 转换，并且给出了 <tt>'#'</tt> 和 <tt>'0'</tt> 标志，那么结果将包含基数指示符（对于八进制是 <tt>'0'</tt>，对于十六进制是 <tt>'0'</tt> 或 <tt>"0x"</tt>）、一定数量的零（基于宽度）和该值。

<p> 如果没有给出 <tt>'-'</tt> 标志，则在符号前填充空格。

<p> 以下 <a name="intFlags"> 标志 </a> 应用于数值整数转换：

 <table cellpadding=5 summary="intFlags">

<tr><td valign="top"> <tt>'+'</tt>
    <td valign="top"> <tt>'\u002b'</tt>
    <td> 要求所有正数的输出都包含一个正号。如果没有给出此标志，则只有负值包含符号。

<p> 如果同时给出了 <tt>'+'</tt> 和 <tt>'&nbsp;&nbsp;'</tt> 标志，则将抛出 {@link IllegalFormatFlagsException}。

<tr><td valign="top"> <tt>'&nbsp;&nbsp;'</tt>
    <td valign="top"> <tt>'\u0020'</tt>
    <td> 对于非负值的输出，要求包括单个额外空格 (<tt>'\u0020'</tt>)。

<p> 如果同时给出了 <tt>'+'</tt> 和 <tt>'&nbsp;&nbsp;'</tt> 标志，则将抛出 {@link IllegalFormatFlagsException}。

<tr><td valign="top"> <tt>'0'</tt>
    <td valign="top"> <tt>'\u0030'</tt>
    <td> 要求将前导{@linkplain java.text.DecimalFormatSymbols#getZeroDigit 零}填充到输出中，这些零被填充到以下任意符号或基数指示符之后，以达到最小字段宽度，转换 NaN 或无穷大时除外。如果没有提供宽度，则将抛出 {@link MissingFormatWidthException}。

<p> 如果同时给出 <tt>'-'</tt> 和 <tt>'0'</tt> 标志，则将抛出 {@link IllegalFormatFlagsException}。

<tr><td valign="top"> <tt>','</tt>
    <td valign="top"> <tt>'\u002c'</tt>
    <td> 要求输出包括在本地化算法的<a href="#l10n group">“群”一节</a>中描述的特定于语言环境的{@linkplain java.text.DecimalFormatSymbols#getGroupingSeparator 组分隔符}。

<tr><td valign="top"> <tt>'('</tt>
    <td valign="top"> <tt>'\u0028'</tt>
    <td> 要求输出预先考虑 <tt>'('</tt> (<tt>'\u0028'</tt>)，并将 <tt>')'</tt> (<tt>'\u0029'</tt>) 追加到负值中。

</table>

<p>如果没有给出 <a name="intdFlags"> 标志 </a>，则默认格式设置如下：

<ul>

<li> <tt>width</tt> 中的输出是右对齐的

<li> 负数以 <tt>'-'</tt> (<tt>'\u002d'</tt>) 开始

<li> 正数和零不包括符号或额外的前导空格

<li> 不包括组分隔符

</ul>

 <p> The <a name="intWidth"> 宽度 </a> 是将向输出中写入的最少字符数。这包括所有符号、数字、组分隔符、基数指示符和圆括号。如果转换值的长度小于宽度，则用空格(<tt>'&#92;u0020'</tt>) 填充输出，直到字符总数等于宽度。默认情况下，在左边进行填补。如果给出 <tt>'-'</tt> 标志，则在右边进行填补。如果没有指定宽度，则没有最小宽度。

<p> 精度不适用。如果指定精度，则将抛出 {@link IllegalFormatPrecisionException}。

 <p><a name="dnbint"><b> BigInteger </b></a>

<p> 以下转换可应用于 {@link java.math.BigInteger}。

<table cellpadding=5 summary="BIntConv">

<tr><td valign="top"> <tt>'d'</tt>
    <td valign="top"> <tt>'\u0054'</tt>
    <td> 要求将输出格式化为十进制整数。应用<a href="#l10n algorithm">本地化算法</a>。

<p> 如果给出 <tt>'#'</tt> 标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

<tr><td valign="top"> <tt>'o'</tt>
    <td valign="top"> <tt>'\u006f'</tt>
    <td> 要求将输出格式化为以 8 为基数的整数。不应用本地化。

<p> 如果 <i>x</i> 为负，那么结果将是以 <tt>'-'</tt> (<tt>'&#92;u002d'</tt>) 开始的有符号值。允许对这种类型使用有符号输出，因为它不同于基本类型，在没有假定显式数据类型大小的情况下，不可能创建无符号的等效值。

<p> 如果 <i>x</i> 为正数或零，且给出了 <tt>'+'</tt> 标志，那么结果是以 <tt>'+'</tt> (<tt>'\u002b'</tt>) 开始的。

<p> 如果给出 <tt>'#'</tt> 标志，那么输出将始终以 <tt>'0'</tt> 前缀开始。

<p> 如果给出 <tt>'0'</tt> 标志，那么将使用前导零填充输出，这些零被填充到指示符后的字段宽度中。

<p> 如果给出 <tt>','</tt> 标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

<tr><td valign="top"> <tt>'x'</tt>
     <td valign="top"> <tt>'\u0078'</tt>
     <td> 要求将输出格式化为以 16 为基数的整数。不应用本地化。

<p> 如果 <i>x</i> 为负，那么结果是以 <tt>'-'</tt> (<tt>'_apos;</tt>) 开始的有符号值。此类型允许使用有符号输出，因为与基本类型不同，如果不假定明确的数据类型大小，则不可能创建无符号的等效数。

<p> 如果 <i>x</i> 为正数或零，且给出了 <tt>'+'</tt> 标志，那么结果以 <tt>'+'</tt> (<tt>'\u002b'</tt>) 开始。

<p> 如果给出 <tt>'#'</tt> 标志，那么输出将始终以基数指示符 <tt>'0x'</tt> 开始。

<p> 如果给出 <tt>'0'</tt> 标志，那么将使用前导零填充输出，这些零被填充到基数指示符或符号（如果存在）后面的字段宽度中。

<p> 如果给出 <tt>','</tt> 标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

<tr><td valign="top"> <tt>'X'</tt>
     <td valign="top"> <tt>'\u0058'</tt>
     <td> <tt>'x'</tt> 的大写形式。将表示数字的整个字符串转换为{@linkplain String#toUpperCase 大写}，其中包括 <tt>'x'</tt>（如果有的话）和所有十六进制数字 <tt>'a'</tt> - <tt>'f'</tt> (<tt>'\u0061'</tt> -  <tt>'\u0066'</tt>)。

</table>

<p> 如果该转换是 <tt>'o'</tt>、<tt>'x'</tt> 或 <tt>'X'</tt>，并且给出了 <tt>'#'</tt> 和 <tt>'0'</tt> 标志，那么结果将包含基数指示符（对于八进制是 <tt>'0'</tt>，对于十六进制是 <tt>'0'</tt> 或 <tt>"0x"</tt>）、一定数量的零（基于宽度）和该值。

<p> 如果给出 <tt>'0'</tt> 标志，并且值为负，则在符号后填充零。

<p> 如果没有给出 <tt>'-'</tt> 标志，则在符号前填充空格。

<p> 应用为 Byte、Short、Integer 和 Long 定义的所有<a href="#intFlags">标志</a>。没有给出标志时的<a href="#intdFlags">默认行为</a>与 Byte、Short、Integer 和 Long 的行为相同。

<p> <a href="#intWidth">宽度</a>的规范与为 Byte、Short、Integer 和 Long 定义的规范相同。

<p> 精度不适用。如果指定精度，则将抛出 {@link IllegalFormatPrecisionException}。

<p><a name="dndec"><b> Float 和 Double</b></a>

<p> 以下转换可应用于 <tt>float</tt>、{@link Float}、<tt>double</tt> 和 {@link Double}。

<table cellpadding=5 summary="floatConv">

<tr><td valign="top"> <tt>'e'</tt>
    <td valign="top"> <tt>'\u0065'</tt>
    <td> 要求使用<a name="scientific">科学记数法</a>来格式化输出。应用<a href="#l10n algorithm">本地化算法</a>。

<p> 数值 <i>m</i> 的格式取决它的值。

<p> 如果 <i>m</i> 是 NaN 或无穷大，则分别输出文本字符串 &quot;NaN&quot; 或 &quot;Infinity&quot;。这些值都没有被本地化。

<p> 如果 <i>m</i> 是正零或负零，则指数将是 <tt>&quot;+00&quot;</tt>。

<p> 否则，结果是表示变量的符号和大小（绝对值）的字符串。符号的格式在<a href="#l10n algorithm">本地化算法</a>中已经描述。数值 <i>m</i> 的格式取决它的值。

<p> 让 <i>n</i> 成为满足 10<sup><i>n</i></sup> &lt;= <i>m</i> &lt; 10<sup><i>n</i>+1</sup> 的唯一整数；让 <i>a</i> 成为 <i>m</i> 和 10<sup><i>n</i></sup> 的精确算术商数值，且满足 1 &lt;= <i>a</i> &lt; 10。然后将该数值解释为 <i>a</i> 的整数部分，因为是一个小数位数，所以后面跟着小数点分隔符，再后面是表示 <i>a</i> 的小数部分的小数位数，后跟指数符号 <tt>'e'</tt> (<tt>'\u0065'</tt>)，这之后是指数符号，后跟十进制整数形式表示的 <i>n</i>，它由方法 {@link Long#toString(long, int)} 产生，并用零填充，使其至少包括两个位数。

<p> 在结果中，<i>m</i> 或 <i>a</i> 的小数部分的位数等于精度。如果没有指定精度，则默认值为 <tt>6</tt>。如果精度小于将出现在分别由 {@link Float#toString(float)} 或 {@link Double#toString(double)} 返回的字符串中的小数点之后的位数，则使用{@linkplain java.math.BigDecimal#ROUND_HALF_UP 四舍五入算法}对该值进行舍入运算。否则，可能通过追加零来达到所需精度。要获得该值的规范表示形式，请在适当时候使用 {@link Float#toString(float)} 或 {@link Double#toString(double)}。

<p>如果给出 <tt>','</tt> 标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

<tr><td valign="top"> <tt>'E'</tt>
    <td valign="top"> <tt>'\u0045'</tt>
    <td> <tt>'e'</tt> 的大写形式。指数符号将是 <tt>'E'</tt> (<tt>'\u0045'</tt>)。

<tr><td valign="top"> <tt>'g'</tt>
    <td valign="top"> <tt>'\u0067'</tt>
    <td> 要求将输出格式化为下面描述的常规科学记数形式。应用<a href="#l10n algorithm">本地化算法</a>。

<p> 在对精度进行舍入运算后，所得数值 <i>m</i> 的格式取决于它的值。

<p> 如果 <i>m</i> 大于等于 10<sup>-4</sup> 但小于 10<sup>精度</sup>，则以<i><a href="#decimal">十进制形式</a></i> 表示它。

<p> 如果 <i>m</i> 小于 10<sup>-4</sup> 或者大于等于 10<sup>精度</sup>，则以<i><a href="#scientific">计算机科学记数法</a></i> 表示它。

<p> <i>m</i> 中的总有效位数等于其精度。如果没有指定精度，则其默认值为 <tt>6</tt>。如果精度为 <tt>0</tt>，则该值将为 <tt>1</tt>。

<p> 如果给出 <tt>'#'</tt> 标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

<tr><td valign="top"> <tt>'G'</tt>
    <td valign="top"> <tt>'\u0047'</tt>
    <td> <tt>'g'</tt> 的大写形式。

<tr><td valign="top"> <tt>'f'</tt>
    <td valign="top"> <tt>'\u0066'</tt>
    <td> 要求使用<a name="decimal">十进制形式</a>来格式化输出。使用<a href="#l10n algorithm">本地化算法</a>。

<p> 结果是表示参数的符号和大小（绝对值）的字符串。符号的格式在<a href="#l10n algorithm">本地化算法</a>中已经描述。数值 <i>m</i> 的格式取决它的值。

<p> 如果 <i>m</i> 是 NaN 或无穷大，则将分别输出文本字符串 &quot;NaN&quot; 或 &quot;Infinity&quot;。这些值都没有被本地化。

<p> 将数值格式化为 <i>m</i> 的整数部分（不带前导零），后跟小数点分隔符，再后面是表示 <i>m</i> 的小数部分的一个或多个十进制数字。

<p> 在结果中，<i>m</i> 或 <i>a</i> 的小数部分的位数等于精度。如果没有指定精度，则默认值为 <tt>6</tt>。如果该精度小于将要出现在分别由 {@link Float#toString(float)} 或 {@link Double#toString(double)} 返回的字符串中的小数点之后的位数，则使用{@linkplain java.math.BigDecimal#ROUND_HALF_UP 四舍五入算法}对该值进行舍入运算。否则，可能通过追加零来达到所需精度。要获得该值的规范表示形式，请在适当时候使用 {@link Float#toString(float)} 或 {@link Double#toString(double)}。

<tr><td valign="top"> <tt>'a'</tt>
    <td valign="top"> <tt>'\u0061'</tt>
    <td> 要求将输出格式化为十六进制指数形式。不应用本地化。

<p> 结果是表示参数 <i>x</i> 的符号和大小（绝对值）的字符串。

<p> 如果 <i>x</i> 为负值或负零值，那么结果将以 <tt>'-'</tt> (<tt>'\u002d'</tt>) 开始。

<p> 如果 <i>x</i> 为正值或正零值，且给出了 <tt>'+'</tt> 标志，那么结果将以 <tt>'+'</tt> (<tt>'\u002b'</tt>) 开始。

<p> 数值 <i>m</i> 的格式取决它的值。

<ul>

<li> 如果该值是 NaN 或无穷大，则将分别输出文本字符串 &quot;NaN&quot; 或 &quot;Infinity&quot;。

<li> 如果 <i>m</i> 等于零，则用字符串 <tt>&quot;0x0.0p0&quot;</tt> 表示它。

<li> 如果 <i>m</i> 是具有标准化表现形式的 <tt>double</tt> 值，则用子字符串来表示有效位数和指数字段。有效位数是用字符串 <tt>&quot;0x1.&quot;</tt> 表示的，后跟该有效位数小数部分的十六进制表示形式。指数用 <tt>'p'</tt> (<tt>'\u0070'</tt>) 表示，后跟无偏指数的十进制字符串，该值是对指数值调用 {@link Integer#toString(int) Integer.toString} 所产生的。

<li> 如果 <i>m</i> 是具有低正常表现形式的 <tt>double</tt> 值，则用字符 <tt>&quot;0x0.&quot;</tt> 表示有效位数，后跟该有效位数小数部分的十六进制表示。用 <tt>'p-1022'</tt> 表示指数。注意，在低正常有效位数中，至少必须有一个非零数字。

</ul>

<p> 如果给出 <tt>'('</tt> 或 <tt>','</tt> 标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

<tr><td valign="top"> <tt>'A'</tt>
    <td valign="top"> <tt>'\u0041'</tt>
    <td> <tt>'a'</tt> 的大写形式。表示数字的整个字符串将被转换为大写形式，其中包括 <tt>'x'</tt> (<tt>'\u0078'</tt>) 和 <tt>'p'</tt> (<tt>'\u0070'</tt> 以及所有的十六进制数字 <tt>'a'</tt> - <tt>'f'</tt> (<tt>'\u0061'</tt> - <tt>'\u0066'</tt>)。

</table>

<p> 应用为 Byte、Short、Integer 和 Long 定义的所有<a href="#intFlags">标志</a>。

<p> 如果给出 <tt>'#'</tt> 标志，则将始终存在小数点分隔符。

<p>如果没有给出 <a name="floatdFlags"> 标志 </a> 则默认格式设置如下：

<ul>

<li> <tt>width</tt> 中的输出是右对齐的。

<li> 负数以 <tt>'-'</tt> 开头

<li> 正数和正零不包括符号或额外的前导空格

<li> 不包括组分隔符

<li> 小数点分隔符只在后面有数字时才出现

 </ul>

 <p> The <a name="floatDWidth"> 宽度 </a> 是将向输出中写入的最少字符数。这包括可应用的所有符号、数字、组分隔符、小数点分隔符、指数符号、基数指示符、圆括号和表示无穷大和 NaN 的字符串。如果转换值的长度小于宽度，则用空格(<tt>'&#92;u0020'</tt>) 填充输出，直到字符总数等于宽度。默认情况下，在左边进行填充。如果给出 <tt>'-'</tt> 标志，则在右边进行填充。如果没有指定宽度，则没有最小宽度。

<p>如果 <a name="floatDPrec"> 转换 </a> 是 <tt>'e'</tt>、<tt>'E'</tt> 或 <tt>'f'</tt>，则精度是小数点分隔符后的位数。如果没有指定精度，则假定精度为 <tt>6</tt>。

<p> 如果转换是 <tt>'g'</tt> 或 <tt>'G'</tt> 转换，那么精度就是舍入运算后所得数值的总有效位数。如果没有指定精度，则默认值为 <tt>6</tt>。如果精度为 <tt>0</tt>，则该值将为 <tt>1</tt>。

<p> 如果转换是 <tt>'a'</tt> 或 <tt>'A'</tt> 转换，则精度是小数点分隔符后十六进制数字的位数。如果没有提供精度，则将输出 {@link Double#toHexString(double)} 返回的所有数字。

<p><a name="dndec"><b> BigDecimal </b></a>

<p> 以下转换可应用于 {@link java.math.BigDecimal BigDecimal}。

<table cellpadding=5 summary="floatConv">

<tr><td valign="top"> <tt>'e'</tt>
    <td valign="top"> <tt>'\u0065'</tt>
    <td> 要求使用<a
     name="scientific">计算机科学记数法</a>对输出进行格式化。应用<a
     href="#l10n algorithm">本地化算法</a>。

<p> 数值 <i>m</i> 的格式取决于它的值。

<p> 如果 <i>m</i> 为正零或负零，则指数将为 <tt>&quot;+00&quot;</tt>。

<p> 否则，结果是表示参数的符号和大小（绝对值）的字符串。符号的格式在<a href="#l10n algorithm">本地化算法</a>中已经描述。数值 <i>m</i> 的格式取决于它的值。

<p> 让 <i>n</i> 成为满足 10<sup><i>n</i></sup> &lt;= <i>m</i> &lt; 10<sup><i>n</i>+1</sup> 的唯一整数；让 <i>a</i> 成为 <i>m</i> 和 10<sup><i>n</i></sup> 的精确算术商数值，且满足 1 &lt;= <i>a</i> &lt; 10。然后将该数值解释为 <i>a</i> 的整数部分，因为是一个小数位数，所以后面跟着小数点分隔符，再后面是表示 <i>a</i> 的小数部分的小数位数，后跟指数符号 <tt>'e'</tt> (<tt>'\u0065'</tt>)，这之后是指数符号，后跟十进制整数形式表示的 <i>n</i>，它由方法 {@link Long#toString(long, int)} 产生，并用零填充，使其至少包括两个位数。

<p> 在结果中，<i>m</i> 或 <i>a</i> 的小数部分的位数等于精度。如果没有指定精度，则默认值为 <tt>6</tt>。如果精度小于将出现在分别由 {@link Float#toString(float)} 或 {@link Double#toString(double)} 返回的字符串中的小数点之后的位数，则使用{@linkplain java.math.BigDecimal#ROUND_HALF_UP 四舍五入算法}对该值进行舍入运算。否则，可能通过追加零来达到所需精度。要获得该值的规范表示形式，请使用 {@link BigDecimal#toString()}。

<p> 如果给出 <tt>','</tt> 标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

<tr><td valign="top"> <tt>'E'</tt>
    <td valign="top"> <tt>'\u0045'</tt>
    <td> <tt>'e'</tt> 的大写形式。指数符号将是 <tt>'E'</tt> (<tt>'\u0045'</tt>)。

<tr><td valign="top"> <tt>'g'</tt>
    <td valign="top"> <tt>'\u0067'</tt>
    <td> 要求将输出格式化为下面描述的常规科学记数形式。应用<a href="#l10n algorithm">本地化算法</a>。

<p> 在对精度进行舍入运算后，所得数值 <i>m</i> 的格式取决于它的值。

<p> 如果 <i>m</i> 大于等于 10<sup>-4</sup> 但小于 10<sup>精度</sup>，则以<i><a href="#decimal">十进制形式</a></i> 表示它。

<p> 如果 <i>m</i> 小于 10<sup>-4</sup> 或者大于等于 10<sup>精度</sup>，则以<i><a href="#scientific">计算机科学记数法</a></i> 表示它。

<p> <i>m</i> 中的总的有效位数等于精度。如果没有指定精度，则默认值为 <tt>6</tt>。如果精度为 <tt>0</tt>，则该值将为 <tt>1</tt>。

<p> 如果给出 <tt>'#'</tt> 标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

 <tr><td valign="top"> <tt>'G'</tt>
     <td valign="top"> <tt>'\u0047'</tt>
<td> <tt>'g'</tt> 的大写形式。

<tr><td valign="top"> <tt>'f'</tt>
    <td valign="top"> <tt>'\u0066'</tt>
    <td> 要求使用<a name="decimal">十进制形式</a>来格式化输出。应用<a href="#l10n algorithm">本地化算法</a>。

<p> 结果是表示参数的符号和大小（绝对值）的字符串。符号的格式在<a href="#l10n algorithm">本地化算法</a>中已经描述。数值 <i>m</i> 的格式取决于它的值。

<p> 将该数值格式化为 <i>m</i> 的整数部分（不带前导零），后跟小数点分隔符，再后面是表示 <i>m</i> 的小数部分的一个或多个十进制数字。

<p> 在结果中，<i>m</i> 或 <i>a</i> 的小数部分的位数等于精度。如果没有指定精度，则默认值为 <tt>6</tt>。如果精度小于将出现在分别由 {@link Float#toString(float)} 或 {@link Double#toString(double)} 返回的字符串中的小数点之后的位数，则使用{@linkplain java.math.BigDecimal#ROUND_HALF_UP 四舍五入算法}对该值进行舍入运算。否则，可能通过追加零来达到所需精度。要获得该值的规范表示形式，请使用 {@link BigDecimal#toString()}。

</table>

<p> 应用为 Byte、Short、Integer 和 Long 定义的所有<a href="#intFlags">标志</a>。

<p> 如果给出 <tt>'#'</tt> 标志，则将始终存在小数点分隔符。

<p> 没有给出标志时的<a href="#floatdFlags">默认行为</a>与 Float 和 Double 的行为相同。

<p> <a href="#floatDWidth">宽度</a>和<a
 href="#floatDPrec">精度</a>的规范与为 Float 和 Double 定义的规范相同。

 <h4><a name="ddt"> 日期/时间 </a></h4>

<p> 此转换可应用于 <tt>long</tt>、{@link Long}、{@link Calendar} 和 {@link Date}。

<table cellpadding=5 summary="DTConv">

<tr><td valign="top"> <tt>'t'</tt>
    <td valign="top"> <tt>'\u0074'</tt>
    <td> 日期和时间转换字符的前缀。
<tr><td valign="top"> <tt>'T'</tt>
    <td valign="top"> <tt>'\u0054'</tt>
    <td> <tt>'t'</tt> 的大写形式。

</table>

<p> 以下日期和时间转换字符后缀是为 <tt>'t'</tt> 和 <tt>'T'</tt> 转换定义的。这些类型类似于但不完全等同于 GNU <tt>date</tt> 和 POSIX <tt>strftime(3c)</tt> 定义的那些类型。提供其他转换类型是为了访问特定于 Java 的功能（例如，<tt>'L'</tt> 用于秒中的毫秒）。

<p> 以下转换字符用来格式化时间：

 <table cellpadding=5 summary="time">

 <tr><td valign="top"> <tt>'H'</tt>
     <td valign="top"> <tt>'\u0048'</tt>
     <td> 24 小时制的小时，被格式化为必要时带前导零的两位数，即 <tt>00 - 23</tt>。<tt>00</tt> 对应午夜。

 <tr><td valign="top"><tt>'I'</tt>
     <td valign="top"> <tt>'\u0049'</tt>
     <td> 12 小时制的小时，被格式化为必要时带前导零的两位数，即 <tt>01 - 12</tt>。<tt>01</tt> 对应于 1 点钟（上午或下午）。

 <tr><td valign="top"><tt>'k'</tt>
     <td valign="top"> <tt>'\u006b'</tt>
     <td> 24 小时制的小时，即 <tt>0 - 23</tt>。<tt>0</tt> 对应于午夜。

 <tr><td valign="top"><tt>'l'</tt>
     <td valign="top"> <tt>'\u006c'</tt>
     <td> 12 小时制的小时，即 <tt>1 - 12</tt>。<tt>1</tt> 对应于上午或下午的一点钟。

 <tr><td valign="top"><tt>'M'</tt>
     <td valign="top"> <tt>'\u004d'</tt>
     <td> 小时中的分钟，被格式化为必要时带前导零的两位数，即 <tt>00 - 59</tt>。

 <tr><td valign="top"><tt>'S'</tt>
     <td valign="top"> <tt>'\u0053'</tt>
     <td> 分钟中的秒，被格式化为必要时带前导零的两位数，即 <tt>00 - 60</tt>（"<tt>60</tt>" 是支持闰秒所需的一个特殊值）。

 <tr><td valign="top"><tt>'L'</tt>
     <td valign="top"> <tt>'\u004c'</tt>
     <td> 秒中的毫秒，被格式化为必要时带前导零的三位数，即 <tt>000 - 999</tt>。

 <tr><td valign="top"><tt>'N'</tt>
     <td valign="top"> <tt>'\u004e'</tt>
     <td> 秒中的毫微秒，被格式化为必要时带前导零的九位数，即 <tt>000000000 - 999999999</tt>。此值的精度受底层操作系统或硬件解析的限制。

 <tr><td valign="top"><tt>'p'</tt>
     <td valign="top"> <tt>'\u0070'</tt>
     <td> 特定于语言环境的{@linkplain java.text.DateFormatSymbols#getAmPmStrings 上午或下午}标记以小写形式表示，例如 &quot;<tt>am</tt>&quot; 或 &quot;<tt>pm</tt>&quot;。使用转换前缀 <tt>'T'</tt> 可以强行将此输出转换为大写形式。（注意，<tt>'p'</tt> 产生的输出是小写的。而 GNU <tt>date</tt> 和 POSIX <tt>strftime(3c)</tt> 产生的输出是大写的。）

 <tr><td valign="top"><tt>'z'</tt>
     <td valign="top"> <tt>'\u007a'</tt>
     <td> 相对于 GMT 的 <a href="http://www.ietf.org/rfc/rfc0822.txt">RFC&nbsp;822</a> 格式的数字时区偏移量，例如 <tt>-0800</tt>。

 <tr><td valign="top"><tt>'Z'</tt>
     <td valign="top"> <tt>'\u005a'</tt>
     <td> 表示时区的缩写形式的字符串。

 <tr><td valign="top"><tt>'s'</tt>
     <td valign="top"> <tt>'\u0073'</tt>
     <td> 自协调世界时 (UTC) 1970 年 1 月 1 日 <tt>00:00:00</tt> 至现在所经过的秒数，也就是 <tt>Long.MIN_VALUE/1000</tt> 与 <tt>Long.MAX_VALUE/1000</tt> 之间的差值。

 <tr><td valign="top"><tt>'Q'</tt>
     <td valign="top"> <tt>'\u004f'</tt>
     <td> 自协调世界时 (UTC) 1970 年 1 月 1 日 <tt>00:00:00</tt> 至现在所经过的毫秒数，即 <tt>Long.MIN_VALUE</tt> 与 <tt>Long.MAX_VALUE</tt> 之间的差值。此值的精度受底层操作系统或硬件解析的限制。

 </table>

<p> 以下转换字符用来格式化日期：

 <table cellpadding=5 summary="date">

 <tr><td valign="top"><tt>'B'</tt>
     <td valign="top"> <tt>'\u0042'</tt>
     <td> 特定于语言环境的{@linkplain java.text.DateFormatSymbols#getMonths 完整月份名称}，例如 <tt>&quot;January&quot;</tt> 和 <tt>&quot;February&quot;</tt>。

 <tr><td valign="top"><tt>'b'</tt>
     <td valign="top"> <tt>'\u0062'</tt>
     <td> 特定于语言环境的{@linkplain java.text.DateFormatSymbols#getShortMonths 月份简称}，例如 <tt>&quot;Jan&quot;</tt> 和 <tt>&quot;Feb&quot;</tt>。

 <tr><td valign="top"><tt>'h'</tt>
     <td valign="top"> <tt>'\u0068'</tt>
     <td> 与 <tt>'b'</tt> 相同。

 <tr><td valign="top"><tt>'A'</tt>
     <td valign="top"> <tt>'\u0041'</tt>
     <td> 特定于语言环境的{@linkplain java.text.DateFormatSymbols#getWeekdays 星期几}的全称，例如 <tt>&quot;Sunday&quot;</tt> 和 <tt>&quot;Monday&quot;</tt>

 <tr><td valign="top"><tt>'a'</tt>
     <td valign="top"> <tt>'\u0061'</tt>
     <td> 特定于语言环境的{@linkplain java.text.DateFormatSymbols#getShortWeekdays 星期几}的简称，例如 <tt>&quot;Sun&quot;</tt> 和 <tt>&quot;Mon&quot;</tt>

 <tr><td valign="top"><tt>'C'</tt>
     <td valign="top"> <tt>'\u0043'</tt>
     <td> 除以 <tt>100</tt> 的四位数表示的年份，被格式化为必要时带前导零的两位数，即 <tt>00 - 99</tt>

 <tr><td valign="top"><tt>'Y'</tt>
     <td valign="top"> <tt>'\u0059'</tt> <td> 年份，被格式化为必要时带前导零的四位数（至少），例如 <tt>0092</tt> 等于格里高利历的 <tt>92</tt> CE。

 <tr><td valign="top"><tt>'y'</tt>
     <td valign="top"> <tt>'\u0079'</tt>
     <td> 年份的最后两位数，被格式化为必要时带前导零的两位数，即 <tt>00 - 99</tt>。

 <tr><td valign="top"><tt>'j'</tt>
     <td valign="top"> <tt>'\u006a'</tt>
     <td> 一年中的天数，被格式化为必要时带前导零的三位数，例如，对于格里高利历是 <tt>001 - 366</tt>。<tt>001</tt> 对应于一年中的第一天。

 <tr><td valign="top"><tt>'m'</tt>
     <td valign="top"> <tt>'\u006d'</tt>
     <td> 月份，被格式化为必要时带前导零的两位数，即 <tt>01 - 13</tt>，其中 &quot;<tt>01</tt>&quot; 是一年的第一个月，(&quot;<tt>13</tt>&quot; 是支持阴历所需的一个特殊值）。

 <tr><td valign="top"><tt>'d'</tt>
     <td valign="top"> <tt>'\u0064'</tt>
     <td> 一个月中的天数，被格式化为必要时带前导零的两位数，即 <tt>01 - 31</tt>，其中 &quot;<tt>01</tt>&quot; 是一个月的第一天。

 <tr><td valign="top"><tt>'e'</tt>
     <td valign="top"> <tt>'\u0065'</tt>
     <td> 一个月中的天数，被格式化为两位数，即 <tt>1 - 31</tt>，其中 &quot;<tt>1</tt>&quot; 是一个月中的第一天。

 </table>

<p> 以下转换字符用于格式化常见的日期/时间组合。

 <table cellpadding=5 summary="composites">

 <tr><td valign="top"><tt>'R'</tt>
     <td valign="top"> <tt>'\u0052'</tt>
     <td> 24 小时制的时间，被格式化为 <tt>&quot;%tH:%tM&quot;</tt>

 <tr><td valign="top"><tt>'T'</tt>
     <td valign="top"> <tt>'\u0054'</tt>
     <td> 24 小时制的时间，被格式化为 <tt>&quot;%tH:%tM:%tS&quot;</tt>。

 <tr><td valign="top"><tt>'r'</tt>
     <td valign="top"> <tt>'\u0072'</tt>
     <td> 12 小时制的时间，被格式化为 <tt>&quot;%tI:%tM:%tS %Tp&quot;</tt>。上午或下午标记 (<tt>'%Tp'</tt>) 的位置可能与地区有关。

 <tr><td valign="top"><tt>'D'</tt>
     <td valign="top"> <tt>'\u0044'</tt>
     <td> 日期，被格式化为 <tt>&quot;%tm/%td/%ty&quot;</tt>。

 <tr><td valign="top"><tt>'F'</tt>
     <td valign="top"> <tt>'\u0046'</tt>
     <td> <a href="http://www.w3.org/TR/NOTE-datetime">ISO&#xA0;8601</a> 格式的完整日期，被格式化为 <tt>&quot;%tY-%tm-%td&quot;</tt>。

 <tr><td valign="top"><tt>'c'</tt>
     <td valign="top"> <tt>'\u0063'</tt>
     <td> 日期和时间，被格式化为 <tt>&quot;%ta %tb %td %tT %tZ %tY&quot;</tt>，例如 <tt>&quot;Sun Jul 20 16:17:00 EDT 1969&quot;</tt>。

 </table>

<p> 应用为<a href="#dFlags">常规转换</a>而定义的 <tt>'-'</tt> 标志。如果给出 <tt>'#'</tt> 标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

<p> <a name="dtWidth"> 宽度 </a> 是将向输出中写入的最少字符数。如果转换值的长度小于 <tt>width</tt>，则用空格(<tt>'\u0020'</tt>) 来填充输出，直到总字符数等于宽度。默认情况下，在左边进行填充。如果给出 <tt>'-'</tt> 标志，则在右边进行填充。如果没有指定宽度，则没有最小宽度。

<p> 精度不适用。如果指定了精度，则将抛出 {@link IllegalFormatPrecisionException}。

 <h4><a name="dper"> 百分比 </a></h4>

<p> 该转换不对应于任何参数。

 <table cellpadding=5 summary="DTConv">

 <tr><td valign="top"><tt>'%'</tt>
     <td> 结果是一个字面值 <tt>'%'</tt> (<tt>'\u0025'</tt>)

<p> <a name="dtWidth"> 宽度 </a> 是将向输出中写入的最少字符数，包括 <tt>'%'</tt>。如果转换值的长度小于 <tt>width</tt>，则用空格 (<tt>'\u0020'</tt>) 来填充输出，直到总字符数等于宽度。在左边进行填充。如果没有指定宽度，则只输出 <tt>'%'</tt>。

<p> 应用为<a href="#dFlags">常规转换</a>而定义的 <tt>'-'</tt> 标志。如果提供其他任何标志，则将抛出 {@link FormatFlagsConversionMismatchException}。

<p> 精度不适用。如果指定精度，则将抛出 {@link IllegalFormatPrecisionException}。

 </table>

 <h4><a name="dls"> 行分隔符 </a></h4>

<p> 该转换不对应于任何参数。

 <table cellpadding=5 summary="DTConv">

 <tr><td valign="top"><tt>'n'</tt>
     <td> 由 {@link System#getProperty System.getProperty(&quot;line.separator&quot;)} 返回的特定于平台的行分隔符。

 </table>

<p> 标志、宽度和精度都不可用。如果提供这三者，则会分别抛出 {@link IllegalFormatFlagsException}、{@link IllegalFormatWidthException} 和 {@link IllegalFormatPrecisionException}。

 <h4><a name="dpos"> 参数索引 </a></h4>

<p> 格式说明符可以通过三种方式引用参数：

 <ul>

<li> <i>显式索引</i> 是在格式说明符中包含参数索引时使用。参数索引是一个十进制整数，用于指示参数在参数列表中的位置。第一个参数由 &quot;<tt>1$</tt>&quot; 引用，第二个参数由 &quot;<tt>2$</tt>&quot; 引用，依此类推。可以多次引用任何一个参数。

<p> 例如：

 <blockquote><pre>
   formatter.format(&quot;%4$s %3$s %2$s %1$s %4$s %3$s %2$s %1$s&quot;,
                    &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
   // -&gt; &quot;d c b a d c b a&quot;
 </pre></blockquote>

<li> <i>相对索引</i> 是在格式说明符中包含 <tt>'&lt;'</tt> (<tt>'\u003c'</tt>) 标志时使用，该标志将导致重用以前格式说明符的参数。如果不存在以前的参数，则抛出 {@link MissingFormatArgumentException}。

 <blockquote><pre>
    formatter.format(&quot;%s %s %&lt;s %&lt;s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
   // -&gt; "b a a b"
    // &quot;c&quot; and &quot;d&quot; are ignored because they are not referenced
 </pre></blockquote>

<li> <i>普通索引</i> 在格式说明符中既不包含参数索引也不包含 <tt>'&lt;'</tt> 标志时使用。每个使用普通索引的格式说明符都分配了一个连续隐式索引，分配在独立于显式索引或相对索引使用的参数列表中。

 <blockquote><pre>
   formatter.format(&quot;%s %s %s %s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
   // -&gt; &quot;a b c d&quot;
 </pre></blockquote>

 </ul>

<p> 可能有一个使用所有索引形式的格式字符串，例如：

 <blockquote><pre>
   formatter.format(&quot;%2$s %s %&lt;s %s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
   // -&gt; &quot;b a a b&quot;
   // &quot;c&quot; and &quot;d&quot; are ignored because they are not referenced
 </pre></blockquote>

<p> 参数的最大数量受到 <a href="http://java.sun.com/docs/books/vmspec/">Java Machine Specification</a> 定义的 Java 数组 的最大维数的限制。如果参数索引与可用参数不对应，则抛出 {@link MissingFormatArgumentException}。

<p> 如果参数多于格式说明符，则忽略额外的参数。

<p> 除非另行指定，否则向此类中的任何方法或构造方法传递 <tt>null</tt> 参数都将抛出 {@link NullPointerException}。

@author  Iris Clark
@version 	1.14, 07/16/04
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Formatter()
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个新 formatter。

<p> 格式化输出的目标文件是 {@link StringBuilder}，可以通过调用 {@link #out out()} 来获取它，还可以调用 {@link #toString toString()} 将其当前内容转换为一个字符串。对于 Java 虚拟机的此实例，所使用的语言环境是{@linkplain Locale#getDefault() 默认语言环境}。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Formatter(Appendable a)
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个带指定目标文件的新 formatter。

<p> 对于 Java 虚拟机的此实例，所使用的语言环境是{@linkplain Locale#getDefault() 默认语言环境}。

@param  a 格式化输出的 Destination。如果 <tt>a</tt> 为 <tt>null</tt>，则创建一个 {@link StringBuilder}。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Formatter(Locale l)
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个带指定语言环境的新 formatter。

<p> 格式化输出的目标文件是 {@link StringBuilder}，可以通过调用 {@link #out out()} 来获取它，还可以调用 {@link #toString toString()} 将其内容转换为一个字符串。

@param  l 格式化期间应用的{@linkplain java.util.Locale 语言环境}。如果 <tt>l</tt> 为 <tt>null</tt>，则不应用本地化。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Formatter(Appendable a, Locale l)
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个带指定目标文件和语言环境的新 formatter。

@param  a 格式化输出的 Destination。如果 <tt>a</tt> 为 <tt>null</tt>，则创建一个 {@link StringBuilder}。

@param  l 格式化期间应用的{@linkplain java.util.Locale 语言环境}。如果 <tt>l</tt> 为 <tt>null</tt>，则不应用本地化。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Formatter(String fileName) throws java.io.FileNotFoundException
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个带指定文件名的新 formatter。

<p> 对于 Java 虚拟机的此实例，所使用的字符集是{@linkplain java.nio.charset.Charset#defaultCharse() 默认字符集}。

<p> 对于 Java 虚拟机的此实例，所使用的语言环境是{@linkplain Locale#getDefault() 默认语言环境}。

@param  fileName 用作此 formatter 的目标文件的文件名称。如果存在该文件，则将其大小截取为零；否则创建一个新文件。将输出写入文件中，并对其进行缓冲处理。

@throws  SecurityException 如果存在安全管理器，并且 {@link SecurityManager#checkWrite checkWrite(fileName)} 拒绝对文件进行写入访问。

@throws  FileNotFoundException 如果给定的文件名称不表示现有的可写常规文件，并且无法创建该名称的新常规文件，或者在打开或创建文件时发生其他一些错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Formatter(String fileName, String csn) throws java.io.FileNotFoundException, java.io.UnsupportedEncodingException
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个带指定文件名和字符集的新 formatter。

<p> 对于 Java 虚拟机的此实例，所使用的语言环境是{@linkplain Locale#getDefault 默认语言环境}。

@param  fileName 用作此 formatter 的目标文件的文件名称。如果存在该文件，则将其大小截取为零；否则创建一个新文件。将输出写入文件中，并对其进行缓冲处理。

@param  csn 受支持的{@linkplain java.nio.charset.Charset 字符集}的名称

@throws  FileNotFoundException 如果给定的文件名称不表示现有的可写常规文件，并且无法创建该名称的新常规文件，或者在打开或创建文件时发生其他一些错误

@throws  SecurityException 如果存在安全管理器，并且 {@link SecurityManager#checkWrite checkWrite(fileName)} 拒绝对文件进行写入访问

@throws  UnsupportedEncodingException 如果不支持指定字符集

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Formatter(String fileName, String csn, Locale l) throws java.io.FileNotFoundException, java.io.UnsupportedEncodingException
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个带指定文件名、字符集和语言环境的新 formatter。

@param  fileName 用作此 formatter 的目标文件的文件名称。如果存在该文件，则将其大小截取为零；否则，创建一个新文件。将输出写入文件中，并对其进行缓冲处理。

@param  csn 受支持的{@linkplain java.nio.charset.Charset 字符集}的名称

@param  l 格式化过程中应用的{@linkplain java.util.Locale 语言环境}。如果 <tt>l</tt> 为 <tt>null</tt>，则不应用本地化。

@throws  FileNotFoundException 如果给定的文件名称不表示现有的可写常规文件，并且无法创建该名称的新常规文件，或者在打开或创建文件时发生其他一些错误

@throws  SecurityException 如果存在安全管理器，并且 {@link SecurityManager#checkWrite checkWrite(fileName)} 拒绝对文件进行写入访问。

@throws  UnsupportedEncodingException 如果不支持指定字符集

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Formatter(File file) throws java.io.FileNotFoundException
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个带指定文件的新 formatter。

<p> 对于 Java 虚拟机的此实例，所使用的字符集是{@linkplain java.nio.charset.Charset#defaultCharset() 默认字符集}。

<p> 对于 Java 虚拟机的此实例，所使用的语言环境是{@linkplain Locale#getDefault() 默认语言环境}。

@param  file 作为此 formatter 的目标文件使用的文件。如果存在该文件，则将其大小截取为零；否则，创建一个新文件。将输出写入文件中，并对其进行缓冲处理。

@throws  SecurityException 如果存在安全管理器，并且 {@link SecurityManager#checkWrite checkWrite(file.getPath())} 拒绝对文件进行写入访问。

@throws  FileNotFoundException 如果给定的文件对象不表示现有的可写常规文件，并且无法创建该名称的新常规文件，或者在打开或创建文件时发生其他一些错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Formatter(File file, String csn) throws java.io.FileNotFoundException, java.io.UnsupportedEncodingException
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个带指定文件和字符集的新 formatter。

<p> 对于 Java 虚拟机的此实例，所使用的语言环境是{@linkplain Locale#getDefault 默认语言环境}。

@param  file 作为此 formatter 的目标文件使用的文件。如果存在该文件，则将其大小截取为零；否则，创建一个新文件。将输出写入文件中，并对其进行缓冲处理。

@param  csn 受支持的{@linkplain java.nio.charset.Charset 字符集}的名称

@throws  FileNotFoundException 如果给定的文件对象不表示现有的可写常规文件，并且无法创建该名称的新常规文件，或者在打开或创建文件时发生其他一些错误

@throws  SecurityException 如果存在安全管理器，并且 {@link SecurityManager#checkWrite checkWrite(file.getPath())} 拒绝对文件进行写入访问

@throws  UnsupportedEncodingException 如果不支持指定字符集

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Formatter(File file, String csn, Locale l) throws java.io.FileNotFoundException, java.io.UnsupportedEncodingException
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个带指定文件、字符集和语言环境的新 formatter。

@param  file 作为此 formatter 的目标文件使用的文件。如果存在该文件，则将其大小截取为零；否则，创建一个新文件。将输出写入文件中，并对其进行缓冲处理。

@param  csn 受支持的{@linkplain java.nio.charset.Charset 字符集}的名称

@param  l 格式化过程中应用的{@linkplain java.util.Locale 语言环境}。如果 <tt>l</tt> 为 <tt>null</tt>，则不应用本地化。

@throws  FileNotFoundException 如果给定的文件对象不表示现有的可写常规文件，并且无法创建该名称的新常规文件，或者在打开或创建文件时发生其他一些错误

@throws  SecurityException 如果存在安全管理器，并且 {@link SecurityManager#checkWrite checkWrite(file.getPath())} 拒绝对文件进行写入访问。

@throws  UnsupportedEncodingException 如果不支持指定字符集

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Formatter(PrintStream ps)
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个带指定输出流的新 formatter。

<p> 对于 Java 虚拟机的此实例，所使用的语言环境是{@linkplain Locale#getDefault() 默认语言环境}。

<p> 将字符写入给定的 {@link java.io.PrintStream PrintStream} 对象，并使用该对象的字符集对其进行编码。 

@param  ps 作为此 formatter 的目标文件使用的流。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Formatter(OutputStream os)
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个带指定输出流的新 formatter。

<p> 对于 Java 虚拟机的此实例，所使用的字符集是{@linkplain java.nio.charset.Charset#defaultCharset() 默认字符集}。

<p> 对于 Java 虚拟机的此实例，所使用的语言环境是{@linkplain Locale#getDefault() 默认语言环境}。

@param  os 作为此 formatter 的目标文件使用的流。将对输出进行缓冲。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Formatter(OutputStream os, String csn) throws java.io.UnsupportedEncodingException
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个带指定输出流和字符集的新 formatter。

<p> 对于 Java 虚拟机的此实例，所使用的语言环境是{@linkplain Locale#getDefault 默认语言环境}。

@param  os 作为此 formatter 的目标文件使用的流。将对输出进行缓冲。

@param  csn 受支持的{@linkplain java.nio.charset.Charset 字符集}的名称

@throws  UnsupportedEncodingException 如果不支持指定字符集

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Formatter(OutputStream os, String csn, Locale l) throws java.io.UnsupportedEncodingException
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个带指定输出流、字符集和语言环境的新 formatter。

@param  os 作为此 formatter 的目标文件使用的流。将对输出进行缓冲。

@param  csn 受支持的{@linkplain java.nio.charset.Charset 字符集}的名称

@param  l 格式化过程中应用的{@linkplain java.util.Locale 语言环境}。如果 <tt>l</tt> 为 <tt>null</tt>，则不应用本地化。

@throws  UnsupportedEncodingException 如果不支持指定字符集

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Locale java.util.Formatter.locale()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回构造此 formatter 时设置的语言环境。

<p> 此对象的带语言环境参数的{@link #format(java.util.Locale,String,Object...) 格式}方法不会更改该值。

@return  如果没有应用本地化，则返回 <tt>null</tt>；否则返回一个语言环境

@throws  FormatterClosedException 如果已经通过调用 {@link #close()} 方法关闭此 formatter

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.Appendable java.util.Formatter.out()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回输出的目标文件。

@return  输出的目标文件

@throws  FormatterClosedException 如果已经通过调用 {@link #close()} 方法关闭此 formatter

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.util.Formatter.toString()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回对输出的目标文件调用 <tt>toString()</tt> 的结果。例如，以下代码将文本格式化到 {@link StringBuilder} 中，然后获取得到的字符串：

 <blockquote><pre>
   Formatter f = new Formatter();
   f.format(&quot;Last reboot at %tc&quot;, lastRebootDate);
   String s = f.toString();
   // -&gt; s == "Last reboot at Sat Jan 01 00:00:00 PST 2000"
 </pre></blockquote>

<p> 调用此方法的方式与调用 out().toString() 的方式完全相同。

 <pre>
     out().toString() </pre>

<p> 根据针对 {@link Appendable} 的 <tt>toString</tt> 的规范，返回的字符串可能否包含（也可能不包含）写入目标文件的字符。例如，缓冲器通常在 <tt>toString()</tt> 中返回其内容，而流不能这样做，因为数据已被丢弃。

@return  对输出目标文件调用 <tt>toString()</tt> 的结果

@throws  FormatterClosedException 如果已经通过调用 {@link #close()} 方法关闭此 formatter

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.util.Formatter.flush()
<!-- END KEY -->
<!-- BEGIN DATA -->
刷新此 formatter。如果目标文件实现 {@link java.io.Flushable} 接口，则调用其 <tt>flush</tt> 方法。

<p> 刷新 formatter 会使目标文件中的所有缓冲输出都写入底层流中。 

@throws  FormatterClosedException 如果已经通过调用 {@link #close()} 方法关闭此 formatter

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.util.Formatter.close()
<!-- END KEY -->
<!-- BEGIN DATA -->
关闭此 formatter。如果目标文件实现 {@link java.io.Closeable} 接口，则调用其 <tt>close</tt> 方法。

<p> 关闭 formatter 允许释放它可能保持（比如打开文件）的资源。如果已经关闭 formatter，则调用此方法无效。

<p> 如果试图在此 formatter 已经关闭之后调用其中除 {@link #ioException()} 之外的任何方法，那么都将导致 {@link FormatterClosedException}。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.io.IOException java.util.Formatter.ioException()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回由此 formatter 的 {@link Appendable} 方法上次抛出的 <tt>IOException</tt> 异常。

<p> 如果目标文件的 <tt>append()</tt> 方法从未抛出 <tt>IOException</tt>，则此方法将始终返回 <tt>null</tt>。

@return 如果不存在这样的异常，则返回由 Appendable 或 <tt>null</tt> 上次抛出的异常。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Formatter java.util.Formatter.format(String format, java.lang.Object[] args)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定格式字符串和参数将一个格式化字符串写入此对象的目标文件中。使用的语言环境是构造此 formatter 期间定义的语言环境。

@param  format 在<a href="#syntax">格式字符串的语法</a>中描述的格式字符串。

@param  args 格式字符串中的格式说明符引用的参数。如果参数多于格式说明符，则忽略额外的参数。参数的最大数量受到 <a href="http://java.sun.com/docs/books/vmspec/">Java Virtual Machine Specification</a> 定义的 Java 数组的最大维数的限制。

@throws  IllegalFormatException 如果格式字符串包含非法语法、与给定参数不兼容的格式说明符、对给定格式字符串而言不够充足的参数或其他非法条件。有关所有可能的格式错误的规范，请参阅 formatter 类规范的<a href="#detail">详细信息</a>部分。

@throws  FormatterClosedException 如果已经通过调用 {@link #close()} 方法关闭此 formatter

@return  此 formatter

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Formatter java.util.Formatter.format(Locale l, String format, java.lang.Object[] args)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用指定的语言环境、格式字符串和参数，将一个格式化字符串写入此对象的目标文件中。

@param  l 格式化过程中应用的{@linkplain java.util.Locale 语言环境}。如果 <tt>l</tt> 为 <tt>null</tt>，则不应用本地化。这不会改变构造期间设置的对象的语言环境。

@param  format 在<a href="#syntax">格式字符串的语法</a>中描述的格式字符串

@param  args 格式字符串中的格式说明符引用的参数。如果参数多于格式说明符，则忽略额外的参数。参数的最大数量受到 <a href="http://java.sun.com/docs/books/vmspec/">Java Virtual Machine Specification</a> 定义的 Java 数组的最大维数的限制

@throws  IllegalFormatException 如果格式字符串包含非法语法、与给定参数不兼容的格式说明符、对给定格式字符串而言不够充足的参数或其他非法条件。有关所有可能的格式错误的规范，请参阅 formatter 类规范的<a href="#detail">详细信息</a>部分。

@throws  FormatterClosedException 如果已经通过调用 {@link #close()} 方法关闭此 formatter

@return  此 formatter

<!-- END DATA -->


