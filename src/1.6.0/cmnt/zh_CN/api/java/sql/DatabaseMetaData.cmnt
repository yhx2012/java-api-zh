<!-- BEGIN KEY -->
public interface java.sql.DatabaseMetaData extends java.sql.Wrapper
<!-- END KEY -->
<!-- BEGIN DATA -->
关于数据库的整体综合信息。
 <P>
此接口由驱动程序供应商实现，让用户了解 Database Management System (DBMS) 在与驱动程序（基于与其一起使用的 JDBC<sup><font size=-2>TM</font></sup> 技术（&ldquo;JDBC 驱动程序&rdquo;））相结合时的能力。不同的关系 DBMS 常常支持不同的功能，以不同方式实现这些功能，并使用不同的数据类型。此外，驱动程序可以实现 DBMS 提供的顶级功能。此接口中的方法返回的信息关系到一起工作的特定驱动程序和特定 DBMS 的能力。注意，正如此文档中所使用的那样，术语&ldquo;数据库&rdquo;通常既指驱动程序，又指 DBMS。
 <P>
此接口的用户通常是一个需要发现如何处理底层 DBMS 的工具。对于试图与多个 DBMS 一起使用的应用程序而言尤其如此。例如，一个工具可能使用 <code>getTypeInfo</code> 方法找出可以在 <code>CREATE TABLE</code> 语句中使用的数据类型。或者用户可能调用 <code>supportsCorrelatedSubqueries</code> 方法查看是否可以使用相关子查询，或者调用 <code>supportsBatchUpdates</code> 查看是否可以使用批量更新。 
 <P>
有些 <code>DatabaseMetaData</code> 方法以 <code>ResultSet</code> 对象的形式返回信息列表。常规 <code>ResultSet</code> 方法（比如 <code>getString</code> 和 <code>getInt</code>）可用于从这些 <code>ResultSet</code> 对象中获取数据。如果给定形式的元数据不可用，则将返回一个空 <code>ResultSet</code>。对于被定义为由 <code>ResultSet</code> 对象的给定方法所返回的列以外的其他列，可以由 JDBC 驱动程序供应商定义，且必须通过其<B>列标签</B>访问。
 <P>
有些 <code>DatabaseMetaData</code> 方法使用 String 模式的参数。这些参数都有 fooPattern 这样的名称。在模式 String 中，&quot;%&quot; 表示匹配 0 个或多个字符的任何子字符串，&quot;_&quot; 表示匹配任何一个字符。仅返回匹配搜索模式的元数据项。如果将搜索模式参数设置为 <code>null</code>，则从搜索中删除参数标准。
 <P>

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.procedureResultUnknown
<!-- END KEY -->
<!-- BEGIN DATA -->
指示不知道过程是否返回结果。
 <P>
<code>getProcedures</code> 方法返回的 <code>ResultSet</code> 对象中 <code>PROCEDURE_TYPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.procedureNoResult
<!-- END KEY -->
<!-- BEGIN DATA -->
指示过程不返回结果。
 <P>
<code>getProcedures</code> 方法返回的 <code>ResultSet</code> 对象中 <code>PROCEDURE_TYPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.procedureReturnsResult
<!-- END KEY -->
<!-- BEGIN DATA -->
指示过程返回结果。
 <P>
<code>getProcedures</code> 方法返回的 <code>ResultSet</code> 对象中 <code>PROCEDURE_TYPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.procedureColumnUnknown
<!-- END KEY -->
<!-- BEGIN DATA -->
指示列的类型为未知。
 <P>
<code>getProcedureColumns</code> 方法返回的 <code>ResultSet</code> 对象中 <code>COLUMN_TYPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.procedureColumnIn
<!-- END KEY -->
<!-- BEGIN DATA -->
指示列中存储了 IN 参数。
 <P>
<code>getProcedureColumns</code> 方法返回的 <code>ResultSet</code> 对象中 <code>COLUMN_TYPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.procedureColumnInOut
<!-- END KEY -->
<!-- BEGIN DATA -->
指示列中存储了 INOUT 参数。
 <P>
<code>getProcedureColumns</code> 方法返回的 <code>ResultSet</code> 对象中 <code>COLUMN_TYPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.procedureColumnOut
<!-- END KEY -->
<!-- BEGIN DATA -->
指示列中存储了 OUT 参数。
 <P>
<code>getProcedureColumns</code> 方法返回的 <code>ResultSet</code> 对象中 <code>COLUMN_TYPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.procedureColumnReturn
<!-- END KEY -->
<!-- BEGIN DATA -->
指示列中存储了返回值。
 <P>
<code>getProcedureColumns</code> 方法返回的 <code>ResultSet</code> 对象中 <code>COLUMN_TYPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.procedureColumnResult
<!-- END KEY -->
<!-- BEGIN DATA -->
指示列中存储了结果。
 <P>
<code>getProcedureColumns</code> 方法返回的 <code>ResultSet</code> 对象中 <code>COLUMN_TYPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.procedureNoNulls
<!-- END KEY -->
<!-- BEGIN DATA -->
指示不允许使用 <code>NULL</code> 值。
 <P>
<code>getProcedureColumns</code> 方法返回的 <code>ResultSet</code> 对象中 <code>NULLABLE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.procedureNullable
<!-- END KEY -->
<!-- BEGIN DATA -->
指示允许使用 <code>NULL</code> 值。
 <P>
<code>getProcedureColumns</code> 方法返回的 <code>ResultSet</code> 对象中 <code>NULLABLE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.procedureNullableUnknown
<!-- END KEY -->
<!-- BEGIN DATA -->
指示不知道是否允许使用 <code>NULL</code> 值。
 <P>
<code>getProcedureColumns</code> 方法返回的 <code>ResultSet</code> 对象中 <code>NULLABLE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.columnNoNulls
<!-- END KEY -->
<!-- BEGIN DATA -->
指示列中可能不允许使用 <code>NULL</code> 值。
 <P>
<code>getColumns</code> 方法返回的 <code>ResultSet</code> 对象中 <code>NULLABLE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.columnNullable
<!-- END KEY -->
<!-- BEGIN DATA -->
指示列中明确允许使用 <code>NULL</code> 值。
 <P>
<code>getColumns</code> 方法返回的 <code>ResultSet</code> 对象中 <code>NULLABLE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.columnNullableUnknown
<!-- END KEY -->
<!-- BEGIN DATA -->
指示不知道列是否可为 null。
 <P>
<code>getColumns</code> 方法返回的 <code>ResultSet</code> 对象中 <code>NULLABLE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.bestRowTemporary
<!-- END KEY -->
<!-- BEGIN DATA -->
指示最佳行标识符的作用域是临时的，仅在使用该行时可用。
 <P>
<code>getBestRowIdentifier</code> 方法返回的 <code>ResultSet</code> 对象中 <code>SCOPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.bestRowTransaction
<!-- END KEY -->
<!-- BEGIN DATA -->
指示最佳行标识符的作用域是当前事务的剩余部分。
 <P>
<code>getBestRowIdentifier</code> 方法返回的 <code>ResultSet</code> 对象中 <code>SCOPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.bestRowSession
<!-- END KEY -->
<!-- BEGIN DATA -->
指示最佳行标识符的作用域是当前会话的剩余部分。
 <P>
<code>getBestRowIdentifier</code> 方法返回的 <code>ResultSet</code> 对象中 <code>SCOPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.bestRowUnknown
<!-- END KEY -->
<!-- BEGIN DATA -->
指示最佳行标识符可能是伪列 (pseudo column)，也可能不是。
 <P>
<code>getBestRowIdentifier</code> 方法返回的 <code>ResultSet</code> 对象中 <code>PSEUDO_COLUMN</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.bestRowNotPseudo
<!-- END KEY -->
<!-- BEGIN DATA -->
指示最佳行标识符&ldquo;不&rdquo;是伪列。
 <P>
<code>getBestRowIdentifier</code> 方法返回的 <code>ResultSet</code> 对象中 <code>PSEUDO_COLUMN</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.bestRowPseudo
<!-- END KEY -->
<!-- BEGIN DATA -->
指示最佳行标识符是伪列。
 <P>
<code>getBestRowIdentifier</code> 方法返回的 <code>ResultSet</code> 对象中 <code>PSEUDO_COLUMN</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.versionColumnUnknown
<!-- END KEY -->
<!-- BEGIN DATA -->
指示这种版本的列可能是伪列，也可能不是。
 <P>
<code>getVersionColumns</code> 方法返回的 <code>ResultSet</code> 对象中 <code>PSEUDO_COLUMN</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.versionColumnNotPseudo
<!-- END KEY -->
<!-- BEGIN DATA -->
指示这种版本的列&ldquo;不&rdquo;是伪列。
 <P>
<code>getVersionColumns</code> 方法返回的 <code>ResultSet</code> 对象中 <code>PSEUDO_COLUMN</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.versionColumnPseudo
<!-- END KEY -->
<!-- BEGIN DATA -->
指示这种版本的列是伪列。
 <P>
<code>getVersionColumns</code> 方法返回的 <code>ResultSet</code> 对象中 <code>PSEUDO_COLUMN</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.importedKeyCascade
<!-- END KEY -->
<!-- BEGIN DATA -->
对于 <code>UPDATE_RULE</code> 列，指示在更新主键时，外键（导入的键）的更改要与之一致。对于 <code>DELETE_RULE</code> 列，它指示在删除主键时，也应删除导入该键的行。
 <P>
方法 <code>getImportedKeys</code>、<code>getExportedKeys</code> 和 <code>getCrossReference</code> 返回的 <code>ResultSet</code> 对象中 <code>UPDATE_RULE</code> 和 <code>DELETE_RULE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.importedKeyRestrict
<!-- END KEY -->
<!-- BEGIN DATA -->
对于 <code>UPDATE_RULE</code> 列，指示如果主键已被另一个表作为外键导入，则可能不更新该主键。对于 <code>DELETE_RULE</code> 列，指示如果主键已被另一个表作为外键导入，则可能不删除该主键。
 <P>
方法 <code>getImportedKeys</code>、<code>getExportedKeys</code> 和 <code>getCrossReference</code> 返回的 <code>ResultSet</code> 对象中 <code>UPDATE_RULE</code> 和 <code>DELETE_RULE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.importedKeySetNull
<!-- END KEY -->
<!-- BEGIN DATA -->
对于 <code>UPDATE_RULE</code> 和 <code>DELETE_RULE</code> 列，指示在更新或删除主键时，将外键（导入的键）更改为 <code>NULL</code>。
 <P>
方法 <code>getImportedKeys</code>、<code>getExportedKeys</code> 和 <code>getCrossReference</code> 返回的 <code>ResultSet</code> 对象中 <code>UPDATE_RULE</code> 和 <code>DELETE_RULE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.importedKeyNoAction
<!-- END KEY -->
<!-- BEGIN DATA -->
对于 <code>UPDATE_RULE</code> 和 <code>DELETE_RULE</code> 列，指示如果主键已导入，则无法更新或删除它。
 <P>
方法 <code>getImportedKeys</code>、<code>getExportedKeys</code> 和 <code>getCrossReference</code> 返回的 <code>ResultSet</code> 对象中 <code>UPDATE_RULE</code> 和 <code>DELETE_RULE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.importedKeySetDefault
<!-- END KEY -->
<!-- BEGIN DATA -->
对于 <code>UPDATE_RULE</code> 和 <code>DELETE_RULE</code> 列，指示如果更新或删除了主键，则将外键（导入的键）设置为默认值。
 <P>
方法 <code>getImportedKeys</code>、<code>getExportedKeys</code> 和 <code>getCrossReference</code> 返回的 <code>ResultSet</code> 对象中 <code>UPDATE_RULE</code> 和 <code>DELETE_RULE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.importedKeyInitiallyDeferred
<!-- END KEY -->
<!-- BEGIN DATA -->
指示可延迟性。有关定义，请参见 SQL-92。
 <P>
方法 <code>getImportedKeys</code>、<code>getExportedKeys</code> 和 <code>getCrossReference</code> 返回的 <code>ResultSet</code> 对象中 <code>DEFERRABILITY</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.importedKeyInitiallyImmediate
<!-- END KEY -->
<!-- BEGIN DATA -->
指示可延迟性。有关定义，请参见 SQL-92。
 <P>
方法 <code>getImportedKeys</code>、<code>getExportedKeys</code> 和 <code>getCrossReference</code> 返回的 <code>ResultSet</code> 对象中 <code>DEFERRABILITY</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.importedKeyNotDeferrable
<!-- END KEY -->
<!-- BEGIN DATA -->
指示可延迟性。有关定义，请参见 SQL-92。
 <P>
方法 <code>getImportedKeys</code>、<code>getExportedKeys</code> 和 <code>getCrossReference</code> 返回的 <code>ResultSet</code> 对象中 <code>DEFERRABILITY</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.typeNoNulls
<!-- END KEY -->
<!-- BEGIN DATA -->
指示&ldquo;不&rdquo;允许对这种数据类型使用 <code>NULL</code> 值。
 <P>
<code>getTypeInfo</code> 方法返回的 <code>ResultSet</code> 对象中 <code>NULLABLE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.typeNullable
<!-- END KEY -->
<!-- BEGIN DATA -->
指示允许对这种数据类型使用 <code>NULL</code> 值。
 <P>
<code>getTypeInfo</code> 方法返回的 <code>ResultSet</code> 对象中 <code>NULLABLE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.typeNullableUnknown
<!-- END KEY -->
<!-- BEGIN DATA -->
指示不知道是否允许对这种数据类型使用 <code>NULL</code> 值。
 <P>
<code>getTypeInfo</code> 方法返回的 <code>ResultSet</code> 对象中 <code>NULLABLE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.typePredNone
<!-- END KEY -->
<!-- BEGIN DATA -->
指示不支持将 <code>WHERE</code> 搜索子句用于这种类型。
 <P>
<code>getTypeInfo</code> 方法返回的 <code>ResultSet</code> 对象中 <code>SEARCHABLE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.typePredChar
<!-- END KEY -->
<!-- BEGIN DATA -->
指示该数据类型只能用于使用 <code>LIKE</code> 谓词的 <code>WHERE</code> 搜索子句中。
 <P>
<code>getTypeInfo</code> 方法返回的 <code>ResultSet</code> 对象中 <code>SEARCHABLE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.typePredBasic
<!-- END KEY -->
<!-- BEGIN DATA -->
指示该数据类型只能用于不使用 <code>LIKE</code> 谓词的 <code>WHERE</code> 搜索子句中。
 <P>
<code>getTypeInfo</code> 方法返回的 <code>ResultSet</code> 对象中 <code>SEARCHABLE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.typeSearchable
<!-- END KEY -->
<!-- BEGIN DATA -->
指示在此类型上可以建立所有 <code>WHERE</code> 搜索子句。
 <P>
<code>getTypeInfo</code> 方法返回的 <code>ResultSet</code> 对象中 <code>SEARCHABLE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final short java.sql.DatabaseMetaData.tableIndexStatistic
<!-- END KEY -->
<!-- BEGIN DATA -->
指示此列包含与表的索引描述一起返回的表统计信息。
 <P>
<code>getIndexInfo</code> 方法返回的 <code>ResultSet</code> 对象中 <code>TYPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final short java.sql.DatabaseMetaData.tableIndexClustered
<!-- END KEY -->
<!-- BEGIN DATA -->
指示此表索引是一个集群索引 (clustered index)。
 <P>
<code>getIndexInfo</code> 方法返回的 <code>ResultSet</code> 对象中 <code>TYPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final short java.sql.DatabaseMetaData.tableIndexHashed
<!-- END KEY -->
<!-- BEGIN DATA -->
指示此表索引是一个散列索引。
 <P>
<code>getIndexInfo</code> 方法返回的 <code>ResultSet</code> 对象中 <code>TYPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final short java.sql.DatabaseMetaData.tableIndexOther
<!-- END KEY -->
<!-- BEGIN DATA -->
指示此表索引不是集群索引、散列索引或表统计信息，它是其他某种东西。
 <P>
<code>getIndexInfo</code> 方法返回的 <code>ResultSet</code> 对象中 <code>TYPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final short java.sql.DatabaseMetaData.attributeNoNulls
<!-- END KEY -->
<!-- BEGIN DATA -->
指示可能不允许使用 <code>NULL</code> 值。
 <P>
<code>getAttributes</code> 方法返回的 <code>ResultSet</code> 对象中 <code>NULLABLE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final short java.sql.DatabaseMetaData.attributeNullable
<!-- END KEY -->
<!-- BEGIN DATA -->
指示明确允许使用 <code>NULL</code> 值。
 <P>
<code>getAttributes</code> 方法返回的 <code>ResultSet</code> 对象中 <code>NULLABLE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final short java.sql.DatabaseMetaData.attributeNullableUnknown
<!-- END KEY -->
<!-- BEGIN DATA -->
指示不知道是否允许使用 <code>NULL</code> 值。 
 <P>
<code>getAttributes</code> 方法返回的 <code>ResultSet</code> 对象中 <code>NULLABLE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.sqlStateXOpen
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>DatabaseMetaData.getSQLStateType</code> 方法一个可能的返回值，用于指示 <code>SQLException.getSQLState</code> 返回的值是否是一个 X/Open（现在称为 Open Group）SQL CLI SQLSTATE 值。
 <P>
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.sqlStateSQL
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>DatabaseMetaData.getSQLStateType</code> 方法一个可能的返回值，用于指示 <code>SQLException.getSQLState</code> 方法返回的值是否是一个 SQLSTATE 值。
 <P>
@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.sqlStateSQL99
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>DatabaseMetaData.getSQLStateType</code> 方法一个可能的返回值，用于指示 <code>SQLException.getSQLState</code> 方法返回的值是否是一个 SQL99 SQLSTATE 值。
<P>
<b>注：</b>保留此常量仅出于兼容性考虑。开发人员应该使用 <code>sqlStateSQL</code> 常量来代替。

@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.functionColumnUnknown
<!-- END KEY -->
<!-- BEGIN DATA -->
 指示该类型的参数或列未知。
 <P>
  <code>ResultSet</code> 中由 <code>getFunctionColumns</code> 方法返回的 <code>COLUMN_TYPE</code> 列的可能值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.functionColumnIn
<!-- END KEY -->
<!-- BEGIN DATA -->
 指示参数或列是一个 IN 参数。
 <P>
 <code>ResultSet</code> 中由 <code>getFunctionColumns</code> 方法返回的 <code>COLUMN_TYPE</code> 列的可能值。
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.functionColumnInOut
<!-- END KEY -->
<!-- BEGIN DATA -->
 指示参数或列是一个 INOUT 参数。
 <P>
 <code>ResultSet</code> 中由 <code>getFunctionColumns</code> 方法返回的 <code>COLUMN_TYPE</code> 列的可能值。
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.functionColumnOut
<!-- END KEY -->
<!-- BEGIN DATA -->
 指示参数或列是一个 OUT 参数。 
 <P>
 <code>ResultSet</code> 中由 <code>getFunctionColumns</code> 方法返回的 <code>COLUMN_TYPE</code> 列的可能值。
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.functionReturn
<!-- END KEY -->
<!-- BEGIN DATA -->
 指示参数或列是一个返回值。
 <P>
  <code>ResultSet</code> 中由 <code>getFunctionColumns</code> 方法返回的 <code>COLUMN_TYPE</code> 列的可能值。   
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.functionColumnResult
<!-- END KEY -->
<!-- BEGIN DATA -->
 指示参数或列是结果集中的一列。
 <P>
 <code>ResultSet</code> 中由 <code>getFunctionColumns</code> 方法返回的 <code>COLUMN_TYPE</code> 列的可能值。 
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.functionNoNulls
<!-- END KEY -->
<!-- BEGIN DATA -->
 指示不允许 <code>NULL</code> 值。
 <P>
 <code>ResultSet</code> 对象中由 <code>getFunctionColumns</code> 方法返回的 <code>NULLABLE</code> 列的可能值。
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.functionNullable
<!-- END KEY -->
<!-- BEGIN DATA -->
 指示允许 <code>NULL</code> 值。
 <P>
  <code>ResultSet</code> 对象中由 <code>getFunctionColumns</code> 方法返回的 <code>NULLABLE</code> 列的可能值。
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.functionNullableUnknown
<!-- END KEY -->
<!-- BEGIN DATA -->
 指示是否允许 <code>NULL</code> 值是未知的。 
 <P>
 <code>ResultSet</code> 对象中由 <code>getFunctionColumns</code> 方法返回的 <code>NULLABLE</code> 列的可能值。
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.functionResultUnknown
<!-- END KEY -->
<!-- BEGIN DATA -->
 指示不知道函数是返回一个结果还是一个表。
 <P>
  <code>ResultSet</code> 对象中由 <code>getFunctions</code> 方法返回的 <code>FUNCTION_TYPE</code> 列的可能值。
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.functionNoTable
<!-- END KEY -->
<!-- BEGIN DATA -->
 指示函数不返回一个表。
 <P>
 <code>ResultSet</code> 对象中由 <code>getFunctions</code> 方法返回的 <code>FUNCTION_TYPE</code> 列的可能值。
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.sql.DatabaseMetaData.functionReturnsTable
<!-- END KEY -->
<!-- BEGIN DATA -->
 指示函数返回一个表。
 <P>
  <code>ResultSet</code> 对象中由 <code>getFunctions</code> 方法返回的 <code>FUNCTION_TYPE</code> 列的可能值。
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.allProceduresAreCallable() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取当前用户是否可以调用 <code>getProcedures</code> 方法返回的所有过程。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.allTablesAreSelectable() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取当前用户是否可以使用 <code>SELECT</code> 语句中的 <code>getTables</code> 方法返回的所有表。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getURL() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此 DBMS 的 URL。

@return 此 DBMS 的 URL，如果无法生成该 URL，则返回 <code>null</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getUserName() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库的已知的用户名称。

@return 数据库用户名称
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.isReadOnly() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否处于只读模式。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.nullsAreSortedHigh() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取 <code>NULL</code> 值是否被高排序。高排序是指在域中，<code>NULL</code> 值的排序高于其他任何值。在升序中，如果此方法返回 <code>true</code>，则 <code>NULL</code> 值将出现在末尾。相反，<code>nullsAreSortedAtEnd</code> 方法指示 <code>NULL</code> 值始终存储在末尾，不管排序顺序如何。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.nullsAreSortedLow() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取 <code>NULL</code> 值是否被低排序。低排序是指在域中，<code>NULL</code> 值的排序低于其他任何值。在升序中，如果此方法返回 <code>true</code>，则 <code>NULL</code> 值将出现在开头。相反，<code>nullsAreSortedAtStart</code> 方法指示 <code>NULL</code> 值始终存储在开头，不管排序顺序如何。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.nullsAreSortedAtStart() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取 <code>NULL</code> 值是否始终排在开头，不管排序顺序如何。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.nullsAreSortedAtEnd() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取 <code>NULL</code> 值是否始终排在末尾，不管排序顺序如何。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getDatabaseProductName() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库产品的名称。

@return 数据库产品名称
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getDatabaseProductVersion() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库产品的版本号。

@return 数据库版本号
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getDriverName() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此 JDBC 驱动程序的名称。

@return JDBC 驱动程序名称
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getDriverVersion() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此 JDBC 驱动程序的 <code>String</code> 形式的版本号。

@return JDBC 驱动程序版本
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getDriverMajorVersion()
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此 JDBC 驱动程序的主版本号。

@return JDBC 驱动程序的主版本

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getDriverMinorVersion()
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此 JDBC 驱动程序的次版本号。

@return JDBC 驱动程序的次版本号

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.usesLocalFiles() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否将表存储在本地文件中。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.usesLocalFilePerTable() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否为每个表使用一个文件。

@return 如果此数据库为每个表使用一个本地文件，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsMixedCaseIdentifiers() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否将大小写混写的不带引号的 SQL 标识符作为区分大小写的形式处理，并且最后以大小写混合形式存储它们。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.storesUpperCaseIdentifiers() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否将大小写混写的不带引号的 SQL 标识符作为不区分大小写的形式处理，并以大写形式存储它们。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.storesLowerCaseIdentifiers() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否将大小写混写的不带引号的 SQL 标识符作为不区分大小写的形式处理，并以小写形式存储它们。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.storesMixedCaseIdentifiers() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否将大小写混写的不带引号的 SQL 标识符作为不区分大小写的形式处理，并以大小写混合形式存储它们。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsMixedCaseQuotedIdentifiers() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否将大小写混写的带引号的 SQL 标识符作为区分大小写的形式处理，并且最后以大小写混合形式存储它们。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.storesUpperCaseQuotedIdentifiers() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否将大小写混写的带引号的 SQL 标识符作为不区分大小写的形式处理，并以大写形式存储它们。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.storesLowerCaseQuotedIdentifiers() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否将大小写混写的带引号的 SQL 标识符作为不区分大小写的形式处理，并以小写形式存储它们。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.storesMixedCaseQuotedIdentifiers() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否将大小写混写的带引号的 SQL 标识符作为不区分大小写的形式处理，并以大小写混合形式存储它们。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getIdentifierQuoteString() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取用于引用 SQL 标识符的字符串。如果标识符引用不受支持，则此方法返回一个空格 &quot; &quot;。

@return 引用字符串，如果引用不受支持，则返回一个空格
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getSQLKeywords() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库的还&ldquo;不&rdquo;是 SQL:2003 关键字的所有 SQL 关键字的逗号分隔列表。

@return 此数据库的还不是 SQL:2003 关键字的那些关键字组成的列表
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getNumericFunctions() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取可用于此数据库的数学函数的逗号分隔列表。这些是用于 JDBC 函数转义子句中的 Open /Open CLI 数学函数名称。

@return 此数据库支持的数学函数的列表
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getStringFunctions() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取可用于此数据库的字符串函数的逗号分隔列表。这些是用于 JDBC 函数转义子句中的 Open Group CLI 字符串函数名称。

@return 受此数据库支持的字符串函数的列表
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getSystemFunctions() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取可用于此数据库的系统函数的逗号分隔列表。这些是用于 JDBC 函数转义子句中的 Open Group CLI 系统函数名称。

@return 受此数据库支持的系统函数的列表
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getTimeDateFunctions() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取可用于此数据库的时间和日期函数的逗号分隔列表。

@return 受此数据库支持的时间和日期函数的列表
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getSearchStringEscape() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取可用于转义通配符的字符串。该字符串是可用于在类别搜索参数中转义 '_' 或 '%' 的字符串，这些类别搜索参数表示模式（因此使用通配符之一）。

<P>'_' 字符表示任何单个字符；'%' 字符表示零个或多个字符的任意序列。

@return 用于转义通配符的字符串
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getExtraNameCharacters() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取可以在不带引号的标识符名称中使用的所有&ldquo;额外&rdquo;字符（除了 a-z、A-Z、0-9 和 _ 以外的字符）。

@return 包含额外字符的字符串
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsAlterTableWithAddColumn() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持带有 add 列的 <code>ALTER TABLE</code>。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsAlterTableWithDropColumn() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持带有 drop 列的 <code>ALTER TABLE</code>。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsColumnAliasing() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持为列提供别名。

<P>如果支持，则可以使用 SQL AS 子句为已经计算的列提供名称，或者为所需要的列提供别名。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.nullPlusNonNullIsNull() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持 <code>NULL</code> 值与等于 <code>NULL</code> 的非 <code>NULL</code> 值之间的连接。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsConvert() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持用于 JDBC 类型之间转换的 JDBC 标量函数 <code>CONVERT</code>。JDBC 类型是 <code>java.sql.Types</code> 中定义的一般 SQL 数据类型。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsConvert(int fromType, int toType) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持用于 JDBC <i>fromType</i> 和 <i>toType</i> 类型之间转换的 JDBC 标量函数 <code>CONVERT</code>。JDBC 类型是 <code>java.sql.Types</code> 中定义的一般 SQL 数据类型。

@param fromType 要转换的类型，它是 <code>java.sql.Types</code> 类中的类型代码之一
@param toType 要转换的目标类型，它是 <code>java.sql.Types</code> 类中的类型代码之一
@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@see Types

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsTableCorrelationNames() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持表关联名称。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsDifferentTableCorrelationNames() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取在表关联名称受支持时，是否要限制它们与表的名称不同。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsExpressionsInOrderBy() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持 <code>ORDER BY</code> 列表中的表达式。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsOrderByUnrelated() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持使用不在 <code>SELECT</code> 语句中而在 <code>ORDER BY</code> 子句中的列。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsGroupBy() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持某种形式的 <code>GROUP BY</code> 子句。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsGroupByUnrelated() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持使用不在 <code>SELECT</code> 语句中而在 <code>GROUP BY</code> 子句中的列。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsGroupByBeyondSelect() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持使用不包含在 <code>SELECT</code> 语句中而包含在 <code>GROUP BY</code> 子句中的列，假设 <code>SELECT</code> 语句中的所有列都包含在 <code>GROUP BY</code> 子句中。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsLikeEscapeClause() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持指定 <code>LIKE</code> 转义子句。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsMultipleResultSets() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持一次调用 <code>execute</code> 方法获得多个 <code>ResultSet</code> 对象。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsMultipleTransactions() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否允许一次打开多个事务（在不同的 connection 上）。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsNonNullableColumns() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取是否可以将此数据库中的列定义为非 null。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsMinimumSQLGrammar() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持 ODBC Minimum SQL 语法。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsCoreSQLGrammar() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持 ODBC Core SQL 语法。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsExtendedSQLGrammar() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持 ODBC Extended SQL 语法。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsANSI92EntryLevelSQL() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持 ANSI92 入门级 SQL 语法。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsANSI92IntermediateSQL() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持受支持的 ANSI92 中间 SQL 语法。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsANSI92FullSQL() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持受支持的 ANSI92 完全 SQL 语法。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsIntegrityEnhancementFacility() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持 SQL Integrity Enhancement Facility。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsOuterJoins() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持某种形式的外连接。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsFullOuterJoins() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持完全嵌套的外连接。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsLimitedOuterJoins() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否为外连接提供受限制的支持。（如果 <code>supportsFullOuterJoins</code> 方法返回 <code>true</code>，则此为 <code>true</code>）。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getSchemaTerm() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取数据库供应商用于 &quot;schema&quot; 的首选术语。

@return 供应商用于 &quot;schema&quot; 的术语
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getProcedureTerm() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取数据库供应商用于 &quot;procedure&quot; 的首选术语。

@return 供应商用于 &quot;procedure&quot; 的术语
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getCatalogTerm() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取数据库供应商用于 &quot;catalog&quot; 的首选术语。

@return 供应商用于 &quot;catalog&quot; 的术语
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.isCatalogAtStart() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取某个类别是否出现在完全限定表名的开头。如果没有出现在开头，则类别出现在表名末尾。

@return 如果类别出现在完全限定表名的开头，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.sql.DatabaseMetaData.getCatalogSeparator() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库用作类别和表名之间的分隔符的 <code>String</code>。

@return 分隔符字符串
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsSchemasInDataManipulation() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取某个模式名称是否可以数据操作语句中使用。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsSchemasInProcedureCalls() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取某个模式名称是否可以在过程调用语句中使用。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsSchemasInTableDefinitions() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取某个模式名称是否可以在表定义语句中使用。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsSchemasInIndexDefinitions() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取某个模式名称是否可以在获取定义语句中使用。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsSchemasInPrivilegeDefinitions() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取某个模式名称是否可以在特权定义语句中使用。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsCatalogsInDataManipulation() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取某个类别名称是否可以在数据操作语句中使用。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsCatalogsInProcedureCalls() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取某个类别名称是否可以在过程调用语句中使用。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsCatalogsInTableDefinitions() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取某个类别名称是否可以在表定义语句中使用。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsCatalogsInIndexDefinitions() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取某个类别名称是否可以在获取定义语句中使用。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsCatalogsInPrivilegeDefinitions() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取某个类别名称是否可以在特权定义语句中使用。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsPositionedDelete() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持位置的 <code>DELETE</code> 语句。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsPositionedUpdate() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持位置的 <code>UPDATE</code> 语句。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsSelectForUpdate() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持位置的 <code>SELECT FOR UPDATE</code> 语句。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsStoredProcedures() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持使用存储过程转义语法的存储过程调用。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsSubqueriesInComparisons() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持比较表达式中的子查询。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsSubqueriesInExists() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持 <code>EXISTS</code> 表达式中的子查询。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsSubqueriesInIns() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持 <code>IN</code> 表达式中的子查询。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsSubqueriesInQuantifieds() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持量化表达式 (quantified expression) 中的子查询。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsCorrelatedSubqueries() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持相关子查询。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsUnion() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持 SQL <code>UNION</code>。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsUnionAll() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持 SQL <code>UNION ALL</code>。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsOpenCursorsAcrossCommit() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持在进行提交期间保持游标开放。 
 
@return 如果游标总是保持开放，则返回 <code>true</code>；如果游标可能无法保持开放，则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsOpenCursorsAcrossRollback() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持在回滚期间保持游标开放。
 
@return 如果游标总是保持开放，则返回 <code>true</code>；如果游标可能无法保持开放，则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsOpenStatementsAcrossCommit() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持在进行提交期间保持语句开放。
 
@return 如果语句总是保持开放，则返回 <code>true</code>；如果游标可能无法保持开放，则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsOpenStatementsAcrossRollback() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持在回滚期间保持语句开放。
 
@return 如果语句总是保持开放，则返回 <code>true</code>；如果游标可能无法保持开放，则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxBinaryLiteralLength() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许在内嵌二进制字面值中使用的最大十六进制字符数。

@return max，即用于二进制字面值的最大长度（十六进制字符形式）；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxCharLiteralLength() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许用于字符字面值的最大字符数。

@return 允许用于字符字面值的最大字符数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxColumnNameLength() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许用于列名称的最大字符数。

@return 允许用于列名称的最大字符数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxColumnsInGroupBy() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许在 <code>GROUP BY</code> 子句中使用的最大列数。

@return 所允许的最大列数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxColumnsInIndex() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许在索引中使用的最大列数。

@return 所允许的最大列数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxColumnsInOrderBy() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许在 <code>ORDER BY</code> 子句中使用的最大列数。

@return 所允许的最大列数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxColumnsInSelect() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许在 <code>SELECT</code> 列表中使用的最大列数。

@return 所允许的最大列数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxColumnsInTable() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许在表中使用的最大列数。

@return 所允许的最大列数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxConnections() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取连接到此数据库的并发连接的可能最大数。

@return 在某一时间可能的活动连接的最大数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxCursorNameLength() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许用于游标名称的最大字符数。

@return 允许用于游标名称的最大字符数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxIndexLength() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许用于索引（包括索引的所有部分）的最大字节数。

@return 所允许的最大字节数；这一限制由该索引所有组成部分的组成；结果为零意味着没有限制或者限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxSchemaNameLength() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许在模式名称中使用的最大字符数。

@return 允许用于模式名称的最大字符数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxProcedureNameLength() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许用于过程名称的最大字符数。

@return 允许用于过程名称的最大字符数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxCatalogNameLength() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许用于类别名称的最大字符数。

@return 允许用于类别名称的最大字符数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxRowSize() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许在单行中使用的最大字节数。

@return 允许在行中使用的最大字节数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.doesMaxRowSizeIncludeBlobs() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取 <code>getMaxRowSize</code> 方法的返回值是否包括 SQL 数据类型 <code>LONGVARCHAR</code> 和 <code>LONGVARBINARY</code>。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxStatementLength() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许在 SQL 语句中使用的最大字符数。

@return 允许在 SQL 语句中使用的最大字符数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxStatements() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取在此数据库中在同一时间内可处于开放状态的最大活动语句数。

@return 在某一时间可同时处于开放状态的最大语句数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxTableNameLength() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许在表名称中使用的最大字符数。

@return 允许用于表名称的最大字符数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxTablesInSelect() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许在 <code>SELECT</code> 语句中使用的表的最大数量。

@return 允许在 <code>SELECT</code> 语句中使用的表的最大数量；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getMaxUserNameLength() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库允许在用户名称中使用的最大字符数。

@return 允许用于用户名称的最大字符数；结果为零意味着没有限制或限制是未知的
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getDefaultTransactionIsolation() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库的默认事务隔离级别。<code>java.sql.Connection</code> 中定义了一些可能值。

@return 默认隔离级别
@exception SQLException 如果发生数据库访问错误
@see Connection

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsTransactions() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持事务。如果不支持，则调用 <code>commit</code> 方法是无操作 (noop)，并且隔离级别是 <code>TRANSACTION_NONE</code>。

@return 如果事务受支持，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsTransactionIsolationLevel(int level) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持给定事务隔离级别。

@param level <code>java.sql.Connection</code> 中定义的事务隔离级别之一
@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@see Connection

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsDataDefinitionAndDataManipulationTransactions() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否同时支持事务中的数据定义和数据操作语句。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsDataManipulationTransactionsOnly() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否仅支持事务中的数据操作语句。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.dataDefinitionCausesTransactionCommit() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取事务中的数据定义语句是否强迫该事务进行提交。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.dataDefinitionIgnoredInTransactions() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否忽略事务中的数据定义语句。

@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getProcedures(String catalog, String schemaPattern, String procedureNamePattern) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取可在给定类别中使用的存储过程的描述。
 <P>
仅返回与模式和过程名称标准匹配的过程。它们根据 <code>PROCEDURE_CAT</code>、<code>PROCEDURE_SCHEM</code>、<code>PROCEDURE_NAME</code> 和 <code>SPECIFIC_ NAME</code> 进行排序。

<P>每个过程描述都有以下列：
  <OL>
	<LI><B>PROCEDURE_CAT</B> String =&gt; 过程类别（可为 <code>null</code>）
	<LI><B>PROCEDURE_SCHEM</B> String =&gt; 过程模式（可为 <code>null</code>）
	<LI><B>PROCEDURE_NAME</B> String =&gt; 过程名称
<LI> 保留供以后使用
<LI> 保留供以后使用
<LI> 保留供以后使用
	<LI><B>REMARKS</B> String =&gt; 过程的解释性注释
	<LI><B>PROCEDURE_TYPE</B> short =&gt; 过程的种类：
      <UL>
      <LI> procedureResultUnknown - 不能确定是否将返回一个返回值。
      <LI> procedureNoResult - 不返回一个返回值
      <LI> procedureReturnsResult - 返回一个返回值
      </UL>
	<LI><B>SPECIFIC_NAME</B> String  => 唯一标识其模式中此过程的名称。
  </OL>
 <p>
用户可能不具有执行 <code>getProcedures</code> 返回的所有过程的权限

@param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；该参数为 &quot;&quot; 表示获取没有类别的那些描述；为 <code>null</code> 则表示该类别名称不应该用于缩小搜索范围
@param schemaPattern 模式名称的模式；它必须与存储在数据库中的模式名称匹配；该参数为 &quot;&quot; 表示获取没有模式的那些描述；为 <code>null</code> 则表示该模式名称不应该用于缩小搜索范围
@param procedureNamePattern 过程名称模式；它必须与存储在数据库中的过程名称匹配
@return <code>ResultSet</code> - 每个行都是一个过程描述
@exception SQLException 如果发生数据库访问错误
@see #getSearchStringEscape 

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getProcedureColumns(String catalog, String schemaPattern, String procedureNamePattern, String columnNamePattern) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取给定类别的存储过程参数和结果列的描述。

<P>仅返回与模式、过程和参数名称标准匹配的描述。它们根据 PROCEDURE_CAT、PROCEDURE_SCHEM、PROCEDURE_NAME 和 SPECIFIC_NAME 进行排序。在此排序中，返回值（如果有）排在最前面。接着是参数描述，它们按调用顺序排序。然后是列描述，它们按列编号顺序进行排序。

<P><code>ResultSet</code> 中的每个行都是带以下字段的参数描述或列描述：
  <OL>
	<LI><B>PROCEDURE_CAT</B> String =&gt; 过程类别（可为 <code>null</code>）
	<LI><B>PROCEDURE_SCHEM</B> String =&gt; 过程模式（可为 <code>null</code>）
	<LI><B>PROCEDURE_NAME</B> String =&gt; 过程名称
	<LI><B>COLUMN_NAME</B> String =&gt; 列/参数名称 
	<LI><B>COLUMN_TYPE</B> Short =&gt; 列/参数的种类：
      <UL>
<LI> procedureColumnUnknown - 没人知道
<LI> procedureColumnIn - IN 参数
<LI> procedureColumnInOut - INOUT 参数
<LI> procedureColumnOut - OUT 参数
<LI> procedureColumnReturn - 过程返回值
<LI> procedureColumnResult - <code>ResultSet</code> 中的结果列
      </UL>
<LI><B>DATA_TYPE</B> int =&gt; 来自 java.sql.Types 的 SQL 类型
	<LI><B>TYPE_NAME</B> String =&gt; SQL 类型名称，对于 UDT 类型，类型名称是完全限定的
	<LI><B>PRECISION</B> int =&gt; 精度
	<LI><B>LENGTH</B> int =&gt; 数据的长度，以字节为单位
	<LI><B>SCALE</B> short => scale -  对于 SCALE 不适用的数据类型返回 null。
	<LI><B>RADIX</B> short =&gt; 基数
	<LI><B>NULLABLE</B> short =&gt; 是否可以包含 NULL。
      <UL>
<LI> procedureNoNulls - 不允许使用 NULL 值
<LI> procedureNullable - 允许使用 NULL 值
<LI> procedureNullableUnknown - 不知道是否可使用 null
      </UL>
	<LI><B>REMARKS</B> String =&gt; 描述参数/列的注释
 	<LI><B>COLUMN_DEF</B> String => 列的默认值，当该值在单引号内时被解释为一个字符串（可以为 <code>null</code>）
      <UL>
      <LI> 字符串 NULL（不在引号内）- 如果 NULL 作为默认值指定
      <LI> TRUNCATE（不在引号内）        - 如果指定的默认值截取后才能被表示
      <LI> NULL                                     - 如果没有指定默认值
      </UL>
	<LI><B>SQL_DATA_TYPE</B> int  => 保留供以后使用
	<LI><B>SQL_DATETIME_SUB</B> int  => 保留供以后使用
	<LI><B>CHAR_OCTET_LENGTH</B> int  => 基于二进制和字符的列的最大长度。对于任何其他数据类型，返回值为 NULL
	<LI><B>ORDINAL_POSITION</B> int  => 顺序位置，对于过程的输入和输出参数该位置从 1 开始。如果此行描述过程的返回值，则返回值 0。对于结果集列，它是从 1 开始的结果集中列的顺序位置。如果有多个结果集，则列顺序位置是已定义的实现。
	<LI><B>IS_NULLABLE</B> String  => ISO 规则用于确定列是否可以包括 null。 
       <UL>
       <LI> YES           --- 如果参数可以包括 NULL
       <LI> NO            --- 如果参数不可以包括 NULL
       <LI> 空字符串       --- 如果不知道参数是否可以包括 Null 
       </UL>
	<LI><B>SPECIFIC_NAME</B> String  => 唯一标识其模式中此过程的名称。
  </OL>

<P><B>注：</B>有些数据库可能不为过程返回列描述。

<p>PRECISION 列表示给定列的指定列大小。对于数值数据，这是最大精度。对于字符数据，这是字符长度。对于日期时间数据类型，这是 String 表示形式的字符长度（假定允许的最大小数秒组件的精度）。对于二进制数据，这是字节长度。对于 ROWID 数据类型，这是字节长度。对于列大小不适用的数据类型，则返回 Null。 
@param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；该参数为 &quot;&quot; 则获取没有类别的描述，表示获取没有类别的那些描述；为  <code>null</code> 则表示该类别名称不应该用于缩小搜索范围
@param schemaPattern 模式名称的模式；它必须与存储在数据库中的模式名称匹配；该参数为 &quot;&quot; 表示获取没有模式的那些描述；为  <code>null</code> 则表示该模式名称不应该用于缩小搜索范围
@param procedureNamePattern 过程名称模式；它必须与存储在数据库中的过程名称匹配
@param columnNamePattern 列名称模式；它必须与存储在数据库中的列名称匹配
@return <code>ResultSet</code> - 每一行都描述一个存储过程参数或列
@exception SQLException 如果发生数据库访问错误
@see #getSearchStringEscape

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getTables(String catalog, String schemaPattern, String tableNamePattern, java.lang.String[] types) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取可在给定类别中使用的表的描述。仅返回与类别、模式、表名称和类型标准匹配的表描述。它们根据 <code>TABLE_TYPE</code>、<code>TABLE_CAT</code>、<code>TABLE_SCHEM</code> 和 <code>TABLE_NAME</code> 进行排序。
 <P>
每个表描述都有以下列：
  <OL>
	<LI><B>TABLE_CAT</B> String =&gt; 表类别（可为 <code>null</code>）
	<LI><B>TABLE_SCHEM</B> String =&gt; 表模式（可为 <code>null</code>）
	<LI><B>TABLE_NAME</B> String =&gt; 表名称
	<LI><B>TABLE_TYPE</B> String =&gt; 表类型。典型的类型是 &quot;TABLE&quot;、&quot;VIEW&quot;、&quot;SYSTEM TABLE&quot;、&quot;GLOBAL TEMPORARY&quot;、&quot;LOCAL TEMPORARY&quot;、&quot;ALIAS&quot; 和 &quot;SYNONYM&quot;。	
	<LI><B>REMARKS</B> String =&gt; 表的解释性注释
<LI><B>TYPE_CAT</B> String =&gt; 类型的类别（可为 <code>null</code>）
<LI><B>TYPE_SCHEM</B> String =&gt; 类型模式（可为 <code>null</code>）
<LI><B>TYPE_NAME</B> String =&gt; 类型名称（可为 <code>null</code>）
<LI><B>SELF_REFERENCING_COL_NAME</B> String =&gt; 有类型表的指定 &quot;identifier&quot; 列的名称（可为 <code>null</code>）
	<LI><B>REF_GENERATION</B> String =&gt; 指定在 SELF_REFERENCING_COL_NAME 中创建值的方式。这些值为 &quot;SYSTEM&quot;、&quot;USER&quot; 和 &quot;DERIVED&quot;。（可能为 <code>null</code>）	
  </OL>

<P><B>注：</B> 有些数据库可能不返回用于所有表的信息。

@param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；该参数为 &quot;&quot; 表示获取没有类别的那些描述；为 <code>null</code> 则表示该类别名称不应该用于缩小搜索范围
@param schemaPattern 模式名称的模式；它必须与存储在数据库中的模式名称匹配；该参数为 &quot;&quot; 表示获取没有模式的那些描述；为  <code>null</code> 则表示该模式名称不应该用于缩小搜索范围
@param tableNamePattern 表名称模式；它必须与存储在数据库中的表名称匹配
@param types 要包括的表类型所组成的列表，必须取自从 {@link #getTableTypes} 返回的表类型列表；<code>null</code> 表示返回所有类型
@return <code>ResultSet</code> - 每一行都是一个表描述
@exception SQLException 如果发生数据库访问错误
@see #getSearchStringEscape 

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getSchemas() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取可在此数据库中使用的模式名称。可根据 <code>TABLE_CATALOG</code> 和 <code>TABLE_SCHEM</code> 对结果进行排序。

<P>模式列为：
  <OL>
	<LI><B>TABLE_SCHEM</B> String =&gt; 模式名称
<LI><B>TABLE_CATALOG</B> String =&gt; 类别名称（可为 <code>null</code>）
  </OL>

@return <code>ResultSet</code> 对象，在该对象中，每一行都是一个模式描述
@exception SQLException 如果发生数据库访问错误


<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getCatalogs() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取可在此数据库中使用的类别名称。可根据类别名称对结果进行排序。

<P>类别列为：
  <OL>
	<LI><B>TABLE_CAT</B> String =&gt; 类别名称
  </OL>

@return <code>ResultSet</code> 对象，在该对象中，每一行都有一个作为类别名称的 <code>String</code> 列
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getTableTypes() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取可在此数据库中使用的表类型。可根据表类型对结果进行排序。

<P>表类型为：
  <OL>
	<LI><B>TABLE_TYPE</B> String =&gt; 表类型。典型的类型为 &quot;TABLE&quot;、&quot;VIEW&quot;、&quot;SYSTEM TABLE&quot;、&quot;GLOBAL TEMPORARY&quot;、&quot;LOCAL TEMPORARY&quot;、&quot;ALIAS&quot; 和 &quot;SYNONYM&quot;。	
  </OL>

@return <code>ResultSet</code> 对象，在该对象中，每一行都有一个作为表类型的 <code>String</code> 列
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取可在指定类别中使用的表列的描述。

<P>仅返回与类别、模式、表和列名称标准匹配的列描述。它们根据 <code>TABLE_CAT</code>、<code>TABLE_SCHEM</code>、<code>TABLE_NAME</code> 和 <code>ORDINAL_POSITION</code> 进行排序。

<P>每个列描述都有以下列：
  <OL>
	<LI><B>TABLE_CAT</B> String =&gt; 表类别（可为 <code>null</code>）
	<LI><B>TABLE_SCHEM</B> String =&gt; 表模式（可为 <code>null</code>）
	<LI><B>TABLE_NAME</B> String =&gt; 表名称
	<LI><B>COLUMN_NAME</B> String =&gt; 列名称
	<LI><B>DATA_TYPE</B> int =&gt; 来自 java.sql.Types 的 SQL 类型
	<LI><B>TYPE_NAME</B> String =&gt; 数据源依赖的类型名称，对于 UDT，该类型名称是完全限定的
	<LI><B>COLUMN_SIZE</B> int =&gt; 列的大小。
	<LI><B>BUFFER_LENGTH</B> 未被使用。
	<LI><B>DECIMAL_DIGITS</B> int =&gt; 小数部分的位数。对于 DECIMAL_DIGITS 不适用的数据类型，则返回 Null。 
	<LI><B>NUM_PREC_RADIX</B> int =&gt; 基数（通常为 10 或 2）
	<LI><B>NULLABLE</B> int =&gt; 是否允许使用 NULL。
      <UL>
<LI> columnNoNulls - 可能不允许使用 <code>NULL</code> 值
<LI> columnNullable - 明确允许使用 <code>NULL</code> 值
<LI> columnNullableUnknown - 不知道是否可使用 null
      </UL>
	<LI><B>REMARKS</B> String =&gt; 描述列的注释（可为 <code>null</code>）
	<LI><B>COLUMN_DEF</B> String =&gt; 该列的默认值，当值在单引号内时应被解释为一个字符串（可为 <code>null</code>）
	<LI><B>SQL_DATA_TYPE</B> int =&gt; 未使用
	<LI><B>SQL_DATETIME_SUB</B> int =&gt; 未使用
	<LI><B>CHAR_OCTET_LENGTH</B> int =&gt; 对于 char 类型，该长度是列中的最大字节数
	<LI><B>ORDINAL_POSITION</B> int	=&gt; 表中的列的索引（从 1 开始）
	<LI><B>IS_NULLABLE</B> String =&gt; ISO 规则用于确定列是否包括 null。 
       <UL>
       <LI> YES           --- 如果参数可以包括 NULL
       <LI> NO            --- 如果参数不可以包括 NULL
       <LI> 空字符串      --- 如果不知道参数是否可以包括 null
       </UL>
<LI><B>SCOPE_CATLOG</B> String =&gt; 表的类别，它是引用属性的作用域（如果 DATA_TYPE 不是 REF，则为 <code>null</code>）
<LI><B>SCOPE_SCHEMA</B> String =&gt; 表的模式，它是引用属性的作用域（如果 DATA_TYPE 不是 REF，则为 <code>null</code>）
<LI><B>SCOPE_TABLE</B> String =&gt; 表名称，它是引用属性的作用域（如果 DATA_TYPE 不是 REF，则为 <code>null</code>）
<LI><B>SOURCE_DATA_TYPE</B> short =&gt; 不同类型或用户生成 Ref 类型、来自 java.sql.Types 的 SQL 类型的源类型（如果 DATA_TYPE 不是 DISTINCT 或用户生成的 REF，则为 <code>null</code>）
   <LI><B>IS_AUTOINCREMENT</B> String  => 指示此列是否自动增加
       <UL>
       <LI> YES           --- 如果该列自动增加
       <LI> NO            --- 如果该列不自动增加
       <LI> 空字符串       --- 如果不能确定该列是否是自动增加参数
       </UL>
  </OL>

<p>COLUMN_SIZE 列表示给定列的指定列大小。对于数值数据，这是最大精度。对于字符数据，这是字符长度。对于日期时间数据类型，这是 String 表示形式的字符长度（假定允许的最大小数秒组件的精度）。对于二进制数据，这是字节长度。对于 ROWID 数据类型，这是字节长度。对于列大小不适用的数据类型，则返回 Null。 

@param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；该参数为 &quot;&quot; 表示获取没有类别的那些描述；为 <code>null</code> 则表示该类别名称不应该用于缩小搜索范围
@param schemaPattern 模式名称的模式；它必须与存储在数据库中的模式名称匹配；该参数为 &quot;&quot; 表示获取没有模式的那些描述；为 <code>null</code> 则表示该模式名称不应该用于缩小搜索范围
@param tableNamePattern 表名称模式；它必须与存储在数据库中的表名称匹配
@param columnNamePattern 列名称模式；它必须与存储在数据库中的列名称匹配
@return <code>ResultSet</code> - 每一行都是一个列描述
@exception SQLException 如果发生数据库访问错误
@see #getSearchStringEscape

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getColumnPrivileges(String catalog, String schema, String table, String columnNamePattern) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取用于表列的访问权的描述。

<P>仅返回与列名称标准匹配的特权。它们根据 COLUMN_NAME 和 PRIVILEGE 进行排序。

<P>每个特权描述都有以下列：
  <OL>
	<LI><B>TABLE_CAT</B> String =&gt; 表类别（可为 <code>null</code>）
	<LI><B>TABLE_SCHEM</B> String =&gt; 表模式（可为 <code>null</code>）
	<LI><B>TABLE_NAME</B> String =&gt; 表名称
	<LI><B>COLUMN_NAME</B> String =&gt; 列名称
	<LI><B>GRANTOR</B> String =&gt; 访问权的授权人（可为 <code>null</code>）
	<LI><B>GRANTEE</B> String =&gt; 访问权的被授权人
	<LI><B>PRIVILEGE</B> String =&gt; 访问权的名称（SELECT、INSERT、UPDATE、REFRENCES 等）
	<LI><B>IS_GRANTABLE</B> String =&gt; 如果允许被授权人将权利授予他人，则为 &quot;YES&quot;；如果不允许，则为 &quot;NO&quot;；如果未知，则为 <code>null</code>
  </OL>

@param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；该参数为 &quot;&quot; 表示获取没有类别的那些描述；为 <code>null</code> 则表示该类别名称不应该用于缩小搜索范围
@param schema 模式名称；它必须与存储在数据库中的模式名称匹配；该参数为 &quot;&quot; 表示获取没有模式的那
些描述；为  <code>null</code> 则表示该模式名称不应该用于缩小搜索范围
@param table 表名称；它必须与存储在数据库中的表名称匹配
@param columnNamePattern 列名称模式；它必须与存储在数据库中的列名称匹配
@return <code>ResultSet</code> - 每一行都是一个列特权描述
@exception SQLException 如果发生数据库访问错误
@see #getSearchStringEscape

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getTablePrivileges(String catalog, String schemaPattern, String tableNamePattern) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取可在类别中使用的每个表的访问权的描述。注意，表特权可用于表中的一个或多个列。假定此特权可用于所有列是错误的（对于某些系统可能是正确的，但并非所有的系统都如此）。

<P>仅返回与模式和表名称标准匹配的特权。它们根据 <code>TABLE_CAT</code>、<code>TABLE_SCHEM</code>、<code>TABLE_NAME</code> 和 <code>PRIVILEGE</code> 进行排序。

<P>每个特权描述都有以下列：
  <OL>
	<LI><B>TABLE_CAT</B> String =&gt; 表类别（可为 <code>null</code>）
	<LI><B>TABLE_SCHEM</B> String =&gt; 表模式（可为 <code>null</code>）
	<LI><B>TABLE_NAME</B> String =&gt; 表名称
	<LI><B>GRANTOR</B> String =&gt; 访问权的授权人（可为 <code>null</code>）
	<LI><B>GRANTEE</B> String =&gt; 访问权的被授权人
	<LI><B>PRIVILEGE</B> String =&gt; 访问权的名称（SELECT、INSERT、UPDATE、REFRENCES 等）
	<LI><B>IS_GRANTABLE</B> String =&gt; 如果允许被授权人将权利授予他人，则为 &quot;YES&quot;；如果不允许，则为 &quot;NO&quot;；如果未知，则为 <code>null</code>
  </OL>

@param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；该参数为 &quot;&quot; 表示获取没有类别的那些描述；为 <code>null</code> 则表示该类别名称不应该用于缩小搜索范围
@param schemaPattern 模式名称的模式；它必须与存储在数据库中的模式名称匹配；该参数为 &quot;&quot; 表示获取没有模式的那些描述；为 <code>null</code> 则表示该模式名称不应该用于缩小搜索范围
@param tableNamePattern 表名称模式；它必须与存储在数据库中的表名称匹配
@return <code>ResultSet</code> - 每个行都是一个表特权描述
@exception SQLException 如果发生数据库访问错误
@see #getSearchStringEscape 

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getBestRowIdentifier(String catalog, String schema, String table, int scope, boolean nullable) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取唯一标识行的表的最佳列集合的描述。它们根据 SCOPE 进行排序。

<P>每个列描述都有以下列：
  <OL>
	<LI><B>SCOPE</B> short =&gt; 实际结果作用域
      <UL>
<LI> bestRowTemporary - 暂时性的，在使用行时使用
<LI> bestRowTransaction - 对当前事务的剩余部分有效
<LI> bestRowSession - 对当前会话的剩余部分有效
      </UL>
	<LI><B>COLUMN_NAME</B> String =&gt; 列名称
	<LI><B>DATA_TYPE</B> int =&gt; 来自 java.sql.Types 的 SQL 数据类型
	<LI><B>TYPE_NAME</B> String =&gt; 数据源依赖的类型名称，对于 UDT，该类型名称是完全限定的
	<LI><B>COLUMN_SIZE</B> int =&gt; 精度
	<LI><B>BUFFER_LENGTH</B> int =&gt; 未被使用
	<LI><B>DECIMAL_DIGITS</B> short	 =&gt; 标度，对于 DECIMAL_DIGITS 不适用的数据类型，则返回 Null。
	<LI><B>PSEUDO_COLUMN</B> short =&gt; 此是否为类似 Oracle ROWID 的伪列
      <UL>
<LI> bestRowUnknown - 可能是伪列，也可能不是
<LI> bestRowNotPseudo - &ldquo;不&rdquo;是伪列
<LI> bestRowPseudo - 是伪列
      </UL>
  </OL>

<p>COLUMN_SIZE 列表示给定列的指定列大小。对于数值数据，这是最大精度。对于字符数据，这是字符长度。对于日期时间数据类型，这是 String 表示形式字符长度（假定允许的最大小数秒组件的精度）。对于二进制数据，这是字节长度。对于 ROWID 数据类型，这是字节长度。对于列大小不适用的数据类型，则返回 Null。 

@param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；该参数为 &quot;&quot; 表示获取没有类别的那些描述；为 <code>null</code> 则表示该类别名称不应该用于缩小搜索范围
@param schema 模式名称；它必须与存储在数据库中的模式名称匹配；该参数为 &quot;&quot; 表示获取没有模式的那
些描述；为 <code>null</code> 则表示该模式名称不应该用于缩小搜索范围
@param table 表名称；它必须与存储在数据库中的表名称匹配
@param scope 感兴趣的作用域，可使用于 SCOPE 相同的值
@param nullable 包含可为 null 的列。
@return <code>ResultSet</code> - 每一行都是一个列描述
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getVersionColumns(String catalog, String schema, String table) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取在更新行中的任意值时自动更新的表列的描述。它们是无序的。

<P>每个列描述都有以下列：
  <OL>
	<LI><B>SCOPE</B> short =&gt; 未被使用
	<LI><B>COLUMN_NAME</B> String =&gt; 列名称
	<LI><B>DATA_TYPE</B> int =&gt; 来自 <code>java.sql.Types</code> 的 SQL 数据类型
	<LI><B>TYPE_NAME</B> String =&gt; 依赖数据源的类型名称
	<LI><B>COLUMN_SIZE</B> int =&gt; 精度
	<LI><B>BUFFER_LENGTH</B> int =&gt; 列值的长度，以字节为单位
	<LI><B>DECIMAL_DIGITS</B> short	 =&gt; 标度，对于 DECIMAL_DIGITS 不适用的数据类型，则返回 Null。
	<LI><B>PSEUDO_COLUMN</B> short =&gt; 此是否为类似 Oracle ROWID 的伪列
      <UL>
<LI> versionColumnUnknown - 可能是伪列，也可能不是
<LI> versionColumnNotPseudo - &ldquo;不&rdquo;是伪列
<LI> versionColumnPseudo - 是伪列
      </UL>
  </OL>

 <p>COLUMN_SIZE 列表示给定列的指定列大小。对于数值数据，这是最大精度。对于字符数据，这是字符长度。对于日期时间数据类型，这是 String 表示形式字符长度（假定允许的最大小数秒组件的精度）。对于二进制数据，这是字节长度。对于 ROWID 数据类型，这是字节长度。对于列大小不适用的数据类型，则返回 Null。 

@param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；该参数为 &quot;&quot; 表示获取没有类别的那些描述；为 <code>null</code> 则表示该类别名称不应该用于缩小搜索范围
@param schema 模式名称；它必须与存储在数据库中的模式名称匹配；该参数为 &quot;&quot; 表示获取没有模式的那
些描述；为 <code>null</code> 则表示该模式名称不应该用于缩小搜索范围
@param table 表名称；它必须与存储在数据库中的表名称匹配
@return 一个 <code>ResultSet</code> 对象，在该对象中，每一行都是一个列描述
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getPrimaryKeys(String catalog, String schema, String table) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取对给定表的主键列的描述。它们根据 COLUMN_NAME 进行排序。

<P>每个主键列描述都有以下列：
  <OL>
	<LI><B>TABLE_CAT</B> String =&gt; 表类别（可为 <code>null</code>）
	<LI><B>TABLE_SCHEM</B> String =&gt; 表模式（可为 <code>null</code>）
	<LI><B>TABLE_NAME</B> String =&gt; 表名称
	<LI><B>COLUMN_NAME</B> String =&gt; 列名称
	<LI><B>KEY_SEQ</B> short =&gt; 主键中的序列号（值 1 表示主键中的第一列，值 2 表示主键中的第二列）。
	<LI><B>PK_NAME</B> String =&gt; 主键的名称（可为 <code>null</code>）
  </OL>

@param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；该参数为 &quot;&quot; 表示获取没有类别的那些描述；为 <code>null</code> 则表示该类别名称不应该用于缩小搜索范围
@param schema 模式名称；它必须与存储在数据库中的模式名称匹配；该参数为 &quot;&quot; 表示获取没有模式的那
些描述；为 <code>null</code> 则表示该模式名称不应该用于缩小搜索范围
@param table 表名称；它必须与存储在数据库中的表名称匹配
@return <code>ResultSet</code> - 每一行都是一个主键列描述
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getImportedKeys(String catalog, String schema, String table) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取由给定表的外键列（表导入的主键）引用的主键列的描述。它们根据 PKTABLE_CAT、PKTABLE_SCHEM、PKTABLE_NAME 和 KEY_SEQ 进行排序。

<P>每个主键列描述都有以下列：
  <OL>
	<LI><B>PKTABLE_CAT</B> String =&gt; 被导入的主键表类别（可为 <code>null</code>）
	<LI><B>PKTABLE_SCHEM</B> String =&gt; 被导入的主键表模式（可为 <code>null</code>）
	<LI><B>PKTABLE_NAME</B> String =&gt; 被导入的主键表名称
	<LI><B>PKCOLUMN_NAME</B> String =&gt; 被导入的主键列名称
	<LI><B>FKTABLE_CAT</B> String =&gt; 外键表类别（可为 <code>null</code>）
	<LI><B>FKTABLE_SCHEM</B> String =&gt; 外键表模式（可为 <code>null</code>）
	<LI><B>FKTABLE_NAME</B> String =&gt; 外键表名称
	<LI><B>FKCOLUMN_NAME</B> String =&gt; 外键列名称
	<LI><B>KEY_SEQ</B> short =&gt; 外键中的序列号（值 1 表示外键中的第一列，值 2 表示外键中的第二列）。
	<LI><B>UPDATE_RULE</B> short =&gt; 更新主键时外键发生的变化：
      <UL>
<LI> importedNoAction - 如果已经被导入，则不允许更新主键
<LI> importedKeyCascade - 将导入的键更改为与主键更新一致
<LI> importedKeySetNull - 如果已更新导入键的主键，则将导入键更改为 <code>NULL</code>
<LI> importedKeySetDefault - 如果已更新导入键的主键，则将导入键更改为默认值
<LI> importedKeyRestrict - 与 importedKeyNoAction 相同（为了与 ODBC 2.x 兼容）
      </UL>
	<LI><B>DELETE_RULE</B> short =&gt; 删除主键时外键发生的变化。
      <UL>
<LI> importedKeyNoAction - 如果已经导入，则不允许删除主键
<LI> importedKeyCascade - 删除导入删除键的行
<LI> importedKeySetNull - 如果已删除导入键的主键，则将导入键更改为 NULL
<LI> importedKeyRestrict - 与 importedKeyNoAction 相同（为了与 ODBC 2.x 兼容）
<LI> importedKeySetDefault - 如果已删除导入键的主键，则将导入键更改为默认值
      </UL>
	<LI><B>FK_NAME</B> String =&gt; 外键的名称（可为 <code>null</code>）
	<LI><B>PK_NAME</B> String =&gt; 主键的名称（可为 <code>null</code>）
	<LI><B>DEFERRABILITY</B> short =&gt; 是否可以将对外键约束的评估延迟到提交时间
      <UL>
<LI> importedKeyInitiallyDeferred - 有关定义，请参见 SQL92
<LI> importedKeyInitiallyImmediate - 有关定义，请参见 SQL92
<LI> importedKeyNotDeferrable - 有关定义，请参见 SQL92
      </UL>
  </OL>

@param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；该参数为 &quot;&quot; 表示获取没有类别的那些描述；为 <code>null</code> 则表示该类别名称不应该用于缩小搜索范围
@param schema 模式名称；它必须与存储在数据库中的模式名称匹配；该参数为 &quot;&quot; 表示获取没有模式的那
些描述；为 <code>null</code> 则表示该模式名称不应该用于缩小搜索范围
@param table 表名称；它必须与存储在数据库中的表名称匹配
@return <code>ResultSet</code> - 每一行都是一个主键列描述
@exception SQLException 如果发生数据库访问错误
@see #getExportedKeys

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getExportedKeys(String catalog, String schema, String table) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取引用给定表的主键列（表导入的外键）的外键列的描述。它们根据 FKTABLE_CAT、FKTABLE_SCHEM、FKTABLE_NAME 和 KEY_SEQ 进行排序。

<P>每个外键列描述都有以下列：
  <OL>
	<LI><B>PKTABLE_CAT</B> String =&gt; 主键表类别（可为 <code>null</code>）
	<LI><B>PKTABLE_SCHEM</B> String =&gt; 主键表模式（可为 <code>null</code>）
	<LI><B>PKTABLE_NAME</B> String =&gt; 主键表名称
	<LI><B>PKCOLUMN_NAME</B> String =&gt; 主键列名称
	<LI><B>FKTABLE_CAT</B> String =&gt; 被导入的外键表类别（可能为 <code>null</code>），该字符串可能为 <code>null</code>
	<LI><B>FKTABLE_SCHEM</B> String =&gt; 被导入的外键表模式（可能为 <code>null</code>），该字符串可能为 <code>null</code>
	<LI><B>FKTABLE_NAME</B> String =&gt; 被导入的外键表名称
	<LI><B>FKCOLUMN_NAME</B> String =&gt; 被导入的外键列名称
	<LI><B>KEY_SEQ</B> short =&gt; 外键中的序列号（值 1 表示外键中的第一列，值 2 表示外键中的第二列）。
	<LI><B>UPDATE_RULE</B> short =&gt; 更新主键时外键发生的变化：
      <UL>
<LI> importedNoAction - 如果已经导入，则不允许更新主键
<LI> importedKeyCascade - 将导入的键更改为与主键更新一致
<LI> importedKeySetNull - 如果已更新导入键的主键，则将导入键更改为 <code>NULL</code>
<LI> importedKeySetDefault - 如果已更新导入键的主键，则将导入键更改为默认值
<LI> importedKeyRestrict - 与 importedKeyNoAction 相同（为了与 ODBC 2.x 兼容）
      </UL>
	<LI><B>DELETE_RULE</B> short =&gt; 删除主键时外键发生的变化。
      <UL>
<LI> importedKeyNoAction - 如果已经导入，则不允许删除主键
<LI> importedKeyCascade - 删除导入删除键的行
<LI> importedKeySetNull - 如果已删除导入键的主键，则将导入键更改为 <code>NULL</code>
<LI> importedKeyRestrict - 与 importedKeyNoAction 相同（为了与 ODBC 2.x 兼容）
<LI> importedKeySetDefault - 如果已删除导入键的主键，则将导入键更改为默认值
      </UL>
	<LI><B>FK_NAME</B> String =&gt; 外键的名称（可为 <code>null</code>）
	<LI><B>PK_NAME</B> String =&gt; 主键的名称（可为 <code>null</code>）
	<LI><B>DEFERRABILITY</B> short =&gt; 是否可以将对外键约束的评估延迟到提交时间
      <UL>
<LI> importedKeyInitiallyDeferred - 有关定义，请参见 SQL92
<LI> importedKeyInitiallyImmediate - 有关定义，请参见 SQL92
<LI> importedKeyNotDeferrable - 有关定义，请参见 SQL92
      </UL>
  </OL>

@param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；该参数为 &quot;&quot; 表示获取没有类别的那些描述；为 <code>null</code> 则表示该类别名称不应该用于缩小搜索范围
@param schema 模式名称；它必须与存储在数据库中的模式名称匹配；该参数为 &quot;&quot; 表示获取没有模式的那
些描述；为 <code>null</code> 则表示该模式名称不应该用于缩小搜索范围
@param table 表名称；它必须与存储在数据库中的表名称匹配
@return 一个 <code>ResultSet</code> 对象，在该对象中，每一行都是一个外键列描述
@exception SQLException 如果发生数据库访问错误
@see #getImportedKeys 

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getCrossReference(String parentCatalog, String parentSchema, String parentTable, String foreignCatalog, String foreignSchema, String foreignTable) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取给定外键列表中外键列的描述，这些列引用主键或表示父表（可能是相同的表，也可能是不同的表）唯一约束的列。从父表返回的列数必须与组成外键的列数匹配。它们根据 FKTABLE_CAT、FKTABLE_SCHEM、FKTABLE_NAME 和 KEY_SEQ 进行排序。

<P>每个外键列描述都有以下列：
  <OL>
	<LI><B>PKTABLE_CAT</B> String =&gt; 父键表类别（可为 <code>null</code>）
	<LI><B>PKTABLE_SCHEM</B> String =&gt; 父键表模式（可为 <code>null</code>）
	<LI><B>PKTABLE_NAME</B> String =&gt; 父键表名称
	<LI><B>PKCOLUMN_NAME</B> String =&gt; 父键列名称
	<LI><B>FKTABLE_CAT</B> String =&gt; 被导入的外键表类别（可能为 <code>null</code>），该字符串可能为 <code>null</code>
	<LI><B>FKTABLE_SCHEM</B> String =&gt; 被导入的外键表模式（可能为 <code>null</code>），该字符串可能为 <code>null</code>
	<LI><B>FKTABLE_NAME</B> String =&gt; 被导入的外键表名称
	<LI><B>FKCOLUMN_NAME</B> String =&gt; 被导入的外键列名称
	<LI><B>KEY_SEQ</B> short =&gt; 外键中的序列号（值 1 表示外键中的第一列，值 2 表示外键中的第二列）。
	<LI><B>UPDATE_RULE</B> short =&gt; 更新父键时外键发生的变化：
      <UL>
<LI> importedNoAction - 如果已经导入，则不允许更新父键
<LI> importedKeyCascade - 将导入的键更改为与父键更新一致
<LI> importedKeySetNull - 如果已更新导入键的父键，则将导入键更改为 <code>NULL</code>
<LI> importedKeySetDefault - 如果已更新导入键的父键，则将导入键更改为默认值
<LI> importedKeyRestrict - 与 importedKeyNoAction 相同（为了与 ODBC 2.x 兼容）
      </UL>
	<LI><B>DELETE_RULE</B> short =&gt; 删除父键时外键发生的变化。
      <UL>
<LI> importedKeyNoAction - 如果已经导入，则不允许删除父键
<LI> importedKeyCascade - 删除导入删除键的行
<LI> importedKeySetNull - 如果已删除导入键的主键，则将导入键更改为 <code>NULL</code>
<LI> importedKeyRestrict - 与 importedKeyNoAction 相同（为了与 ODBC 2.x 兼容）
<LI> importedKeySetDefault - 如果已删除导入键的父键，则将导入键更改为默认值
      </UL>
	<LI><B>FK_NAME</B> String =&gt; 外键的名称（可为 <code>null</code>）
	<LI><B>PK_NAME</B> String =&gt; 父键的名称（可为 <code>null</code>）
	<LI><B>DEFERRABILITY</B> short =&gt; 是否可以将对外键约束的评估延迟到提交时间
      <UL>
<LI> importedKeyInitiallyDeferred - 有关定义，请参见 SQL92
<LI> importedKeyInitiallyImmediate - 有关定义，请参见 SQL92
<LI> importedKeyNotDeferrable - 有关定义，请参见 SQL92
      </UL>
  </OL>

@param parentCatalog 类别名称；它必须与存储在数据库中的类别名称匹配；该参数为 &quot;&quot; 表示获取没有类别的那些描述；为 <code>null</code> 则表示该类别名称不应该用于缩小搜索范围
@param parentSchema 模式名称；它必须与存储在数据库中的模式名称匹配；该参数为 &quot;&quot; 表示获取没有模式的那些描述；为 <code>null</code> 则表示该模式名称不应该用于缩小搜索范围
@param parentTable 导出该键的表的名称；它必须与存储在数据库中的表名称匹配
@param foreignCatalog 类别名称；它必须与存储在数据库中的类别名称匹配；该参数为 &quot;&quot; 则获取没有类别的那些描述，为 <code>null</code> 则表示从选择标准中删除类别名称
@param foreignSchema 模式名称；它必须与存储在数据库中的模式名称匹配；该参数为 &quot;&quot; 表示获取那些没有模式的描述，为 <code>null</code> 则表示从选择标准中删除模式名称
@param foreignTable 导入该键的表的名称；它必须与存储在数据库中的表名称匹配
@return <code>ResultSet</code> - 每一行是一个外键列描述
@exception SQLException 如果发生数据库访问错误
@see #getImportedKeys 

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getTypeInfo() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库支持的所有数据类型的描述。它们先按照 DATA_TYPE 排序，然后按照数据类型映射表与相应的 JDBC SQL 类型的接近程度排序。

<P>如果数据库支持 SQL 独特类型，则 getTypeInfo() 将返回一行类型为 DISTINCT 的 TYPE_NAME 和类型为 Types.DISTINCT 的 DATA_TYPE。如果数据库支持 SQL 结构类型，则 getTypeInfo() 将会返回一行类型为 STRUCT 的 TYPE_NAME 和类型为 Types.STRUCT 的 DATA_TYPE。

<P>如果支持 SQL 独特类型和结构类型，则每种类型的信息可以从 getUDTs() 方法获得。



<P>每个类型描述都有以下列：
  <OL>
	<LI><B>TYPE_NAME</B> String =&gt; 类型名称
	<LI><B>DATA_TYPE</B> int =&gt; 来自 java.sql.Types 的 SQL 数据类型
	<LI><B>PRECISION</B> int =&gt; 最大精度
	<LI><B>LITERAL_PREFIX</B> String =&gt; 用于引用字面值的前缀（可为 <code>null</code>）
	<LI><B>LITERAL_SUFFIX</B> String =&gt; 用于引用字面值的后缀（可为 <code>null</code>）
	<LI><B>CREATE_PARAMS</B> String =&gt; 用于创建类型的参数（可为 <code>null</code>）
	<LI><B>NULLABLE</B> short =&gt; 是否可对此类型使用 NULL。
      <UL>
<LI> typeNoNulls - 不允许使用 NULL 值
<LI> typeNullable - 允许使用 NULL 值
<LI> typeNullableUnknown - 不知道是否可使用 null
      </UL>
	<LI><B>CASE_SENSITIVE</B> boolean=&gt; 是否区分大小写。
	<LI><B>SEARCHABLE</B> short =&gt; 是否可以基于此类型使用 &quot;WHERE&quot;：
      <UL>
<LI> typePredNone - 不支持
<LI> typePredChar - 仅支持 WHERE ..LIKE 
<LI> typePredBasic - 除 WHERE ..LIKE 以外都受支持 
<LI> typeSearchable - 所有 WHERE ..都受支持
      </UL>
	<LI><B>UNSIGNED_ATTRIBUTE</B> boolean =&gt; 是否不带符号。
	<LI><B>FIXED_PREC_SCALE</B> boolean =&gt; 是否可以为钱币值。
	<LI><B>AUTO_INCREMENT</B> boolean =&gt; 是否可以用于自动增量值。
	<LI><B>LOCAL_TYPE_NAME</B> String =&gt; 类型名称的本地版（可为 <code>null</code>）
	<LI><B>MINIMUM_SCALE</B> short =&gt; 受支持的最小标度
	<LI><B>MAXIMUM_SCALE</B> short =&gt; 受支持的最大标度
	<LI><B>SQL_DATA_TYPE</B> int =&gt; 未被使用
	<LI><B>SQL_DATETIME_SUB</B> int =&gt; 未被使用
	<LI><B>NUM_PREC_RADIX</B> int =&gt; 通常为 2 或 10
  </OL>

<p>对于给定数据类型，PRECISION 列表示服务器支持的最大列大小。对于数值数据，这是最大精度。对于字符数据，这是字符长度。对于日期时间数据类型，这是 String 表示形式的字符长度（假定允许的最大小数秒组件的精度）。对于二进制数据，这是字节长度。对于 ROWID 数据类型，这是字节长度。对于列大小不适用的数据类型，则返回 Null。

@return <code>ResultSet</code> 对象，在此对象中，每一行都是一个 SQL 类型描述
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getIndexInfo(String catalog, String schema, String table, boolean unique, boolean approximate) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取给定表的索引和统计信息的描述。它们根据 NON_UNIQUE、TYPE、INDEX_NAME 和 ORDINAL_POSITION 进行排序。

<P>每个索引列描述都有以下列：
  <OL>
	<LI><B>TABLE_CAT</B> String =&gt; 表类别（可为 <code>null</code>）
	<LI><B>TABLE_SCHEM</B> String =&gt; 表模式（可为 <code>null</code>）
	<LI><B>TABLE_NAME</B> String =&gt; 表名称
	<LI><B>NON_UNIQUE</B> boolean =&gt; 索引值是否可以不唯一。TYPE 为 tableIndexStatistic 时索引值为 false
	<LI><B>INDEX_QUALIFIER</B> String =&gt; 索引类别（可为 <code>null</code>）；TYPE 为 tableIndexStatistic 时索引类别为 <code>null</code>
	<LI><B>INDEX_NAME</B> String =&gt; 索引名称；TYPE 为 tableIndexStatistic 时索引名称为 <code>null</code>
	<LI><B>TYPE</B> short =&gt; 索引类型：
      <UL>
<LI> tableIndexStatistic - 此标识与表的索引描述一起返回的表统计信息
<LI> tableIndexClustered - 此为集群索引
<LI> tableIndexHashed - 此为散列索引
<LI> tableIndexOther - 此为某种其他样式的索引
      </UL>
	<LI><B>ORDINAL_POSITION</B> short =&gt; 索引中的列序列号；TYPE 为 tableIndexStatistic 时该序列号为零
	<LI><B>COLUMN_NAME</B> String =&gt; 列名称；TYPE 为 tableIndexStatistic 时列名称为 <code>null</code>
	<LI><B>ASC_OR_DESC</B> String =&gt; 列排序序列，&quot;A&quot; =&gt; 升序，&quot;D&quot; =&gt; 降序，如果排序序列不受支持，可能为 <code>null</code>；TYPE 为 tableIndexStatistic 时排序序列为 <code>null</code>	
	<LI><B>CARDINALITY</B> int =&gt; TYPE 为 tableIndexStatistic 时，它是表中的行数；否则，它是索引中唯一值的数量。
	<LI><B>PAGES</B> int =&gt; TYPE 为  tableIndexStatisic 时，它是用于表的页数，否则它是用于当前索引的页数。
	<LI><B>FILTER_CONDITION</B> String =&gt; 过滤器条件，如果有的话。（可能为 <code>null</code>）
  </OL>

@param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；该参数为 &quot;&quot; 表示获取没有类别的那些描述；为 <code>null</code> 则表示该类别名称不应该用于缩小搜索范围
@param schema 模式名称；它必须与存储在数据库中的模式名称匹配；该参数为 &quot;&quot; 表示获取没有模式的那
些描述；为 <code>null</code> 则表示该模式名称不应该用于缩小搜索范围
@param table 表名称；它必须与存储在数据库中的表名称匹配
@param unique 该参数为 true 时，仅返回唯一值的索引；该参数为 false 时，返回所有索引，不管它们是否唯一
@param approximate 该参数为 true 时，允许结果是接近的数据值或这些数据值以外的值；该参数为 false 时，要求结果是精确结果
@return <code>ResultSet</code> - 每一行都是一个索引列描述
@exception SQLException 如果发生数据库访问错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsResultSetType(int type) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持给定结果集类型。

@param type 在 <code>java.sql.ResultSet</code> 中定义
@return 如果是这样，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@see Connection
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsResultSetConcurrency(int type, int concurrency) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持与给定结果集类型结合在一起的给定并发性类型。

@param type 在 <code>java.sql.ResultSet</code> 中定义
@param concurrency <code>java.sql.ResultSet</code> 中定义的类型
@return 如果支持，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@see Connection
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.ownUpdatesAreVisible(int type) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->

获取对于给定类型的 <code>ResultSet</code> 对象，结果集自身的更新是否可见。

@param type <code>ResultSet</code> 类型，它是 <code>ResultSet.TYPE_FORWARD_ONLY</code>、<code>ResultSet.TYPE_SCROLL_INSENSITIVE</code> 或 <code>ResultSet.TYPE_SCROLL_SENSITIVE</code> 之一
@return 如果更新对于给定结果集是可见的，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.ownDeletesAreVisible(int type) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取结果集自身的删除是否可见。

@param type <code>ResultSet</code> 类型，它是 <code>ResultSet.TYPE_FORWARD_ONLY</code>、<code>ResultSet.TYPE_SCROLL_INSENSITIVE</code> 或 <code>ResultSet.TYPE_SCROLL_SENSITIVE</code> 之一
@return 如果删除对于给定结果集是可见的，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.ownInsertsAreVisible(int type) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取结果集自身的插入是否可见。

@param type <code>ResultSet</code> 类型，它是 <code>ResultSet.TYPE_FORWARD_ONLY</code>、<code>ResultSet.TYPE_SCROLL_INSENSITIVE</code> 或 <code>ResultSet.TYPE_SCROLL_SENSITIVE</code> 之一
@return 如果插入对于给定结果集是可见的，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.othersUpdatesAreVisible(int type) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取由其他结果集类型进行的更新是否可见。

@param type <code>ResultSet</code> 类型，它是 <code>ResultSet.TYPE_FORWARD_ONLY</code>、<code>ResultSet.TYPE_SCROLL_INSENSITIVE</code> 或 <code>ResultSet.TYPE_SCROLL_SENSITIVE</code> 之一
@return 如果由其他结果集类型进行的更新对于给定结果集是可见的，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.othersDeletesAreVisible(int type) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取由其他结果集类型进行的删除是否可见。

@param type <code>ResultSet</code> 类型，它是 <code>ResultSet.TYPE_FORWARD_ONLY</code>、<code>ResultSet.TYPE_SCROLL_INSENSITIVE</code> 或 <code>ResultSet.TYPE_SCROLL_SENSITIVE</code> 之一
@return 如果由其他结果集类型进行的删除对于给定结果集是可见的，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.othersInsertsAreVisible(int type) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取由其他结果集类型进行的插入是否可见。

@param type <code>ResultSet</code> 类型，它是 <code>ResultSet.TYPE_FORWARD_ONLY</code>、<code>ResultSet.TYPE_SCROLL_INSENSITIVE</code> 或 <code>ResultSet.TYPE_SCROLL_SENSITIVE</code> 之一
@return 如果由其他结果集类型进行的插入对于给定结果集是可见的，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.updatesAreDetected(int type) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取是否可以通过调用 <code>ResultSet.rowUpdated</code> 方法检测可见行的更新。

@param type <code>ResultSet</code> 类型，它是 <code>ResultSet.TYPE_FORWARD_ONLY</code>、<code>ResultSet.TYPE_SCROLL_INSENSITIVE</code> 或 <code>ResultSet.TYPE_SCROLL_SENSITIVE</code> 之一
@return 如果根据结果集类型检测更改，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.deletesAreDetected(int type) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取是否可以通过调用 <code>ResultSet.rowDeleted</code> 方法检测可见行的删除。如果 <code>deletesAreDetected</code> 方法返回 <code>false</code>，则意味着从结果集中移除已删除的行。

@param type <code>ResultSet</code> 类型，它是 <code>ResultSet.TYPE_FORWARD_ONLY</code>、<code>ResultSet.TYPE_SCROLL_INSENSITIVE</code> 或 <code>ResultSet.TYPE_SCROLL_SENSITIVE</code> 之一
@return 如果根据给定结果集类型检测删除，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.insertsAreDetected(int type) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取是否可以通过调用 <code>ResultSet.rowInserted</code> 方法检测可见行的插入。

@param type <code>ResultSet</code> 类型，它是 <code>ResultSet.TYPE_FORWARD_ONLY</code>、<code>ResultSet.TYPE_SCROLL_INSENSITIVE</code> 或 <code>ResultSet.TYPE_SCROLL_SENSITIVE</code> 之一
@return 如果根据指定结果集类型检测更改，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsBatchUpdates() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持批量更新。

@return 如果此数据库支持批量更新，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getUDTs(String catalog, String schemaPattern, String typeNamePattern, int[] types) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取在特定模式中定义的用户定义类型 (UDT) 的描述。特定于模式的 UDT 可能具有类型 <code>JAVA_OBJECT</code>、<code>STRUCT</code> 或 <code>DISTINCT</code>。

<P>仅返回与类别、模式、类型名称和类型标准匹配的类型。它们根据 <code>DATA_TYPE</code>、<code>TYPE_CAT</code>、<code>TYPE_SCHEM</code>  和 <code>TYPE_NAME</code> 进行排序。类型名称参数可能为完全限定名称。在这种情况下，忽略 catalog 和 schemaPattern 参数。

<P>每个类型描述都有以下列：
  <OL>
	<LI><B>TYPE_CAT</B> String =&gt; 类型的类别（可为 <code>null</code>）
	<LI><B>TYPE_SCHEM</B> String =&gt; 类型的模式（可为 <code>null</code>）
	<LI><B>TYPE_NAME</B> String =&gt; 类型名称
<LI><B>CLASS_NAME</B> String =&gt; Java 类名称
	<LI><B>DATA_TYPE</B> int =&gt; 在 java.sql.Types 中定义的类型值，它是 JAVA_OBJECT、STRUCT 或 DISTINCT 之一
	<LI><B>REMARKS</B> String =&gt; 类型的解释性注释
<LI><B>BASE_TYPE</B> short =&gt; DISTINCT 类型或实现结构类型的 SELF_REFERENCING_COLUMN 的用户生成引用类型的类型的源类型类型代码，正如在 java.sql.Types 中定义的那样（如果 DATA_TYPE 不是 DISTINCT 或者不是带有 REFERENCE_GENERATION = USER_DEFINED 的 STRUCT，则该类型代码为 <code>null</code>）
  </OL>

<P><B>注：</B> 如果驱动程序不支持 UDT，则返回空结果集。

@param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；该参数为 &quot;&quot; 表示获取没有类别的那些描述；为 <code>null</code> 则表示该类别名称不应该用于缩小搜索范围
@param schemaPattern 模式名称的模式；它必须与存储在数据库中的模式名称匹配；该参数为 &quot;&quot; 表示获取没有模式的那些描述；为 <code>null</code> 则表示该模式名称不应该用于缩小搜索范围
@param typeNamePattern 类型名称模式；它必须与存储在数据库中的类型名称匹配，它可以是一个完全限定名称
@param types 将包括的用户定义类型（JAVA_OBJECT、STRUCT 或 DISTINCT）组成的列表；该参数为 <code>null</code> 则返回所有类型
@return <code>ResultSet</code> 对象，其中每一行都描述了一个 UDT
@exception SQLException 如果发生数据库访问错误
@see #getSearchStringEscape 
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.Connection java.sql.DatabaseMetaData.getConnection() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此元数据对象所产生的连接。
 <P>
@return 此元数据对象所产生的连接
@exception SQLException 如果发生数据库访问错误
@since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsSavepoints() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持保存点 (savepoint)。

@return 如果保存点受支持，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsNamedParameters() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持可调用语句的指定参数。

@return 如果指定参数受支持，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsMultipleOpenResults() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取是否可以同时拥有从 <code>CallableStatement</code> 对象中返回的多个 <code>ResultSet</code> 对象。

@return 如果一个 <code>CallableStatement</code> 对象可以同时返回多个 <code>ResultSet</code> 对象，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsGetGeneratedKeys() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取是否可以在执行语句后获取自动生成的键。

@return 如果可以在已执行语句后获取自动生成的键，则返回 <code>true</code>；否则返回 <code>false</code>
<p>如果返回 <code>true</code>，则 JDBC 驱动程序至少必须为 SQL INSERT 语句支持自动生成键的返回值。
<p>
@exception SQLException 如果发生数据库访问错误
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getSuperTypes(String catalog, String schemaPattern, String typeNamePattern) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取在此数据库的特定模式中定义的用户定义类型 (UDT) 分层结构的描述。仅建模直接的超类型/子类型关系。
 <P>
仅返回与类别、模式和类型名称匹配的用于 UDT 的超类型信息。类型名称参数可能为完全限定名称。当提供的 UDT 名称是完全限定名称时，忽略 catalog 和 schemaPattern 参数。 
 <P>
如果 UDT 没有直接的超类型，则它不会在这里列出。由此方法返回的 <code>ResultSet</code> 对象的一行描述了指定 UDT 和直接超类型。每一行都具有以下列：
  <OL>
<LI><B>TYPE_CAT</B> String =&gt; UDT 的类别（可为 <code>null</code>）
<LI><B>TYPE_SCHEM</B> String =&gt; UDT 的模式（可为 <code>null</code>）
<LI><B>TYPE_NAME</B> String =&gt; UDT 的类型名称
<LI><B>SUPERTYPE_CAT</B> String =&gt; 直接超类型的类别（可为 <code>null</code>）
<LI><B>SUPERTYPE_SCHEM</B> String =&gt; 直接超类型的模式（可为 <code>null</code>）
<LI><B>SUPERTYPE_NAME</B> String =&gt; 直接超类型的名称
  </OL>

<P><B>注：</B> 如果驱动程序不支持类型分层结构，则返回空结果集。

@param catalog 类别名称，该参数为 &quot;&quot; 表示获取没有类别的那些描述，为 <code>null</code> 则表示从选择标准中删除类别名称
@param schemaPattern 模式名称的模式，该参数为 &quot;&quot; 表示获取没有模式的那些描述
@param typeNamePattern UDT 名称模式，可以是一个完全限定名称
@return <code>ResultSet</code> 对象，其中一行给出了关于指定 UDT 的信息
@throws SQLException 如果发生数据库访问错误
@see #getSearchStringEscape
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getSuperTables(String catalog, String schemaPattern, String tableNamePattern) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取在此数据库的特定模式中定义的表分层结构的描述。

<P>仅返回与类别、模式和表名称匹配的表的超表 (supertable) 信息。表名称参数可能为完全限定名称，在这种情况下，可忽略 catalog 和 schemaPattern 参数。如果表没有超表，则它不会在这里列出。超表必须使用与子表相同的类别和模式来定义。所以，类型描述不必包含子表的此信息。

<P>每个类型描述都有以下列：
  <OL>
<LI><B>TABLE_CAT</B> String =&gt; 类型的类别（可为 <code>null</code>）
<LI><B>TABLE_SCHEM</B> String =&gt; 类型的模式（可为 <code>null</code>）
<LI><B>TABLE_NAME</B> String =&gt; 类型名称
<LI><B>SUPERTABLE_NAME</B> String =&gt; 直接超类型的名称
  </OL>

<P><B>注：</B> 如果驱动程序不支持类型分层结构，则返回空结果集。

@param catalog 类别名称，该参数为 &quot;&quot; 表示获取没有类别的那些描述，为 <code>null</code> 则表示从选择标准中删除类别名称
@param schemaPattern 模式名称的模式，该参数为 &quot;&quot; 表示获取没有模式的那些描述
@param tableNamePattern 表名称模式，可以是一个完全限定名称
@return 一个 <code>ResultSet</code> 对象，其中的每一行都是一个类型描述
@throws SQLException 如果发生数据库访问错误
@see #getSearchStringEscape
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getAttributes(String catalog, String schemaPattern, String typeNamePattern, String attributeNamePattern) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取可在给定模式和类别中使用的用户定义类型 (UDT) 的给定类型的给定属性的描述。
 <P>
仅返回与类别、模式、类型和属性名称标准匹配的 UDT 的属性描述。它们根据 <code>TYPE_CAT</code>、<code>TYPE_SCHEM</code>、<code>TYPE_NAME</code> 和 <code>ORDINAL_POSITION</code> 进行排序。此描述不包含某些特定的继承属性。
 <P>
返回的 <code>ResultSet</code> 对象具有以下列：
 <OL>
<LI><B>TYPE_CAT</B> String =&gt; 类型的类别（可为 <code>null</code>）
	<LI><B>TYPE_SCHEM</B> String =&gt; 类型的模式（可为 <code>null</code>）
	<LI><B>TYPE_NAME</B> String =&gt; 类型名称
	<LI><B>ATTR_NAME</B> String =&gt; 属性名称
	<LI><B>DATA_TYPE</B> int =&gt; 来自 java.sql.Types 的 SQL 类型的属性类型
	<LI><B>ATTR_TYPE_NAME</B> String =&gt; 依赖数据源的类型名称。对于 UDT，类型名称是完全限定的。对于 REF，类型名称是完全限定的，并且表示引用类型的目标类型。
	<LI><B>ATTR_SIZE</B> int =&gt; 列的大小。对于 char 或 date 类型，列的大小是最大字符数；对于 numeric 和 decimal 类型，列的大小就是精度。
	<LI><B>DECIMAL_DIGITS</B> int =&gt; 小数部分的位数。对于 DECIMAL_DIGITS 不适用的数据类型，则返回 Null。
	<LI><B>NUM_PREC_RADIX</B> int =&gt; 基数（通常为 10 或 2）
	<LI><B>NULLABLE</B> int =&gt; 是否允许使用 NULL
      <UL>
<LI> attributeNoNulls - 可能不允许使用 NULL 值
<LI> attributeNullable - 明确允许使用 NULL 值
<LI> attributeNullableUnknown - 不知道是否可使用 null
      </UL>
	<LI><B>REMARKS</B> String =&gt; 描述列的注释（可为 <code>null</code>）
	<LI><B>ATTR_DEF</B> String =&gt; 默认值（可为 <code>null</code>）
	<LI><B>SQL_DATA_TYPE</B> int =&gt; 未被使用
	<LI><B>SQL_DATETIME_SUB</B> int =&gt; 未被使用
	<LI><B>CHAR_OCTET_LENGTH</B> int =&gt; 对于 char 类型，该长度是列中的最大字节数
	<LI><B>ORDINAL_POSITION</B> int =&gt; UDT 中的属性的索引（从 1 开始）	
	<LI><B>IS_NULLABLE</B> String =&gt; ISO 规则用于确定属性是否可以包括 Null。
       <UL>
       <LI> YES           --- 如果属性可以包括 NULL
       <LI> NO            --- 如果属性不可以包括 NULL
       <LI> 空字符串  --- 如果不知道属性是否可以包括 Null 
       </UL>
<LI><B>SCOPE_CATALOG</B> String =&gt; 表的类别，它是引用属性的作用域（如果 DATA_TYPE 不是 REF，则为 <code>null</code>）
<LI><B>SCOPE_SCHEMA</B> String =&gt; 表的模式，它是引用属性的作用域（如果 DATA_TYPE 不是 REF，则为 <code>null</code>）
<LI><B>SCOPE_TABLE</B> String =&gt; 表名称，它是引用属性的作用域（如果 DATA_TYPE 不是 REF，则为 <code>null</code>）
<LI><B>SOURCE_DATA_TYPE</B> short =&gt; 不同类型或用户生成 Ref 类型、来自 java.sql.Types 的 SQL 类型的源类型（如果 DATA_TYPE 不是 DISTINCT 或用户生成的 REF，则为 <code>null</code>）
  </OL>
@param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；该参数为 &quot;&quot; 表示获取没有类别的那些描述；为 <code>null</code> 则表示该类别名称不应该用于缩小搜索范围
@param schemaPattern 模式名称的模式；它必须与存储在数据库中的模式名称匹配；该参数为 &quot;&quot; 表示获取没有模式的那些描述；为 <code>null</code> 则表示该模式名称不应该用于缩小搜索范围
@param typeNamePattern 类型名称模式；它必须与存储在数据库中的类型名称匹配
@param attributeNamePattern 属性名称模式；它必须与在数据库中被声明的属性名称匹配
@return 一个 <code>ResultSet</code> 对象，其中每一行都是一个属性描述
@exception SQLException 如果发生数据库访问错误
@see #getSearchStringEscape
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsResultSetHoldability(int holdability) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持给定结果集可保存性。

@param holdability  以下常量之一：<code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> 或 <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>
@return 如果支持，则返回 <code>true</code>；否则返回 <code>false</code>
@exception SQLException 如果发生数据库访问错误
@see Connection
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getResultSetHoldability() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
针对 <code>ResultSet</code> 对象获取此数据库的默认可保存性。

@return 默认可保存性，它是 <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> 或 <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>
@exception SQLException 如果发生数据库访问错误
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getDatabaseMajorVersion() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取底层数据库的主版本号。

@return 底层数据库的主版本号
@exception SQLException 如果发生数据库访问错误
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getDatabaseMinorVersion() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
底层数据库的次版本号。

@return 底层数据库的次版本号
@exception SQLException 如果发生数据库访问错误
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getJDBCMajorVersion() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此驱动程序的主 JDBC 版本号。
 
@return JDBC 的主版本号
@exception SQLException 如果发生数据库访问错误
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getJDBCMinorVersion() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此驱动程序的次 JDBC 版本号。
 
@return JDBC 的次版本号
@exception SQLException 如果发生数据库访问错误
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.sql.DatabaseMetaData.getSQLStateType() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
指示由 <code>SQLException.getSQLState</code> 返回的 SQLSTATE 是 X/Open（现在称为 Open Group）SQL CLI 还是 SQL:2003。
@return SQLSTATE 的类型，它为 sqlStateXOpen 或 sqlStateSQL 之一
@throws SQLException 如果发生数据库访问错误
@since 1.4 

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.locatorsUpdateCopy() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
指示对 LOB 的更新是在副本上进行还是直接更新到 LOB。
@return 如果更新在 LOB 的副本上进行，则返回 <code>true</code>；如果直接更新到 LOB，则返回 <code>false</code>
@throws SQLException 如果发生数据库访问错误
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsStatementPooling() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此数据库是否支持语句合并 (statement pooling)。

@return 如果支持，则返回 <code>true</code>；否则返回 <code>false</code>
@throws SQLExcpetion 如果发生数据库访问错误
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.RowIdLifetime java.sql.DatabaseMetaData.getRowIdLifetime() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 指示此数据源是否支持 SQL <code>ROWID</code> 类型，如果支持，则 <code>RowId</code> 对象在该类型的生存期内持续有效。  
<p>
 返回的 int 值之间具有以下关系：
 <pre>
     ROWID_UNSUPPORTED < ROWID_VALID_OTHER < ROWID_VALID_TRANSACTION
         < ROWID_VALID_SESSION < ROWID_VALID_FOREVER
 </pre>
 因此，可以使用
 <pre>
     if (metadata.getRowIdLifetime() > DatabaseMetaData.ROWID_VALID_TRANSACTION)
 </pre>
 之类的条件逻辑。永远有效 (ROWID_VALID_FOREVER) 意味着在所有会话中有效，对会话有效 (ROWID_VALID_SESSION) 意味着在其包含的所有事务中有效。

 @return 指示 <code>RowId</code> 生存期的状态
 @throws SQLException 如果发生数据库访问错误
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getSchemas(String catalog, String schemaPattern) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 获取此数据库中可用的模式名称。结果根据 <code>TABLE_CATALOG</code> 和 <code>TABLE_SCHEM</code> 进行排序。

 <P>模式列为：
  <OL>
	<LI><B>TABLE_SCHEM</B> String => 模式名称
  <LI><B>TABLE_CATALOG</B> String => 类别名称（可以为 <code>null</code>）
  </OL>


 @param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；为 "" 表示获取没有类别的模式名称；为 <code>null</code> 表示该类别名称不应该用于缩小搜索范围。
 @param schemaPattern 模式名称；它必须与存储在数据库中的模式名称匹配；为 null 则表示该模式名称不应该用于缩小搜索范围。
 @return 每行是一个模式描述的 <code>ResultSet</code> 对象
 @exception SQLException 如果发生数据库访问错误
 @see #getSearchStringEscape 
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.supportsStoredFunctionsUsingCallSyntax() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 获取此数据库是否支持使用存储过程转义语法调用用户定义的函数或供应商函数。

 @return 如果支持，则返回 <code>true</code>；否则返回 <code>false</code>
 @exception SQLException 如果发生数据库访问错误
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.sql.DatabaseMetaData.autoCommitFailureClosesAllResultSets() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
当 autoCommit 为 <code>true</code> 时，获取 <code>SQLException</code> 是否指示所有打开的 ResultSets 已关闭（包括那些可保持的）。当发生 <code>SQLException</code> 而 autocommit 为 <code>true</code> 时，则 JDBC 驱动程序是以提交操作、回滚操作响应还是既不提交也不回滚是特定于供应商的。此差异的可能结果在于可保持的 ResultSets 是否关闭。 

 @return 如果是，则返回 <code>true</code>；否则返回 <code>false</code>
 @exception SQLException 如果发生数据库访问错误
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getClientInfoProperties() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 获取驱动程序支持的客户端信息属性的列表。结果集包括以下列
 <p>
 <ol>
 <li><b>NAME</b> String=> 客户端信息属性的名称<br>
 <li><b>MAX_LEN</b> int=> 属性值的最大长度<br>
 <li><b>DEFAULT_VALUE</b> String=> 属性的默认值<br>
 <li><b>DESCRIPTION</b> String=> 属性的描述。通常包括关于此属性存储在数据库何处的信息。
 </ol>
 <p>
 <code>ResultSet</code> 按 NAME 列排序
 <p>
 @return	一个 <code>ResultSet</code> 对象；每行是一个客户端信息属性
 <p>
  @exception SQLException 如果发生数据库访问错误
 <p>
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getFunctions(String catalog, String schemaPattern, String functionNamePattern) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 获取给定类别中可用的系统和用户函数的描述。
 <P>
 只返回那些匹配模式和函数名称标准的系统和用户函数的描述。它们按照 <code>FUNCTION_CAT</code>、<code>FUNCTION_SCHEM</code>、<code>FUNCTION_NAME</code> 和 <code>SPECIFIC_ NAME</code> 进行排序。

 <P>每个函数描述都有以下列：
  <OL>
	<LI><B>FUNCTION_CAT</B> String => 函数类别（可为 <code>null</code>）
	<LI><B>FUNCTION_SCHEM</B> String => 函数模式（可为 <code>null</code>）
	<LI><B>FUNCTION_NAME</B> String => 函数名称。这是用于调用该函数的名称
	<LI><B>REMARKS</B> String => 函数的解释性注释
 <LI><B>FUNCTION_TYPE</B> short => 函数的种类：
      <UL>
      <LI>functionResultUnknown - 不能确定是否将返回一个返回值或表。
      <LI> functionNoTable- 不返回表
      <LI> functionReturnsTable - 返回表
      </UL>
	<LI><B>SPECIFIC_NAME</B> String  => 唯一标识模式中此函数的名数。这是用户指定的或 DBMS 生成的名称，这可能不同于带有重载函数的 <code>FUNCTION_NAME</code>
  </OL>
 <p>
 用户可能不具有执行 <code>getFunctions</code> 返回的所有函数的权限

 @param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；为 "" 表示获取没有类别的那些描述；为 <code>null</code> 表示该类别名称不应该用于缩小搜索范围
 @param schemaPattern 模式名称的模式；它必须与存储在数据库中的模式名称匹配；为 "" 表示获取没有模式的那些描述；为 <code>null</code> 表示该模式名称不应该用于缩小搜索范围
 @param functionNamePattern 函数名称模式；它必须与存储在数据库中的函数名称匹配
 @return <code>ResultSet</code> - 每行是一个函数描述
 @exception SQLException 如果发生数据库访问错误
 @see #getSearchStringEscape 
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.sql.ResultSet java.sql.DatabaseMetaData.getFunctionColumns(String catalog, String schemaPattern, String functionNamePattern, String columnNamePattern) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 获取给定类别的系统或用户函数参数和返回类型的描述。

 <P>只返回那些匹配模式、函数和参数名称标准的描述。它们按照 <code>FUNCTION_CAT</code>、<code>FUNCTION_SCHEM</code>、<code>FUNCTION_NAME</code> 和 <code>SPECIFIC_ NAME</code> 进行排序。 在此排序中，返回值（如果有）排在最前面。接着是参数描述，它们按调用顺序排序。然后是列描述，它们按列编号顺序排序。

 <P><code>ResultSet</code> 中的每个行都是带以下字段的参数描述、列描述或返回类型描述：
  <OL>
  <LI><B>FUNCTION_CAT</B> String => 函数类别（可为 <code>null</code>）
	<LI><B>FUNCTION_SCHEM</B> String => 函数模式（可为 <code>null</code>）
	<LI><B>FUNCTION_NAME</B> String => 函数名称。这是用于调用该函数的名称
	<LI><B>COLUMN_NAME</B> String => 列/参数名称
	<LI><B>COLUMN_TYPE</B> Short => 列/参数的种类：
      <UL>
      <LI> functionColumnUnknown - 未知
      <LI> functionColumnIn - IN 参数
      <LI> functionColumnInOut - INOUT 参数
      <LI> functionColumnOut - OUT 参数
      <LI> functionColumnReturn - 函数返回值
      <LI> functionColumnResult - 指示该参数或列是 <code>ResultSet</code> 中的列。
      </UL>
  <LI><B>DATA_TYPE</B> int => 取自 java.sql.Types 的 SQL 类型
	<LI><B>TYPE_NAME</B> String => SQL 类型名称，对于 UDT 类型该类型名称是完全限定的
	<LI><B>PRECISION</B> int => 精度
	<LI><B>LENGTH</B> int => 数据的字节长度
	<LI><B>SCALE</B> short => scale -  对于其 SCALE 不适用的数据类型返回 null。 
	<LI><B>RADIX</B> short => 基数
	<LI><B>NULLABLE</B> short => 是否可以包含 NULL。
      <UL>
      <LI> functionNoNulls - 不允许使用 NULL 值
      <LI> functionNullable - 允许使用 NULL 值
      <LI> functionNullableUnknown - 不知道是否可使用 Null 值 
      </UL>
	<LI><B>REMARKS</B> String => 描述列/参数的注释
	<LI><B>CHAR_OCTET_LENGTH</B> int  => 基于二进制和字符的参数或列的最大长度。对于任何其他数据类型，返回值为 NULL
	<LI><B>ORDINAL_POSITION</B> int  => 顺序位置，对于输入和输出参数，从 1 开始。如果此行描述函数的返回值，则返回值 0。对于结果集列，它是结果集中列的顺序位置（从 1 开始）。
	<LI><B>IS_NULLABLE</B> String  => ISO 规则用于确定参数或列是否可以包括 Null 
       <UL>
       <LI> YES           --- 如果该参数或列可以包括 NULL
       <LI> NO            --- 如果该参数或列不可以包括 NULL
       <LI> 空字符串  --- 如果不知道该参数或列是否可以包括 Null 
       </UL>
	<LI><B>SPECIFIC_NAME</B> String  => 唯一标识模式中此函数的名数。这是用户指定的或 DBMS 生成的名称，这可能不同于带有重载函数的 <code>FUNCTION_NAME</code>
  </OL>
 
 <p>PRECISION 列表示给定参数或列的指定列大小。对于数值数据，这是最大精度。对于字符数据，这是字符长度。对于日期时间数据类型，这是 String 表示形式字符长度（假定允许的最大小数秒组件的精度）。对于二进制数据，这是字节长度。对于 ROWID 数据类型，这是字节长度。对于列大小不适用的数据类型，则返回 Null。
 @param catalog 类别名称；它必须与存储在数据库中的类别名称匹配；为 "" 表示获取没有类别的那些描述；为 <code>null</code> 表示该类别名称不应该用于缩小搜索范围
 @param schemaPattern 模式名称的模式；它必须与存储在数据库中的模式名称匹配；为 "" 表示获取没有模式的那
些描述；为 <code>null</code> 表示该模式名称不应该用于缩小搜索范围
 @param functionNamePattern 进程名称模式；它必须与存储在数据库中的函数名称匹配
 @param columnNamePattern 参数名称模式；它必须与存储在数据库中的参数或列名称匹配
 @return <code>ResultSet</code> - 每行描述一个用户函数参数、列或返回类型

 @exception SQLException 如果发生数据库访问错误。
 @see #getSearchStringEscape 
 @since 1.6

<!-- END DATA -->
