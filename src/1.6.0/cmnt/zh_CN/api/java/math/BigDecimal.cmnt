<!-- BEGIN KEY -->
public class java.math.BigDecimal extends java.lang.Number implements java.lang.Comparable
<!-- END KEY -->
<!-- BEGIN DATA -->
不可变的、任意精度的有符号十进制数。<tt>BigDecimal</tt> 由任意精度的整数<i>非标度值</i> 和 32 位的整数<i>标度</i> (scale) 组成。如果为零或正数，则标度是小数点后的位数。如果为负数，则将该数的非标度值乘以 10 的负 scale 次幂。因此，<tt>BigDecimal</tt> 表示的数值是 <tt>(unscaledValue &times; 10<sup>-scale</sup>)</tt>。
 
<p><tt>BigDecimal</tt> 类提供以下操作：算术、标度操作、舍入、比较、哈希算法和格式转换。{@link #toString} 方法提供 <tt>BigDecimal</tt> 的规范表示形式。
 
<p><tt>BigDecimal</tt> 类使用户能完全控制舍入行为。如果未指定舍入模式，并且无法表示准确结果，则抛出一个异常；否则，通过向该操作提供适当的 {@link MathContext} 对象，可以对已选择的精度和舍入模式执行计算。在任何情况下，可以为舍入控制提供八种<em>舍入模式</em>。使用此类（例如，{@link #ROUND_HALF_UP}）中的整数字段来表示舍入模式已过时；应改为使用 <tt>RoundingMode</tt> <tt>enum</tt>（例如，{@link RoundingMode#HALF_UP}）的枚举值。
 
<p>当为 <tt>MathContext</tt> 对象提供 0 的精度设置（例如，{@link MathContext#UNLIMITED}）时，算术运算是准确的，它们是不采用任何 <tt>MathContext</tt> 对象的算术方法。（这是第 5 版之前的版本支持的唯一行为。）为了计算准确结果，不使用附带 0 精度设置的 <tt>MathContext</tt> 对象的舍入模式设置，因此与该对象无关。在除法中，准确的商可能是一个无限长的十进制扩展；例如，1 除以 3 所得的商。如果商具有无穷的十进制扩展，但是指定了该操作返回准确结果，则抛出 <tt>ArithmeticException</tt>。否则，像其他操作那样，返回除法运算的准确结果。

<p>当精度设置不为 0 时，<tt>BigDecimal</tt> 算法的规则完全符合 ANSI X3.274-1996 和 ANSI X3.274-1996/AM 1-2000（ 7.4 节）中定义的算法的可选操作模式。与上述标准不同，<tt>BigDecimal</tt> 包括多种舍入模式，它们对于版本 5 以前的 <tt>BigDecimal</tt> 版本中的除法是强制性的。这些 ANSI 标准和 <tt>BigDecimal</tt> 规范之间的任何冲突都按照有利于 <tt>BigDecimal</tt> 的方式进行解决。  

<p>由于同一数值可以有不同的表示形式（具有不同的标度），因此运算和舍入的规则必须同时指定数值结果和结果表示形式中所用的标度。


<p>一般情况下，当准确结果（在除法中，可能有无限多位）比返回的数值具有更多位数时，舍入模式和精度设置确定操作如何返回具有有限位数的结果。
 
首先，<tt>MathContext</tt> 的 <tt>precision</tt> 设置指定要返回的总位数；这确定了结果的<i>精度</i>。位数计数从准确结果的最左边的非零数字开始。舍入模式确定丢弃的尾部位数如何影响返回的结果。

<p>对于所有算术运算符，运算的执行方式是，首先计算准确的中间结果，然后，使用选择的舍入模式将其舍入为精度设置（如有必要）指定的位数。如果不返回准确结果，则将丢弃准确结果的某些数位。当舍入增加了返回结果的大小时，前导数字&ldquo;9&rdquo;的进位传播可能会创建新的数位。例如，将值 999.9 舍入为三位数字，则在数值上等于一千，表示为 100&times;10<sup>1</sup>。在这种情况下，新的 &quot;1&quot; 是返回结果的前导数位。

<p>除了逻辑的准确结果外，每种算术运算都有一个表示结果的首选标度。下表列出了每个运算的首选标度。

 <table border>
<caption top><h3>算术运算结果的首选标度
 </h3></caption>
<tr><th>运算</th><th>结果的首选标度</th></tr>
<tr><td>加</td><td>max(addend.scale(), augend.scale())</td>
<tr><td>减</td><td>max(minuend.scale(), subtrahend.scale())</td>
<tr><td>乘</td><td>multiplier.scale() + multiplicand.scale()</td>
<tr><td>除</td><td>dividend.scale() - divisor.scale()</td>
 </table>

这些标度是返回准确算术结果的方法使用的标度；准确相除可能必须使用较大的标度除外，因为准确的结果可能有较多的位数。例如，<tt>1/32</tt> 得到 <tt>0.03125</tt>。

<p>舍入之前，逻辑的准确中间结果的标度是该运算的首选标度。如果用 <code>precision</code> 位数无法表示准确的数值结果，则舍入会选择要返回的一组数字，并将该结果的标度从中间结果的标度减小到可以表示实际返回的 <code>precision</code> 位数的最小标度。如果准确结果可以使用最多 <code>precision</code> 个数字表示，则返回具有最接近首选标度的标度的结果表示形式。尤其是，通过移除结尾零并减少标度，可以用少于 <code>precision</code> 个数字来表示准确的可表示的商。例如，使用 {@linkplain RoundingMode#FLOOR floor} 舍入模式将结果舍入为三个数字，<br>

 <code>19/100 = 0.19   // integer=19,  scale=2</code> <br>

但是<br>

 <code>21/110 = 0.190  // integer=190, scale=3</code> <br>

<p>注意，对于加、减和乘，标度的缩减量将等于丢弃的准确结果的数字位置数。如果舍入导致进位传播创建一个新的高位，则当未创建新的数位时，会丢弃该结果的附加数字。

<p>其他方法可能与舍入语义稍微不同。例如，使用{@linkplain #pow(int, MathContext) 指定的算法}的 <tt>pow</tt> 方法得到的结果可能偶尔不同于舍入得到的算术结果，如最后一位有多个单位（<i>{@linkplain #ulp() ulp}</i>）。

<p>可以通过两种类型的操作来处理 <tt>BigDecimal</tt> 的标度：标度/舍入操作和小数点移动操作。标度/舍入操作（{@link #setScale setScale} 和 {@link #round round}）返回 <tt>BigDecimal</tt>，其值近似地（或精确地）等于操作数的值，但是其标度或精度是指定的值；即：它们会增加或减少对其值具有最小影响的存储数的精度。小数点移动操作（{@link #movePointLeft movePointLeft} 和 {@link #movePointRight movePointRight}）返回从操作数创建的 <tt>BigDecimal</tt>，创建的方法是按指定方向将小数点移动一个指定距离。
 
<p>为了简洁明了起见，整个 <tt>BigDecimal</tt> 方法的描述中都使用了伪代码。伪代码表达式 <tt>(i + j)</tt> 是&ldquo;其值为 <tt>BigDecimal</tt> <tt>i</tt> 加 <tt>BigDecimal</tt> <tt>j</tt> 的 <tt>BigDecimal</tt>&rdquo;的简写。伪代码表达式 <tt>(i == j)</tt> 是&ldquo;当且仅当 <tt>BigDecimal</tt> <tt>i</tt> 表示与 <tt>BigDecimal</tt> <tt>j</tt> 相同的值时，则为 <tt>true</tt>&rdquo;的简写。可以类似地解释其他伪代码表达式。方括号用于表示特定的 <tt>BigInteger</tt> 和定义 <tt>BigDecimal</tt> 值的标度对；例如，[19, 2] 表示 <tt>BigDecimal</tt> 在数值上等于 0.19，标度是 2。

<p>注：如果 <tt>BigDecimal</tt> 对象用作 {@link java.util.SortedMap SortedMap} 中的键或 {@link java.util.SortedSet SortedSet} 中的元素，则应特别小心，因为 <tt>BigDecimal</tt> 的<i>自然排序</i><i>与 equals 方法不一致</i>。有关更多信息，请参见 {@link Comparable}、{@link java.util.SortedMap} 或 {@link java.util.SortedSet}。
 
<p>当为任何输入参数传递 <tt>null</tt> 对象引用时，此类的所有方法和构造方法都将抛出 <tt>NullPointerException</tt>。

@see     BigInteger
@see     MathContext
@see     RoundingMode
@see     java.util.SortedMap
@see     java.util.SortedSet
@author  Josh Bloch
@author  Mike Cowlishaw
@author  Joseph D. Darcy

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.math.BigDecimal java.math.BigDecimal.ZERO
<!-- END KEY -->
<!-- BEGIN DATA -->
值为 0，标度为 0。

@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.math.BigDecimal java.math.BigDecimal.ONE
<!-- END KEY -->
<!-- BEGIN DATA -->
值为 1，标度为 0。

@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.math.BigDecimal java.math.BigDecimal.TEN
<!-- END KEY -->
<!-- BEGIN DATA -->
值为 10，标度为 0。

@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.math.BigDecimal.ROUND_UP
<!-- END KEY -->
<!-- BEGIN DATA -->
舍入远离零的舍入模式。在丢弃非零部分之前始终增加数字。注意，此舍入模式始终不会减少计算值的大小。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.math.BigDecimal.ROUND_DOWN
<!-- END KEY -->
<!-- BEGIN DATA -->
接近零的舍入模式。在丢弃某部分之前始终不增加数字（即截短）。注意，此舍入模式始终不会增加计算值的大小。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.math.BigDecimal.ROUND_CEILING
<!-- END KEY -->
<!-- BEGIN DATA -->
接近正无穷大的舍入模式。如果 <tt>BigDecimal</tt> 为正，则舍入行为与 <tt>ROUND_UP</tt> 相同；如果为负，则舍入行为与 <tt>ROUND_DOWN</tt> 相同。注意，此舍入模式始终不会减少计算值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.math.BigDecimal.ROUND_FLOOR
<!-- END KEY -->
<!-- BEGIN DATA -->
接近负无穷大的舍入模式。如果 <tt>BigDecimal</tt> 为正，则舍入行为与 <tt>ROUND_DOWN</tt> 相同；如果为负，则舍入行为与 <tt>ROUND_UP</tt> 相同。注意，此舍入模式始终不会增加计算值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.math.BigDecimal.ROUND_HALF_UP
<!-- END KEY -->
<!-- BEGIN DATA -->
向&ldquo;最接近的&rdquo;数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。如果舍弃部分 &gt;= 0.5，则舍入行为与 <tt>ROUND_UP</tt> 相同；否则舍入行为与 <tt>ROUND_DOWN</tt> 相同。注意，这是我们大多数人在小学时就学过的舍入模式。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.math.BigDecimal.ROUND_HALF_DOWN
<!-- END KEY -->
<!-- BEGIN DATA -->
向&ldquo;最接近的&rdquo;数字舍入，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。如果舍弃部分 &gt; 0.5，则舍入行为与 <tt>ROUND_UP</tt> 相同；否则舍入行为与 <tt>ROUND_DOWN</tt> 相同。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.math.BigDecimal.ROUND_HALF_EVEN
<!-- END KEY -->
<!-- BEGIN DATA -->
向&ldquo;最接近的&rdquo;数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。如果舍弃部分左边的数字为奇数，则舍入行为与 <tt>ROUND_HALF_UP</tt> 相同；如果为偶数，则舍入行为与 <tt>ROUND_HALF_DOWN</tt> 相同。注意，在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.math.BigDecimal.ROUND_UNNECESSARY
<!-- END KEY -->
<!-- BEGIN DATA -->
断言请求的操作具有精确的结果，因此不需要舍入。如果对获得精确结果的操作指定此舍入模式，则抛出 <tt>ArithmeticException</tt>。

<!-- END DATA -->
<!-- BEGIN KEY -->
private volatile java.math.BigInteger java.math.BigDecimal.intVal
<!-- END KEY -->
<!-- BEGIN DATA -->
此 BigDecimal 的非标度值，由 {@link #unscaledValue} 返回。

@serial
@see #unscaledValue

<!-- END DATA -->
<!-- BEGIN KEY -->
private int java.math.BigDecimal.scale
<!-- END KEY -->
<!-- BEGIN DATA -->
此 BigDecimal 的标度，由 {@link #scale} 返回。

@serial
@see #scale

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal(char[] in, int offset, int len)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>BigDecimal</tt> 的字符数组表示形式转换为 <tt>BigDecimal</tt>，接受与 {@link #BigDecimal(String)} 构造方法相同的字符序列，同时允许指定子数组。
 
<p>注意，如果字符数组中已经提供字符的序列，则使用此构造方法要比将 <tt>char</tt> 数组转换为字符串并使用 <tt>BigDecimal(String)</tt> 构造方法更快。

@param  in 作为源字符的 <tt>char</tt> 数组。
@param  offset 要检查的数组中的第一个字符。
@param  len 要考虑的字符数。
@throws NumberFormatException 如果 <tt>in</tt> 不是 <tt>BigDecimal</tt> 的有效表示形式，或者定义的子数组不完全在 <tt>in</tt> 中。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal(char[] in, int offset, int len, MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>BigDecimal</tt> 的字符数组表示形式转换为 <tt>BigDecimal</tt>，接受与 {@link #BigDecimal(String)} 构造方法相同的字符序列，同时允许指定子数组，并根据上下文设置进行舍入。
 
<p>注意，如果字符数组中已经提供字符的序列，则使用此构造方法要比将 <tt>char</tt> 数组转换为字符串并使用 <tt>BigDecimal(String)</tt> 构造方法更快。

@param  in 作为源字符的 <tt>char</tt> 数组。
@param  offset 要检查的数组中的第一个字符。
@param  len 要考虑的字符数。
@param  mc 要使用的上下文。
@throws ArithmeticException 如果结果不准确，且舍入模式为 <tt>UNNECESSARY</tt>。
@throws NumberFormatException 如果 <tt>in</tt> 不是 <tt>BigDecimal</tt> 的有效表示形式，或者定义的子数组不完全在 <tt>in</tt> 中。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal(char[] in)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>BigDecimal</tt> 的字符数组表示形式转换为 <tt>BigDecimal</tt>，接受与 {@link #BigDecimal(String)} 构造方法相同的字符序列。
 
<p>注意，如果字符序列已经可以作为一个字符数组使用，则使用此构造方法要比将 <tt>char</tt> 数组转换为字符串并使用 <tt>BigDecimal(String)</tt> 构造方法更快。

@param  in 作为源字符的 <tt>char</tt> 数组。
@throws  NumberFormatException 如果 <tt>in</tt> 不是 <tt>BigDecimal</tt> 的有效表示形式。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal(char[] in, MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>BigDecimal</tt> 的字符数组表示形式转换为 <tt>BigDecimal</tt>，接受与 {@link #BigDecimal(String)} 构造方法相同的字符序列（根据上下文设置进行舍入）。
 
<p>注意，如果字符序列已经可以作为一个字符数组使用，则使用此构造方法要比将 <tt>char</tt> 数组转换为字符串并使用 <tt>BigDecimal(String)</tt> 构造方法更快。

@param  in 作为源字符的 <tt>char</tt> 数组。
@param  mc 要使用的上下文。
@throws ArithmeticException 如果结果不准确，且舍入模式为 <tt>UNNECESSARY</tt>。
@throws  NumberFormatException 如果 <tt>in</tt> 不是 <tt>BigDecimal</tt> 的有效表示形式。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal(String val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>BigDecimal</tt> 的字符串表示形式转换为 <tt>BigDecimal</tt>。字符串表示形式由可选符号 <tt>'+'</tt> (<tt>'\u002B'</tt>) 或 <tt>'-'</tt> (<tt>'\u002D'</tt>) 组成，后跟零或多个十进制数字（&ldquo;整数&rdquo;）的序列，可以选择后跟一个小数，也可以选择后跟一个指数。
 
<p>该小数由小数点以及后跟的零或更多十进制数字组成。字符串必须至少包含整数或小数部分中的一个数字。由符号、整数和小数部分组成的数字称为<i>有效位数</i>。

<p>指数由字符 <tt>'e'</tt>（<tt>'\u0065'</tt>) 或 <tt>'E'</tt> (<tt>'\u0045'</tt>) 以及后跟的一个或多个十进制数字组成。指数的值必须位于 {@link Integer#MAX_VALUE} ({@link Integer#MIN_VALUE}+1) 和 {@link Integer#MAX_VALUE}（包括）之间。

<p>更正式地说，以下语法描述了此构造方法接受的字符串：
 <blockquote>
 <dl>
 <dt><i>BigDecimalString:</i>
 <dd><i>Sign<sub>opt</sub> Significand Exponent<sub>opt</sub></i>
 <p>
<dt><i>Sign:</i>
 <dd><tt>+</tt>
 <dd><tt>-</tt>
 <p>
 <dt><i>Significand:</i>
 <dd><i>IntegerPart</i> <tt>.</tt><i>FractionPart<sub>opt</sub></i>
 <dd><tt>.</tt> <i>FractionPart</i>
 <dd><i>IntegerPart</i>
 <p>
 <dt><i>IntegerPart:
<dd>Digits</i>
 <p>
 <dt><i>FractionPart:
<dd>Digits</i>
 <p>
<dt><i>Exponent:
 <dd>ExponentIndicator SignedInteger</i>
 <p>
 <dt><i>ExponentIndicator:</i>
 <dd><tt>e</tt>
<dd><tt>E</tt>
 <p>
<dt><i>SignedInteger:
 <dd>Sign<sub>opt</sub> Digits</i>
 <p>
<dt><i>Digits:
<dd>Digit
 <dd>Digits Digit</i>
 <p>
<dt><i>Digit:</i>
<dd>{@link Character#isDigit} 对其返回 <tt>true</tt> 的任何字符，如 0、1、2……
 </dl>
 </blockquote>

<p>返回的 <tt>BigDecimal</tt> 的标度将是小数部分中的数字位数，如果该字符串不包含小数点，则标度为零，这取决于对指数的调整；如果字符串包含一个指数，则从标度减去该指数。得到的标度值必须位于 <tt>Integer.MIN_VALUE</tt> 和 <tt>Integer.MAX_VALUE</tt>（包括）之间。

<p>{@link java.lang.Character#digit} 集提供从字符到数字的映射，以转换成基数 10。该字符串不能包含任何额外字符（例如，空白）。

<p><b>示例：</b><br> 返回的 <tt>BigDecimal</tt> 的值等于<i>有效位数</i> &times; 10<sup>&#xA0;<i>指数</i></sup>。对于左边的每个字符串，得到的表示形式 [<tt>BigInteger</tt>, <tt>scale</tt>] 显示在右边。
 <pre>
 &quot;0&quot;            [0,0]
 &quot;0.00&quot;         [0,2]
 &quot;123&quot;          [123,0]
 &quot;-123&quot;         [-123,0]
 &quot;1.23E3&quot;       [123,-1]
 &quot;1.23E+3&quot;      [123,-1]
 &quot;12.3E+7&quot;      [123,-6]
 &quot;12.0&quot;         [120,1]
 &quot;12.3&quot;         [123,1]
 &quot;0.00123&quot;      [123,5]
 &quot;-1.23E-12&quot;    [-123,14]
 &quot;1234.5E-4&quot;    [12345,5]
 &quot;0E+7&quot;         [0,-7]
 &quot;-0&quot;           [0,0]
 </pre>

<p>注：对于不是 <tt>float</tt>、<tt>double</tt> NaN 和 &plusmn;Infinity 的值，此构造方法与 {@link Float#toString} 和 {@link Double#toString} 返回的值兼容。这通常是将 <tt>float</tt> 或 <tt>double</tt> 转换为 BigDecimal 的首选方法，因为它不会遇到 {@link #BigDecimal(double)} 构造方法的不可预知问题。

@param val <tt>BigDecimal</tt> 的字符串表示形式。

@throws NumberFormatException 如果 <tt>val</tt> 不是 <tt>BigDecimal</tt> 的有效表示形式。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal(String val, MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>BigDecimal</tt> 的字符串表示形式转换为 <tt>BigDecimal</tt>，接受与 {@link #BigDecimal(String)} 构造方法相同的字符串（按照上下文设置进行舍入）。
 
@param val <tt>BigDecimal</tt> 的字符串表示形式。
@param  mc 要使用的上下文。
@throws ArithmeticException 如果结果不准确，且舍入模式为 <tt>UNNECESSARY</tt>。
@throws NumberFormatException 如果 <tt>val</tt> 不是 BigDecimal 的有效表示形式。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal(double val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>double</tt> 转换为 <tt>BigDecimal</tt>，后者是 <tt>double</tt> 的二进制浮点值准确的十进制表示形式。返回的 <tt>BigDecimal</tt> 的标度是使 <tt>(10<sup>scale</sup> &times; val)</tt> 为整数的最小值。
 <p>
<b>注：</b>
 <ol>
 <li>
此构造方法的结果有一定的不可预知性。有人可能认为在 Java 中写入 <tt>new BigDecimal(0.1)</tt> 所创建的 <tt>BigDecimal</tt> 正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于 0.1000000000000000055511151231257827021181583404541015625。这是因为 0.1 无法准确地表示为 <tt>double</tt>（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，<i>传入</i> 到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。

 <li>
另一方面，<tt>String</tt> 构造方法是完全可预知的：写入 <tt>new BigDecimal(&quot;0.1&quot;)</tt> 将创建一个 <tt>BigDecimal</tt>，它<i>正好</i> 等于预期的 0.1。因此，比较而言，通常建议优先使用 {@linkplain #BigDecimal(String) <tt>String</tt> 构造方法}。

 <li>
当 <tt>double</tt> 必须用作 <tt>BigDecimal</tt> 的源时，请注意，此构造方法提供了一个准确转换；它不提供与以下操作相同的结果：先使用 {@link Double#toString(double)} 方法，然后使用 {@link #BigDecimal(String)} 构造方法，将 <tt>double</tt> 转换为 <tt>String</tt>。要获取该结果，请使用 <tt>static</tt> {@link #valueOf(double)} 方法。
 </ol>

@param val 要转换为 <tt>BigDecimal</tt> 的 <tt>double</tt> 值。
@throws NumberFormatException 如果 <tt>val</tt> 为无穷大或 NaN。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal(double val, MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>double</tt> 转换为 <tt>BigDecimal</tt>（根据上下文设置进行舍入）。<tt>BigDecimal</tt> 的标度是使 <tt>(10<sup>scale</sup> &times; val)</tt> 为整数的最小值。
 
<p>此构造方法的结果有一定的不可预知性，通常不建议使用它，请参见 {@link #BigDecimal(double)} 构造方法下面的注释。

@param val 要转换为 <tt>BigDecimal</tt> 的 <tt>double</tt> 值。
@param  mc 要使用的上下文。
@throws ArithmeticException 如果结果不准确，但是 RoundingMode 为 UNNECESSARY。
@throws NumberFormatException 如果 <tt>val</tt> 为无穷大或 NaN。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal(BigInteger val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>BigInteger</tt> 转换为 <tt>BigDecimal</tt>。<tt>BigDecimal</tt> 的标度是零。

@param val 要转换为 <tt>BigDecimal</tt> 的 <tt>BigInteger</tt> 值。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal(BigInteger val, MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>BigInteger</tt> 转换为 <tt>BigDecimal</tt>（根据上下文设置进行舍入）。<tt>BigDecimal</tt> 的标度为零。
 
@param val 要转换为 <tt>BigDecimal</tt> 的 <tt>BigInteger</tt> 值。
@param  mc 要使用的上下文。
@throws ArithmeticException 如果结果不准确，但是舍入模式为 <tt>UNNECESSARY</tt>。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal(BigInteger unscaledVal, int scale)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>BigInteger</tt> 非标度值和 <tt>int</tt> 标度转换为 <tt>BigDecimal</tt>。<tt>BigDecimal</tt> 的值为 <tt>(unscaledVal &times; 10<sup>-scale</sup>)</tt>。

@param unscaledVal <tt>BigDecimal</tt> 的非标度值。
@param scale <tt>BigDecimal</tt> 的标度。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal(BigInteger unscaledVal, int scale, MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>BigInteger</tt> 非标度值和 <tt>int</tt> 标度转换为 <tt>BigDecimal</tt>（根据上下文设置进行舍入）。<tt>BigDecimal</tt> 的值为 <tt>(unscaledVal &times; 10<sup>-scale</sup>)</tt>，它是根据 <tt>precision</tt> 和舍入模式设置进行舍入的。

@param unscaledVal <tt>BigDecimal</tt> 的非标度值。
@param scale <tt>BigDecimal</tt> 的标度。
@param  mc 要使用的上下文。
@throws ArithmeticException 如果结果不准确，但是舍入模式为 <tt>UNNECESSARY</tt>。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal(int val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>int</tt> 转换为 <tt>BigDecimal</tt>。<tt>BigDecimal</tt> 的标度为零。

@param val 要转换为 <tt>BigDecimal</tt> 的 <tt>int</tt> 值。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal(int val, MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>int</tt> 转换为 <tt>BigDecimal</tt>（根据上下文设置进行舍入）。在进行任何舍入之前，<tt>BigDecimal</tt> 的标度为零。
 
@param val 要转换为 <tt>BigDecimal</tt> 的 <tt>int</tt> 值。
@param  mc 要使用的上下文。
@throws ArithmeticException 如果结果不准确，但是舍入模式为 <tt>UNNECESSARY</tt>。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal(long val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>long</tt> 转换为 <tt>BigDecimal</tt>。<tt>BigDecimal</tt> 的标度为零。

@param val 要转换为 <tt>BigDecimal</tt> 的 <tt>long</tt> 值。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal(long val, MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>long</tt> 转换为 <tt>BigDecimal</tt>（根据上下文设置进行舍入）。在进行任何舍入之前，<tt>BigDecimal</tt> 的标度为零。
 
@param val 要转换为 <tt>BigDecimal</tt> 的 <tt>long</tt> 值。
@param  mc 要使用的上下文。
@throws ArithmeticException 如果结果不准确，但是舍入模式为 <tt>UNNECESSARY</tt>。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.math.BigDecimal java.math.BigDecimal.valueOf(long unscaledVal, int scale)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>long</tt> 非标度值和 <tt>int</tt> 标度转换为 <tt>BigDecimal</tt>。提供的此&ldquo;静态工厂方法&rdquo;优先于 (<tt>long</tt>, <tt>int</tt>) 构造方法，因为前者允许重用经常使用的 <tt>BigDecimal</tt> 值。

@param unscaledVal <tt>BigDecimal</tt> 的非标度值。
@param scale <tt>BigDecimal</tt> 的标度。
@return 其值为 <tt>(unscaledVal &times; 10<sup>-scale</sup>)</tt> 的 <tt>BigDecimal</tt>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.math.BigDecimal java.math.BigDecimal.valueOf(long val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <tt>long</tt> 值转换为具有零标度的 <tt>BigDecimal</tt>。提供的此&ldquo;静态工厂方法&rdquo;优先于 (<tt>long</tt>) 构造方法，因为前者允许重用经常使用的 <tt>BigDecimal</tt> 值。

@param val <tt>BigDecimal</tt> 的值。
@return 其值为 <tt>val</tt> 的 <tt>BigDecimal</tt>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.math.BigDecimal java.math.BigDecimal.valueOf(double val)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用 {@link Double#toString(double)} 方法提供的 <tt>double</tt> 规范的字符串表示形式将 <tt>double</tt> 转换为 <tt>BigDecimal</tt>。
 
<p><b>注：</b>这通常是将 <tt>double</tt>（或 <tt>float</tt>）转化为 <tt>BigDecimal</tt> 的首选方法，因为返回的值等于从构造 <tt>BigDecimal</tt>（使用 {@link Double#toString(double)} 得到的结果）得到的值。

@param  val 要转换为 <tt>BigDecimal</tt> 的 <tt>double</tt>。
@return 其值等于或约等于 <tt>val</tt> 值的 <tt>BigDecimal</tt>。
@throws NumberFormatException 如果 <tt>val</tt> 为无穷大或 NaN。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.add(BigDecimal augend)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个 <tt>BigDecimal</tt>，其值为 <tt>(this + augend)</tt>，其标度为 <tt>max(this.scale(), augend.scale())</tt>。

@param  augend 将添加到此 <tt>BigDecimal</tt> 中的值。
@return <tt>this + augend</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.add(BigDecimal augend, MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回其值为 <tt>(this + augend)</tt> 的 <tt>BigDecimal</tt>（根据上下文设置进行舍入）。

如果任一数字为零，并且精度设置为非零，则其他数字（必要时进行舍入）可以作为结果。

@param  augend 将添加到此 <tt>BigDecimal</tt> 中的值。
@param  mc 要使用的上下文。
@return <tt>this + augend</tt>，必要时进行舍入。
@throws ArithmeticException 如果结果不准确，但是舍入模式为 <tt>UNNECESSARY</tt>。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.subtract(BigDecimal subtrahend)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个 <tt>BigDecimal</tt>，其值为 <tt>(this - subtrahend)</tt>，其标度为 <tt>max(this.scale(), subtrahend.scale())</tt>。

@param  subtrahend 从此 <tt>BigDecimal</tt> 减去的值。
@return <tt>this - subtrahend</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.subtract(BigDecimal subtrahend, MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回其值为 <tt>(this - subtrahend)</tt> 的 <tt>BigDecimal</tt>（根据上下文设置进行舍入）。

如果 <tt>subtrahend</tt> 为零，则将其（必要时进行舍入）作为结果。如果为零，则该结果是 <tt>subtrahend.negate(mc)</tt>。

@param  subtrahend 从此 <tt>BigDecimal</tt> 减去的值。
@param  mc 要使用的上下文。
@return <tt>this - subtrahend</tt>，必要时进行舍入。
@throws ArithmeticException 如果结果不准确，但是舍入模式为 <tt>UNNECESSARY</tt>。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.multiply(BigDecimal multiplicand)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个 <tt>BigDecimal</tt>，其值为 <tt>(this &times; multiplicand)</tt>，其标度为 <tt>(this.scale() + multiplicand.scale())</tt>。

@param  multiplicand 乘以此 <tt>BigDecimal</tt> 的值。
@return <tt>this * multiplicand</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.multiply(BigDecimal multiplicand, MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回其值为 <tt>(this &times; multiplicand)</tt> 的 <tt>BigDecimal</tt>（根据上下文设置进行舍入）。

@param  multiplicand 乘以此 <tt>BigDecimal</tt> 的值。
@param  mc 要使用的上下文。
@return 必要时舍入的 <tt>this * multiplicand</tt>。
@throws ArithmeticException 如果结果不准确，但是舍入模式为 <tt>UNNECESSARY</tt>。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.divide(BigDecimal divisor, int scale, int roundingMode)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个 <tt>BigDecimal</tt>，其值为 <tt>(this / divisor)</tt>，其标度为指定标度。如果必须执行舍入，以生成具有指定标度的结果，则应用指定的舍入模式。
 
<p>相对于此遗留方法，应优先使用新的 {@link #divide(BigDecimal, int, RoundingMode)} 方法。
 
@param  divisor 此 <tt>BigDecimal</tt> 要除以的值。
@param  scale 要返回的 <tt>BigDecimal</tt> 商的标度。
@param  roundingMode 要应用的舍入模式。
@return <tt>this / divisor</tt>
@throws ArithmeticException 如果 <tt>divisor</tt> 为零，则 <tt>roundingMode==ROUND_UNNECESSARY</tt> 和指定的标度不足以准确地表示相除的结果。
@throws IllegalArgumentException 如果 <tt>roundingMode</tt> 不表示一个有效的舍入模式。
@see    #ROUND_UP
@see    #ROUND_DOWN
@see    #ROUND_CEILING
@see    #ROUND_FLOOR
@see    #ROUND_HALF_UP
@see    #ROUND_HALF_DOWN
@see    #ROUND_HALF_EVEN
@see    #ROUND_UNNECESSARY

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.divide(BigDecimal divisor, int scale, RoundingMode roundingMode)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个 <tt>BigDecimal</tt>，其值为 <tt>(this / divisor)</tt>，其标度为指定标度。如果必须执行舍入，以生成具有指定标度的结果，则应用指定的舍入模式。
 
@param  divisor 此 <tt>BigDecimal</tt> 要除以的值。
@param  scale 要返回的 <tt>BigDecimal</tt> 商的标度。
@param  roundingMode 要应用的舍入模式。
@return <tt>this / divisor</tt>
@throws ArithmeticException 如果 <tt>divisor</tt> 为零，则 <tt>roundingMode==RoundingMode.UNNECESSARY</tt> 和指定的标度不足以准确地表示相除的结果。
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.divide(BigDecimal divisor, int roundingMode)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个 <tt>BigDecimal</tt>，其值为 <tt>(this / divisor)</tt>，其标度为 <tt>this.scale()</tt>。如果必须执行舍入，以生成具有给定标度的结果，则应用指定的舍入模式。
 
<p>相对于此遗留方法，应优先使用新的 {@link #divide(BigDecimal, RoundingMode)} 方法。
 
@param  divisor 此 <tt>BigDecimal</tt> 要除以的值。
@param  roundingMode 要应用的舍入模式。
@return <tt>this / divisor</tt>
@throws ArithmeticException 如果 <tt>divisor==0</tt> 或者 <tt>roundingMode==ROUND_UNNECESSARY</tt> 和 <tt>this.scale()</tt> 不足以准确地表示相除的结果。
@throws IllegalArgumentException 如果 <tt>roundingMode</tt> 不表示一个有效的舍入模式。
@see    #ROUND_UP
@see    #ROUND_DOWN
@see    #ROUND_CEILING
@see    #ROUND_FLOOR
@see    #ROUND_HALF_UP
@see    #ROUND_HALF_DOWN
@see    #ROUND_HALF_EVEN
@see    #ROUND_UNNECESSARY

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.divide(BigDecimal divisor, RoundingMode roundingMode)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个 <tt>BigDecimal</tt>，其值为 <tt>(this / divisor)</tt>，其标度为 <tt>this.scale()</tt>。如果必须执行舍入，以生成具有给定标度的结果，则应用指定的舍入模式。
 
@param  divisor 此 <tt>BigDecimal</tt> 要除以的值。
@param  roundingMode 要应用的舍入模式。
@return <tt>this / divisor</tt>
@throws ArithmeticException 如果 <tt>divisor==0</tt> 或者 <tt>roundingMode==RoundingMode.UNNECESSARY</tt> 和 <tt>this.scale()</tt> 不足以准确地表示相除的结果。
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.divide(BigDecimal divisor)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个 <tt>BigDecimal</tt>，其值为 <tt>(this / divisor)</tt>，其首选标度为 <tt>(this.scale() - divisor.scale())</tt>；如果无法表示准确的商值（因为它有无穷的十进制扩展），则抛出 <tt>ArithmeticException</tt>。

@param  divisor 此 <tt>BigDecimal</tt> 要相除的值。
@throws ArithmeticException 如果准确的商值没有无穷的十进制扩展
@return <tt>this / divisor</tt>
@since 1.5
@author Joseph D. Darcy

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.divide(BigDecimal divisor, MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回其值为 <tt>(this / divisor)</tt> 的 <tt>BigDecimal</tt>（根据上下文设置进行舍入）。

@param  divisor 此 <tt>BigDecimal</tt> 要除以的值。
@param  mc 要使用的上下文。
@return <tt>this / divisor</tt>，必要时进行舍入。
@throws ArithmeticException 如果结果不准确，但是舍入模式为 <tt>UNNECESSARY</tt> 或 <tt>mc.precision == 0</tt>，并且商值具有无穷的十进制扩展。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.divideToIntegralValue(BigDecimal divisor)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <tt>BigDecimal</tt>，其值为向下舍入所得商值 <tt>(this / divisor)</tt> 的整数部分。该结果的首选标度为 <code>(this.scale() - divisor.scale())</code>。

@param  divisor 此 <tt>BigDecimal</tt> 要除以的值。
@return <tt>this / divisor</tt> 的整数部分。
@throws ArithmeticException 如果 <tt>divisor==0</tt>
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.divideToIntegralValue(BigDecimal divisor, MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <tt>BigDecimal</tt>，其值为 <tt>(this / divisor)</tt> 的整数部分。因为准确商值的整数部分与舍入模式无关，所以舍入模式不影响此方法返回的值。该结果的首选标度是 <code>(this.scale() - divisor.scale())</code>。如果准确商值的整数部分需要的位数多于 <tt>mc.precision</tt>，则抛出 <tt>ArithmeticException</tt>。

@param  divisor 此 <tt>BigDecimal</tt> 要相除的值。
@param  mc 要使用的上下文。
@return <tt>this / divisor</tt> 的整数部分。
@throws ArithmeticException 如果 <tt>divisor==0</tt>
@throws ArithmeticException 如果 <tt>mc.precision</tt> &gt; 0，并且该结果需要的精度大于 <tt>mc.precision</tt>。
@since  1.5
@author Joseph D. Darcy

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.remainder(BigDecimal divisor)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回其值为 <tt>(this % divisor)</tt> 的 <tt>BigDecimal</tt>。
 
<p>余数由 <tt>this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))</tt> 给出。注意，这不是模操作（结果可以为负）。

@param  divisor 此 <tt>BigDecimal</tt> 要除以的值。
@return <tt>this % divisor</tt>。
@throws ArithmeticException 如果 <tt>divisor==0</tt>
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.remainder(BigDecimal divisor, MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回其值为 <tt>(this % divisor)</tt> 的 <tt>BigDecimal</tt>（根据上下文设置进行舍入）。<tt>MathContext</tt> 设置会影响用于计算余数的隐式除法。余数计算本身要进行准确的定义。因此，余数包含的数字个数可能多于 <tt>mc.getPrecision()</tt>。
 
<p>余数由 <tt>this.subtract(this.divideToIntegralValue(divisor, mc).multiply(divisor))</tt> 给出。注意，这不是模操作（结果可以为负）。

@param  divisor 此 <tt>BigDecimal</tt> 要相除的值。
@param  mc 要使用的上下文。
@return <tt>this % divisor</tt>，必要时进行舍入。
@throws ArithmeticException 如果 <tt>divisor==0</tt>
@throws ArithmeticException 如果结果不准确，但舍入模式为 <tt>UNNECESSARY</tt>，或者 <tt>mc.precision</tt> &gt; 0，并且 <tt>this.divideToIntgralValue(divisor)</tt> 的结果要求的精度大于 <tt>mc.precision</tt>。
@see    #divideToIntegralValue(java.math.BigDecimal, java.math.MathContext)
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal[] java.math.BigDecimal.divideAndRemainder(BigDecimal divisor)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回由两个元素组成的 <tt>BigDecimal</tt> 数组，该数组包含 <tt>divideToIntegralValue</tt> 的结果，后跟对两个操作数计算所得到的 <tt>remainder</tt>。
 
<p>注意，如果同时需要整数商和余数，则此方法比分别使用 <tt>divideToIntegralValue</tt> 和 <tt>remainder</tt> 方法更快速，因为相除仅需执行一次。

@param  divisor 此 <tt>BigDecimal</tt> 要相除的值和计算的余数。
@return 由两个元素组成的 <tt>BigDecimal</tt> 数组：商值（<tt>divideToIntegralValue</tt> 的结果）是初始元素，余数是最终元素。
@throws ArithmeticException 如果 <tt>divisor==0</tt>
@see    #divideToIntegralValue(java.math.BigDecimal, java.math.MathContext)
@see    #remainder(java.math.BigDecimal, java.math.MathContext)
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal[] java.math.BigDecimal.divideAndRemainder(BigDecimal divisor, MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回由两个元素组成的 <tt>BigDecimal</tt> 数组，该数组包含 <tt>divideToIntegralValue</tt> 的结果，后跟根据上下文设置对两个操作数进行舍入计算所得到的 <tt>remainder</tt> 的结果。
 
<p>注意，如果同时需要整数商和余数，则此方法比分别使用 <tt>divideToIntegralValue</tt> 和 <tt>remainder</tt> 方法更快速，因为相除仅需执行一次。

@param  divisor 此 <tt>BigDecimal</tt> 要相除的值和计算的余数。
@param  mc 要使用的上下文。
@return 由两个元素组成的 <tt>BigDecimal</tt> 数组：商值（<tt>divideToIntegralValue</tt> 的结果）是初始元素，余数是最终元素。
@throws ArithmeticException 如果 <tt>divisor==0</tt>
@throws ArithmeticException 如果结果不准确，但舍入模式为 <tt>UNNECESSARY</tt>，或者 <tt>mc.precision</tt> &gt; 0，并且 <tt>this.divideToIntgralValue(divisor)</tt> 的结果要求的精度大于 <tt>mc.precision</tt>。
@see    #divideToIntegralValue(java.math.BigDecimal, java.math.MathContext)
@see    #remainder(java.math.BigDecimal, java.math.MathContext)
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.pow(int n)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回其值为 <tt>(this<sup>n</sup>)</tt> 的 <tt>BigDecimal</tt>，准确计算该幂，使其具有无限精度。
 
<p>参数 <tt>n</tt> 必须在 0 到 999999999（包括）之间。<tt>ZERO.pow(0)</tt> 返回 {@link #ONE}。

注意，未来版本可能会扩展此方法允许的指数范围。

@param  n 此 <tt>BigDecimal</tt> 的幂。
@return <tt>this<sup>n</sup></tt>
@throws ArithmeticException 如果 <tt>n</tt> 超出范围。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.pow(int n, MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回其值为 <tt>(this<sup>n</sup>)</tt> 的 <tt>BigDecimal</tt>。当前实现使用的是 ANSI 标准 X3.274-1996 中定义的核心算法（根据上下文设置进行舍入）。一般情况下，返回的数值在具有选择精度的精确数值的两个 ulp 中。注意，未来版本可以使用不同的算法，以减少允许的错误范围，并增加允许的指数范围。

<p>X3.274-1996 算法为：

 <ul>
<li> 如果出现以下情况，则抛出 <tt>ArithmeticException</tt> 异常
  <ul>
    <li><tt>abs(n) &gt; 999999999</tt>
<li><tt>mc.precision == 0</tt> 且 <tt>n &lt; 0</tt>
<li><tt>mc.precision &gt; 0</tt> 且 <tt>n</tt> 大于 <tt>mc.precision</tt> 
  </ul>

<li> 如果 <tt>n</tt> 为零，则返回 {@link #ONE}（即使 <tt>this</tt> 为零），否则
 <ul>
<li> 如果 <tt>n</tt> 为正数，则通过重复的平方技术将此结果计算到一个累加器中。每个附带累加器的乘法都使用与 <tt>mc</tt> 中相同的数学上下文设置，增加到 <tt>mc.precision + elength + 1</tt> 的精度除外，其中 <tt>elength</tt> 表示 <tt>n</tt> 中的十进制数字的个数。
<li> 如果 <tt>n</tt> 为负数，则将 <tt>n</tt> 视为正数计算其结果；然后使用上面指定的工作精度，用一除以此值。

<li> 然后将正数或负数的最终值舍入为目标精度。
   </ul>
 </ul>

@param  n 此 <tt>BigDecimal</tt> 的幂。
@param  mc 要使用的上下文。
@return 使用 ANSI 标准 X3.274-1996 算法的 <tt>this<sup>n</sup></tt>
@throws ArithmeticException 如果该结果不准确，但是舍入模式为 <tt>UNNECESSARY</tt>，或者 <tt>n</tt> 超出范围。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.abs()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <tt>BigDecimal</tt>，其值为此 <tt>BigDecimal</tt> 的绝对值，其标度为 <tt>this.scale()</tt>。

@return <tt>abs(this)</tt>

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.abs(MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回其值为此 <tt>BigDecimal</tt> 绝对值的 <tt>BigDecimal</tt>（根据上下文设置进行舍入）。

@param  mc 要使用的上下文。
@return <tt>abs(this)</tt>，必要时进行舍入。
@throws ArithmeticException 如果结果不准确，但是舍入模式为 <tt>UNNECESSARY</tt>。
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.negate()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <tt>BigDecimal</tt>，其值为 <tt>(-this)</tt>，其标度为 <tt>this.scale()</tt>。

@return <tt>-this</tt>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.negate(MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回其值为 <tt>(-this)</tt> 的 <tt>BigDecimal</tt>（根据上下文设置进行舍入）。

@param  mc 要使用的上下文。
@return <tt>abs(this)</tt>，必要时进行舍入。
@throws ArithmeticException 如果结果不准确，但是舍入模式为 <tt>UNNECESSARY</tt>。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.plus()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <tt>BigDecimal</tt>，其值为 <tt>(+this)</tt>，其标度为 <tt>this.scale()</tt>。
 
<p>此方法仅返回此 <tt>BigDecimal</tt>，该方法与一元减方法 {@link #negate()} 对称。
 
@return <tt>this</tt>。
@see #negate()
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.plus(MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回其值为 <tt>(+this)</tt> 的 <tt>BigDecimal</tt>（根据上下文设置进行舍入）。
 
<p>此方法的效果与 {@link #round(MathContext)} 方法的效果相同。

@param  mc 要使用的上下文。
@return <tt>this</tt>，必要时进行舍入。零结果具有的标度为 0。
@throws ArithmeticException 如果结果不准确，但是舍入模式为 <tt>UNNECESSARY</tt>。
@see    #round(MathContext)
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.math.BigDecimal.signum()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <tt>BigDecimal</tt> 的正负号函数。

@return 当此 <tt>BigDecimal</tt> 的值为负、零或正时，返回 -1、0 或 1。

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.math.BigDecimal.scale()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <tt>BigDecimal</tt> 的<i>标度</i>。如果为零或正数，则标度是小数点后的位数。如果为负数，则将该数的非标度值乘以 10 的负 scale 次幂。例如，<tt>-3</tt> 标度是指非标度值乘以 1000。

@return 此 <tt>BigDecimal</tt> 的标度。

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.math.BigDecimal.precision()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <tt>BigDecimal</tt> 的<i>精度</i>。（精度是非标度值的数字个数。）

<p>零值的精度是 1。

@return 此 <tt>BigDecimal</tt> 的精度。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigInteger java.math.BigDecimal.unscaledValue()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回其值为此 <tt>BigDecimal</tt> 的<i>非标度值</i> 的 <tt>BigInteger</tt>。（计算 <tt>(this * 10<sup>this.scale()</sup>)</tt>。）

@return 此 <tt>BigDecimal</tt> 的非标度值。
@since  1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.round(MathContext mc)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回根据 <tt>MathContext</tt> 设置进行舍入后的 <tt>BigDecimal</tt>。如果精度设置为 0，则不进行任何舍入操作。
 
<p>此方法的效果与 {@link #plus(MathContext)} 方法的效果相同。

@param  mc 要使用的上下文。
@return 根据 <tt>MathContext</tt> 设置舍入后的 <tt>BigDecimal</tt>。
@throws ArithmeticException 如果舍入模式为 <tt>UNNECESSARY</tt>，并且 <tt>BigDecimal</tt> 操作要求进行舍入。
@see    #plus(MathContext)
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.setScale(int newScale, RoundingMode roundingMode)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <tt>BigDecimal</tt>，其标度为指定值，其非标度值通过此 <tt>BigDecimal</tt> 的非标度值乘以或除以十的适当次幂来确定，以维护其总值。如果该操作减少标度，则非标度值必须被除（而不是乘），并且该值可以更改；在这种情况下，将指定的舍入模式应用到除法中。

@param  newScale 要返回的 <tt>BigDecimal</tt> 值的标度。
@param  roundingMode 要应用的舍入模式。
@return 一个 <tt>BigDecimal</tt>，其标度为指定值，其非标度值可以通过此 <tt>BigDecimal</tt> 的非标度值乘以或除以十的适当次幂来确定，以维护其总值。
@throws ArithmeticException 如果 <tt>roundingMode==UNNECESSARY</tt>，并且指定的标度操作要求进行舍入。
@see    RoundingMode
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.setScale(int newScale, int roundingMode)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个 <tt>BigDecimal</tt>，其标度为指定值，其非标度值通过此 <tt>BigDecimal</tt> 的非标度值乘以或除以十的适当次幂来确定，以维护其总值。如果该操作减少标度，则非标度值必须被除（而不是乘），并且该值可以更改；在这种情况下，将指定的舍入模式应用到除法中。
 
<p>注意，由于 BigDecimal 对象是不可变的，此方法的调用<i>不会</i> 导致初始对象被修改，这与使用名为 <tt>set<i>X</i></tt> 变异字段 <tt><i>X</i></tt> 方法的常规约定相反。相反，<tt>setScale</tt> 返回具有适当标度的对象；返回的对象不一定是新分配的。
 
<p>相对于此遗留方法，应优先使用新的 {@link #setScale(int, RoundingMode)} 方法。
 
@param  newScale 要返回的 <tt>BigDecimal</tt> 值的标度。
@param  roundingMode 要应用的舍入模式。
@return 一个 <tt>BigDecimal</tt>，其标度为指定值，其非标度值可以通过此 <tt>BigDecimal</tt> 的非标度值乘以或除以十的适当次幂来确定。
@throws ArithmeticException 如果 <tt>roundingMode==ROUND_UNNECESSARY</tt>，并且指定的标度操作要求进行舍入。
@throws IllegalArgumentException 如果 <tt>roundingMode</tt> 不表示一个有效的舍入模式。
@see    #ROUND_UP
@see    #ROUND_DOWN
@see    #ROUND_CEILING
@see    #ROUND_FLOOR
@see    #ROUND_HALF_UP
@see    #ROUND_HALF_DOWN
@see    #ROUND_HALF_EVEN
@see    #ROUND_UNNECESSARY

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.setScale(int newScale)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个 <tt>BigDecimal</tt>，其标度为指定值，其值在数值上等于此 <tt>BigDecimal</tt> 的值。如果这不可能，则抛出 <tt>ArithmeticException</tt>。
 
<p>此调用通常用于增加标度，在这种情况下，可以保证存在指定标度和正确值的 <tt>BigDecimal</tt>。如果调用方知道 <tt>BigDecimal</tt>在其小数部分的结尾有足够多的零（即其整数值中的十的因子），则该调用也可用于减少标度，以允许重新标度，而不更改其值。
 
<p>此方法返回与 <tt>setScale</tt> 的两个参数版本相同的结果，但是，为调用方省去了指定舍入模式的麻烦（舍入模式不影响结果）。
 
<p>注意，由于 <tt>BigDecimal</tt> 对象是不可变的，因此此方法的调用<i>不会</i> 导致初始对象被修改，这与使用名为 <tt>set<i>X</i></tt> 变异字段 <tt><i>X</i></tt> 方法的常规约定相反。相反，<tt>setScale</tt> 返回具有适当标度的对象；返回的对象不一定是新分配的。

@param  newScale 要返回的 <tt>BigDecimal</tt> 值的标度。
@return 一个 <tt>BigDecimal</tt>，其标度为指定值，其非标度值可以通过此 <tt>BigDecimal</tt> 的非标度值乘以或除以十的适当次幂来确定，以维护其总值。
@throws ArithmeticException 如果指定的标度操作要求进行舍入。
@see    #setScale(int, int)
@see    #setScale(int, RoundingMode)

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.movePointLeft(int n)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个 <tt>BigDecimal</tt>，它等效于将该值的小数点向左移动 <tt>n</tt> 位。如果 <tt>n</tt> 为非负数，则调用仅将 <tt>n</tt> 添加到该标度。如果 <tt>n</tt> 为负数，则该调用等效于 <tt>movePointRight(-n)</tt>。此调用返回的 <tt>BigDecimal</tt> 的值为 <tt>(this &times; 10<sup>-n</sup>)</tt>，标度为 <tt>max(this.scale()+n, 0)</tt>。

@param  n 将小数点向左移动的位数。
@return 一个 <tt>BigDecimal</tt>，它等效于将该值的小数点向左移动 <tt>n</tt> 位。
@throws ArithmeticException 如果标度溢出。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.movePointRight(int n)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个 <tt>BigDecimal</tt>，它等效于将该值的小数点向右移动 <tt>n</tt> 位。如果 <tt>n</tt> 为非负数，则该调用仅从该标度减去 <tt>n</tt>。如果 <tt>n</tt> 为负，则该调用等效于 <tt>movePointLeft(-n)</tt>。此调用返回的 <tt>BigDecimal</tt> 的值为 <tt>(this &times; 10<sup>n</sup>)</tt>，标度为 <tt>max(this.scale()-n, 0)</tt>。

@param  n 将小数点向右移动的位数。
@return 一个 <tt>BigDecimal</tt>，它等效于将该值的小数点向右移动 <tt>n</tt> 位。
@throws ArithmeticException 如果标度溢出。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.scaleByPowerOfTen(int n)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回其数值等于 (<tt>this</tt> * 10<sup>n</sup>) 的 BigDecimal。该结果的标度为 <tt>(this.scale() - n)</tt>。

@throws ArithmeticException 如果该标度的范围超出 32 位整数的范围。

@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.stripTrailingZeros()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回数值上等于此小数，但从该表示形式移除所有尾部零的 <tt>BigDecimal</tt>。例如，从 <tt>BigDecimal</tt> 值 <tt>600.0</tt> 中移除尾部零，该值具有的 [<tt>BigInteger</tt>, <tt>scale</tt>] 组件等于 [6000, 1]，使用 [<tt>BigInteger</tt>, <tt>scale</tt>] 组件生成的 <tt>6E2</tt> 等于 [6, -2]

@return 数值上等于移除所有尾部零的 <tt>BigDecimal</tt>。
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.math.BigDecimal.compareTo(BigDecimal val)
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <tt>BigDecimal</tt> 与指定的 <tt>BigDecimal</tt> 比较。根据此方法，值相等但具有不同标度的两个 <tt>BigDecimal</tt> 对象（如，2.0 和 2.00）被认为是相等的。相对六个 boolean 比较运算符 (&lt;, ==, &gt;, &gt;=, !=, &lt;=) 中每一个运算符的各个方法，优先提供此方法。建议使用以下语句执行上述比较：<tt>(x.compareTo(y)</tt> &lt;<i>op</i>&gt; <tt>0)</tt>，其中 &lt;<i>op</i>&gt; 是六个比较运算符之一。

@param  val 将此 <tt>BigDecimal</tt> 与之比较的 <tt>BigDecimal</tt>。
@return  当此 <tt>BigDecimal</tt> 在数字上小于、等于或大于 <tt>val</tt> 时，返回 -1、0 或 1。

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.math.BigDecimal.equals(Object x)
<!-- END KEY -->
<!-- BEGIN DATA -->
比较此 <tt>BigDecimal</tt> 与指定的 <tt>Object</tt> 的相等性。与 {@link #compareTo(BigDecimal) compareTo} 不同，仅当两个 <tt>BigDecimal</tt> 对象的值和标度都相等时，此方法才认为它们相等（因此通过此方法进行比较时，2.0 不等于 2.00）。

@param  x 将与此 <tt>BigDecimal</tt> 进行比较的 <tt>Object</tt>。
@return 当且仅当指定的 <tt>Object</tt> 为 <tt>BigDecimal</tt>，并且其值和标度都等于此 <tt>BigDecimal</tt> 的值和标度时，返回 <tt>true</tt>。
@see    #compareTo(java.math.BigDecimal)
@see    #hashCode

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.min(BigDecimal val)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <tt>BigDecimal</tt> 和 <tt>val</tt> 的最小值。

@param  val 要计算最小值的值。
@return 其值为 <tt>BigDecimal</tt> 和 <tt>val</tt> 中较小值的 <tt>BigDecimal</tt>。根据 {@link #compareTo(BigDecimal) compareTo} 方法的定义，如果它们相等，则返回 <tt>this</tt>。
@see    #compareTo(java.math.BigDecimal)

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.max(BigDecimal val)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <tt>BigDecimal</tt> 和 <tt>val</tt> 的最大值。

@param  val 要计算最大值的值。
@return 其值为此 <tt>BigDecimal</tt> 和 <tt>val</tt> 中较大值的 <tt>BigDecimal</tt>。根据 {@link #compareTo(BigDecimal) compareTo} 方法的定义，如果它们相等，则返回 <tt>this</tt>。
@see    #compareTo(java.math.BigDecimal)

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.math.BigDecimal.hashCode()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <tt>BigDecimal</tt> 的哈希码。注意，数值上相等但标度不同的两个 <tt>BigDecimal</tt> 对象（如，2.0 和 2.00）通常<i>没有</i> 相同的哈希码。

@return 此 <tt>BigDecimal</tt> 的哈希码。
@see #equals(Object)

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.math.BigDecimal.toString()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <tt>BigDecimal</tt> 的字符串表示形式，如果需要指数，则使用科学记数法。
 
<p>根据以下步骤可创建 <tt>BigDecimal</tt> 的标准的规范化字符串形式：首先，使用不带前导零的字符 <tt>'0'</tt> 至 <tt>'9'</tt>（如果其值为零，则使用单个 <tt>'0'</tt> 字符）将 <tt>BigDecimal</tt> 的非标度值的绝对值转换为以十为基数的字符串。
 
<p>其次，计算<i>调整的指数</i>；这是无效的标度，加上转换的非标度值中的字符数减 1。即：<tt>-scale+(ulength-1)</tt>，其中 <tt>ulength</tt> 是十进制数字中非标度值的绝对值的长度（其<i>精度</i>）。
 
<p>如果该标度大于或等于零，并且调整的指数大于或等于 <tt>-6</tt>，则在不使用指数记数法的情况下将该数转换为字符形式。在这种情况下，如果标度为零，则不添加小数点，如果标度为正数，则插入小数点，且标度指定了小数点右边的字符个数。必要时，将字符 <tt>'0'</tt> 添加到转换的非标度值的左边。如果插入后小数点前面没有字符，则以传统字符 <tt>'0'</tt> 为前缀。
 
<p>否则（即：如果标度为负数，或者调整的指数小于 <tt>-6</tt>），使用指数记数法将该数转换为字符形式。在这种情况下，如果转换后的 <tt>BigInteger</tt> 多于一位数，则小数点插入在第一个数字之后。然后，将字符形式的指数作为转换的非标度值（也许具有插入的小数点）的后缀；这包含字母 <tt>'E'</tt> 和直接跟在其后的转换为字符形式的调整指数。后者的基数为十，使用的字符是 <tt>'0'</tt> 到 <tt>'9'</tt>，没有前导零，并且，如果调整的指数为负数，则总是以符号字符 <tt>'-'</tt> (<tt>'\u002D'</tt>) 为前缀，否则以 <tt>'+'</tt> (<tt>'\u002B'</tt>) 为前缀。
 
<p>最后，如果非标度值小于零，则整个字符串以减号 <tt>'-'</tt> (<tt>'\u002D'</tt>) 为前缀。如果非标度值为零或正数，则不使用符号字符作为前缀。
 
<p><b>示例：</b>
<p>对于左边的每个表示形式 [<i>unscaled value</i>, <i>scale</i>]，得到的字符串显示在右边。
 <pre>
 [123,0]      &quot;123&quot;
 [-123,0]     &quot;-123&quot;
 [123,-1]     &quot;1.23E+3&quot;
 [123,-3]     &quot;1.23E+5&quot;
 [123,1]      &quot;12.3&quot;
 [123,5]      &quot;0.00123&quot;
 [123,10]     &quot;1.23E-8&quot;
 [-123,12]    &quot;-1.23E-10&quot;
 </pre>

<b>注：</b>
 <ol>

<li>可区分的 <tt>BigDecimal</tt> 值和此转换的结果之间存在一对一的映射关系。即：每个可区分的 <tt>BigDecimal</tt> 值（非标度值和标度）都有唯一的字符串表示形式，作为使用 <tt>toString</tt> 的结果。如果使用 {@link #BigDecimal(String)} 构造方法将该字符串表示形式转换为 <tt>BigDecimal</tt>，则将恢复初始值。
 
<li>给定的数产生的字符串总是相同的；它不受语言环境的影响。这意味着它可以用作交换十进制数据的规范化字符串表示形式，或用作 Hashtable 的关键字等等。{@link java.text.NumberFormat} 类及其子类可以处理区分语言环境的数的格式化和分析。
 
<li>{@link #toEngineeringString} 方法可用于在工程计数法中表示带有指数的数。{@link #setScale(int,RoundingMode) setScale} 方法可用于对 <tt>BigDecimal</tt> 进行舍入，使其小数点后的位数为已知位数。
 
<li>使用 <tt>Character.forDigit</tt> 提供的数字到字符的映射关系。

 </ol>

@return  此 <tt>BigDecimal</tt> 的字符串表示形式。
@see    Character#forDigit
@see    #BigDecimal(java.lang.String)

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.math.BigDecimal.toEngineeringString()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <tt>BigDecimal</tt> 的字符串表示形式，需要指数时，则使用工程计数法。
 
<p>返回如 {@link #toString()} 方法中所描述的表示 <tt>BigDecimal</tt> 的字符串，不包括使用指数记数法的情况，将十的幂调整为三的倍数（工程记数法），这样，非零值的整数部分的范围是 1 到 999。如果对零值使用指数记数法，则使用小数点和小数的一（或二）个零数字，以便保留零值的标度。注意，与 {@link #toString()} 的输出不同，如果使用 {@linkplain #BigDecimal(String) string constructor} 将输出字符串转换为 <tt>BigDecimal</tt>，则此方法的输出<em>不</em> 保证恢复此 <tt>BigDecimal</tt> 的相同 [integer, scale] 对。此方法满足以下较弱约束，即产生的结果在数值上始终等于将字符串构造方法应用到方法的输出得到的结果。

@return 此 <tt>BigDecimal</tt> 的字符串表示形式，如果需要指数，则使用工程记数法。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.math.BigDecimal.toPlainString()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回不带指数字段的此 <tt>BigDecimal</tt> 的字符串表示形式。对于具有正标度的值，小数点右边的数字个数用于指示标度。对于具有零或负标度的值，生成得到的字符串，好像将该值转换为在数值上等于具有零标度的值一样，并且好像零标度值的所有尾部零都出现在该结果中。

如果非标度值小于零，则整个字符串以减号 '-' (<tt>'\u002D'</tt>) 为前缀。如果非标度值为零或正数，则没有任何符号字符作为前缀。

注意，如果将此方法的结果传递到 {@linkplain #BigDecimal(String) string constructor}，则只需要恢复此 <tt>BigDecimal</tt> 的数值；新的 <tt>BigDecimal</tt> 的表示形式可以有不同的标度。尤其是，如果此 <tt>BigDecimal</tt> 具有负标度，则在由字符串构造方法进行处理时，此方法产生的字符串将具有零标度。

（此方法的作用类似于 1.4 和更早版本中的 <tt>toString</tt> 方法。）

@return 不带指数字段的此 <tt>BigDecimal</tt> 的字符串表示形式。
@since 1.5
@see #toString()
@see #toEngineeringString()

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigInteger java.math.BigDecimal.toBigInteger()
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <tt>BigDecimal</tt> 转换为 <tt>BigInteger</tt>。此转换类似于 <a
 href="http://java.sun.com/docs/books/jls/html/">Java Language Specification</a> 中定义的从 <tt>double</tt> 到 <tt>long</tt> 的<a
 href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25363"><i>基本收缩转换</i></a>：将丢弃此 <tt>BigDecimal</tt> 的小数部分。注意，此转换会丢失关于 <tt>BigDecimal</tt> 值的精度信息。
 <p>
要在转换不准确时（即当丢弃非零小数部分时）抛出异常，请使用 {@link #toBigIntegerExact()} 方法。

@return 转换为 <tt>BigInteger</tt> 的此 <tt>BigDecimal</tt>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigInteger java.math.BigDecimal.toBigIntegerExact()
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <tt>BigDecimal</tt> 转换为 <tt>BigInteger</tt>，以检查丢失的信息。如果此 <tt>BigDecimal</tt> 具有非零小数部分，则抛出一个异常。

@return 转换为 <tt>BigInteger</tt> 的此 <tt>BigDecimal</tt>。
@throws ArithmeticException 如果 <tt>this</tt> 具有非零小数部分。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public long java.math.BigDecimal.longValue()
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <tt>BigDecimal</tt> 转换为 <tt>long</tt>。此转换类似于 <a  href="http://java.sun.com/docs/books/jls/html/">Java Language Specification</a> 中定义的从 <tt>double</tt> 到 <tt>short</tt> 的<a  href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25363"><i>基本收缩转换</i></a>：将丢弃此 <tt>BigDecimal</tt> 的小数部分，并且如果生成的 &quot;<tt>BigInteger</tt>&quot; 太大而不适合用 <tt>long</tt> 表示，则仅返回 64 位低位字节。注意，此转换会丢失关于此 <tt>BigDecimal</tt> 值的总大小和精度的信息，并返回带有相反符号的结果。
 
@return 转换为 <tt>long</tt> 的此 <tt>BigDecimal</tt>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public long java.math.BigDecimal.longValueExact()
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <tt>BigDecimal</tt> 转换为 <tt>long</tt>，以检查丢失的信息。如果此 <tt>BigDecimal</tt> 具有非零小数部分，或者超出 <tt>long</tt> 结果的可能范围，则抛出 <tt>ArithmeticException</tt>。

@return 转换为 <tt>long</tt> 的此 <tt>BigDecimal</tt>。
@throws ArithmeticException 如果 <tt>this</tt> 具有非零小数部分，或者不适合用 <tt>long</tt> 表示。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.math.BigDecimal.intValue()
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <tt>BigDecimal</tt> 转换为 <tt>int</tt>。此转换类似于 <a  href="http://java.sun.com/docs/books/jls/html/">Java Language Specification</a> 中定义的从 <tt>double</tt> 到 <tt>short</tt> 的<a  href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25363"><i>基本收缩转换</i></a>：将丢弃此 <tt>BigDecimal</tt> 的所有小数部分，并且如果生成的 &quot;<tt>BigInteger</tt>&quot; 太大而不适合用 <tt>int</tt> 表示，则仅返回 32 位低位字节。注意，此转换会丢失关于此 <tt>BigDecimal</tt> 值的总大小和精度的信息，并返回带有相反符号的结果。
 
@return 转换为 <tt>int</tt> 的此 <tt>BigDecimal</tt>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.math.BigDecimal.intValueExact()
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <tt>BigDecimal</tt> 转换为 <tt>int</tt>，以检查丢失的信息。如果此 <tt>BigDecimal</tt> 具有非零小数部分，或者超出 <tt>int</tt> 结果的可能范围，则抛出 <tt>ArithmeticException</tt>。

@return 转换为 <tt>int</tt> 的此 <tt>BigDecimal</tt>。
@throws ArithmeticException 如果 <tt>this</tt> 具有非零小数部分，或者不适合用 <tt>int</tt> 表示。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public short java.math.BigDecimal.shortValueExact()
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <tt>BigDecimal</tt> 转换为 <tt>short</tt>，以检查丢失的信息。如果此 <tt>BigDecimal</tt> 具有非零小数部分，或者超出 <tt>short</tt> 结果的可能范围，则抛出 <tt>ArithmeticException</tt>。

@return 转换为 <tt>short</tt> 的此 <tt>BigDecimal</tt>。
@throws ArithmeticException 如果 <tt>this</tt> 具有非零小数部分，或者不适合用 <tt>short</tt> 表示。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public byte java.math.BigDecimal.byteValueExact()
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <tt>BigDecimal</tt> 转换为 <tt>byte</tt>，以检查丢失的信息。如果此 <tt>BigDecimal</tt> 具有非零小数部分，或者超出 <tt>byte</tt> 结果的可能范围，则抛出 <tt>ArithmeticException</tt>。

@return 转换为 <tt>byte</tt> 的此 <tt>BigDecimal</tt>。
@throws ArithmeticException 如果 <tt>this</tt> 具有非零小数部分，或者不适合用 <tt>byte</tt> 表示。
@since  1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public float java.math.BigDecimal.floatValue()
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <tt>BigDecimal</tt> 转换为 <tt>float</tt>。此转换类似于 <a  href="http://java.sun.com/docs/books/jls/html/">Java Language Specification</a> 中定义的从 <tt>double</tt> 到 <tt>float</tt> 的<a  href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25363"><i>基本收缩转换</i></a>：如此 <tt>BigDecimal</tt> 的值太大而不能表示为 <tt>float</tt>，则将其适当地转换为 {@link Float#NEGATIVE_INFINITY} 或 {@link Float#POSITIVE_INFINITY}。注意，即使在返回值为有限值的情况下，此转换也可能丢失关于 <tt>BigDecimal</tt> 值精度的信息。
 
@return 转换为 <tt>float</tt> 的此 <tt>BigDecimal</tt>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public double java.math.BigDecimal.doubleValue()
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <tt>BigDecimal</tt> 转换为 <tt>double</tt>。此转换类似于 <a  href="http://java.sun.com/docs/books/jls/html/">Java Language Specification</a> 中定义的从 <tt>double</tt> 到 <tt>float</tt> 的 <a  href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25363"><i>基本收缩转换</i></a>：如果此 <tt>BigDecimal</tt> 的数量太大而不能表示为 <tt>double</tt>，则将其适当地转换为 {@link Double#NEGATIVE_INFINITY} 或 {@link Double#POSITIVE_INFINITY}。注意，即使在返回值为有限值的情况下，此转换也可能丢失关于 <tt>BigDecimal</tt> 值精度的信息。
 
@return 转换为 <tt>double</tt> 的此 <tt>BigDecimal</tt>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.math.BigDecimal java.math.BigDecimal.ulp()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <tt>BigDecimal</tt> 的 ulp（最后一位的单位）的大小。非零 <tt>BigDecimal</tt> 值的 ulp 是此值与下一个具有相同位数的较大 <tt>BigDecimal</tt> 值之间的正距离。零值的 ulp 在数值上等于具有 <tt>this</tt> 标度的 1。使用与 <code>this</code> 相同的标度存储该结果，这样，零和非零值的结果等于 <code>[1, this.scale()]</code>。

@return <tt>this</tt> 的 ulp 的大小
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
private synchronized void java.math.BigDecimal.readObject(ObjectInputStream s) throws java.io.IOException, java.lang.ClassNotFoundException
<!-- END KEY -->
<!-- BEGIN DATA -->
从流重构 <tt>BigDecimal</tt> 实例（也就是将其反序列化）。

@param s 将读取的流。


<!-- END DATA -->
<!-- BEGIN KEY -->
private void java.math.BigDecimal.writeObject(ObjectOutputStream s) throws java.io.IOException
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <tt>BigDecimal</tt> 序列化到请求的流

 @param s 要序列化到的流。

<!-- END DATA -->
