<!-- BEGIN KEY -->
public interface org.w3c.dom.ls.LSSerializer
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>LSSerializer</code> 提供了将 DOM 文档序列化（编写）为 XML 的 API。XML 数据被写入字符串或输入流。在序列化期间所做的任何更改或修复仅影响序列化的数据。<code>Document</code> 对象及其子对象永远不会被序列化操作所改变。 
<p> 在序列化 XML 数据期间，将像在 [<a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407'>DOM Level 3 Core</a>] 的附录 B 中所定义的那样，执行名称空间修复。[<a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113'>DOM Level 2 Core</a>] 允许空字符串作为实际名称空间 URI。如果一个 <code>Node</code> 的 <code>namespaceURI</code> 是空字符串，则序列化将把它们视为 <code>null</code>，从而忽略前缀（如果有）。 
<p> <code>LSSerializer</code> 接受任何用于序列化的节点类型。对于 <code>Document</code> 或 <code>Entity</code> 类型的节点，将在可能的情况下创建格式良好的 XML（如果文档或实体来自解析操作并且自创建以来没有改变，则可保证格式良好性）。这些节点类型的序列化输出分别作为 XML 文档或外部 XML 实体，并且是 XML 解析器可接受的输入。对于所有其他类型的节点，序列化格式是依赖于实现的。 
<p>在被序列化的 <code>Document</code>、<code>DocumentFragment</code> 或 <code>Entity</code> 内，将按如下方式处理 <code>Nodes</code>
 <ul>
<li> 编写 <code>Document</code> 节点，包括 XML 声明（除非参数 &quot;xml-declaration&quot; 设置为 <code>false</code>）和 DTD 子集（如果 DOM 中存在一个）。编写 <code>Document</code> 节点序列化整个文档。 
 </li>
 <li> 
当 <code>Entity</code> 节点直接由 <code>LSSerializer.write</code> 编写时将输出实体扩展，但不执行名称空间修复。得到的输出将作为有效的外部实体。 
 </li>
<li> 如果参数 &quot;<a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-entities'>entities</a>&quot; 设置为 <code>true</code>，则把 <code>EntityReference</code> 节点序列化为输出中形式 &quot; <code>&entityName;</code>&quot; 的实体引用。将忽略实体引用的子节点（扩展）。如果参数 &quot;<a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-entities'>entities</a>&quot; 设置为 <code>false</code>，则仅序列化实体引用的子项。将始终序列化不带有子项的 <code>EntityReference</code> 节点（没有相应的 <code>Entity</code> 节点，或者相应的 <code>Entity</code> 节点没有子节点）。 
 </li>
 <li> 
<code>CDATAsections</code> 包括不能用指定的输出编码表示的内容字符，将根据 &quot;<a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-split-cdata-sections'>split-cdata-sections</a>&quot; 参数对其进行处理。如果将该参数设置为 <code>true</code>，则将拆分 <code>CDATAsections</code>，将不可表示的字符序列化为普通内容中的数字字符引用。不指定拆分的精确位置和数量。如果参数设置为 <code>false</code>，则参数 &quot;<a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-well-formed'>well-formed</a>&quot; 设置为 <code>true</code> 时，<code>CDATAsection</code> 中不可表示的字符将报告为 <code>&quot;wf-invalid-character&quot;</code> 错误。该错误不可恢复 - 没有提供替换字符和继续进行序列化的机制。 
 </li>
<li> <code>DocumentFragment</code> 节点可通过按照文档片段的子片段在文档片段中出现的顺序序列化这些子片段得以序列化。 
 </li>
<li> 所有其他节点类型（Element、Text 等）都将序列化为其相应的 XML 源格式。 
 </li>
 </ul>
<p ><b>注：</b>序列化 <code>Node</code> 并不总能生成格式良好的 XML 文档，即解析得到的序列化时 <code>LSParser</code> 可能会抛出严重错误。 
<p> 在文档的字符数据中（在标记之外），任何无法直接表示的字符都将替换为字符引用。'&lt;' 和 '&amp;' 将由预定义实体 &lt; 和 &amp; 替换。除非必需（例如在 ']]&gt;' 这一情况下使用 &gt;），否则不能使用其他预定义实体（&gt;、&apos; 和 &quot;）。无法用输入字符编码直接表示的任何字符都将序列化为数值字符引用（由于字符编码标准一般使用字符的十六进制表示形式，所以在序列化字符引用时鼓励使用十六进制表示形式）。 
<p> 若要允许属性值同时包括单引号和双引号，可以将省略号或单引号字符 (') 表示为 &quot;&apos;&quot;，双引号字符 (&quot;) 表示为 &quot;&quot;&quot;。无法直接用输出字符编码表示的新行字符和其他字符将被序列化为数值字符引用。 
<p> 在标记内（但在属性外），无法用输出字符编码表示的任何字符都将被报告为 <code>DOMError</code> 严重错误。其中的一个示例就是使用 <code>encoding=&quot;us-ascii&quot;</code> 序列化元素 &lt;LaCa?ada/&gt;。这将导致生成 <code>DOMError</code> &quot;wf-invalid-character-in-node-name&quot;（在 &quot;<a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-well-formed'>well-formed</a>&quot; 中建议的）。 
<p> 当通过将 <code>LSSerializer</code> 上的参数 &quot;<a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-normalize-characters'>normalize-characters</a>&quot; 设置为 true 请求字符标准化时，对所有被序列化的数据（包括标识和字符数据），将根据对 &quot;<a href='http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm'>fully normalized</a>&quot; 字符（包括在 [<a href='http://www.w3.org/TR/2004/REC-xml11-20040204/'>XML 1.1</a>] 的附录 E 中）的定义实施字符标准化。字符标准化过程只影响正在编写的数据；在序列化完成之后不会改变 DOM 的文档视图。 
<p> 需要实现支持编码 &quot;UTF-8&quot;、&quot;UTF-16&quot;、&quot;UTF-16BE&quot; 和 &quot;UTF-16LE&quot;，以保证数据在需要得到所有 XML 解析器支持的所有编码中能够序列化。当编码是 UTF-8 时，无论字节顺序标记是否得到了序列化，无论输出是大尾端还是 小尾端，都具有实现依赖性。当编码是 UTF-16 时，无论输出是大尾端还是小尾端，都具有实现依赖性，但必须为非字符输出（如 <code>LSOutput.byteStream</code> 或 <code>LSOutput.systemId</code>）生成字节顺序标记。如果未生成字节顺序标记，则报告一个 &quot;byte-order-mark-needed&quot; 警告。当编码是 UTF-16LE 或 UTF-16BE 时，输出是大尾端 (UTF-16BE) 或小尾端 (UTF-16LE)，将不生成字节顺序标记。在所有这些情况下，编码声明（如果已生成）将与序列化期间使用的编码一致（例如，如果请求 UTF-16，则 <code>encoding=&quot;UTF-16&quot;</code> 将出现）。 
<p> 名称空间将在序列化期间进行修复，序列化过程将检验名称空间声明、名称空间前缀以及与元素和属性相关的名称空间 URI 是否一致。如果发现有不一致，则将改变文档的序列化形式以删除它们。序列化文档时修复名称空间所使用的方法是在 [<a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407'>DOM Level 3 Core</a>] 的附录 B.1 &quot;Namespace normalization&quot; 中定义的算法。 
<p> 在序列化文档期间，参数 &quot;discard-default-content&quot; 控制是否序列化非指定数据。 
<p> 在序列化期间，将通过错误处理程序（<code>LSSerializer.domConfig</code> 的 &quot;<a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-error-handler'>error-handler</a>&quot; 参数）将错误和警告报告给应用程序。此规范从不尝试定义序列化 DOM 节点期间可能发生的所有错误和警告，但却对一些常见的错误和警告情形做了定义。此规范定义的错误和警告类型 (<code>DOMError.type</code>) 包括： 
 <dl>
 <dt><code>&quot;no-output-specified&quot; [fatal]</code></dt>
<dd> 当未在 <code>LSOutput</code> 中指定输出的情况下向 <code>LSOutput</code> 写入时，将引发此错误。 </dd>
 <dt> 
 <code>&quot;unbound-prefix-in-entity-reference&quot; [fatal]</code> </dt>
<dd> 引发此错误的情况是：配置参数 &quot;<a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-namespaces'>namespaces</a>&quot; 设置为 <code>true</code>，并且在没有名称空间前缀绑定的位置引用了其替换文本包含未绑定的名称空间前缀的实体。 </dd>
 <dt>
 <code>&quot;unsupported-encoding&quot; [fatal]</code></dt>
<dd> 如果遇到了不受支持的编码，则引发此错误。 </dd>
 </dl> 
<p> 除引发定义的错误和警告之外，这些实现还应该针对其他任何错误和警告情况，例如 IO 错误（未找到文件，权限被拒绝）等引发特定于实现的错误和警告。 
<p>另请参见《<a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407'>Document Object Model (DOM) Level 3 Load and Save Specification</a>》。

<!-- END DATA -->
<!-- BEGIN KEY -->
public org.w3c.dom.DOMConfiguration org.w3c.dom.ls.LSSerializer.getDomConfig()
<!-- END KEY -->
<!-- BEGIN DATA -->
在序列化 DOM 节点时由 <code>LSSerializer</code> 使用的 <code>DOMConfiguration</code> 对象。<br> 除由 &quot;<a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#DOMConfiguration'>DOMConfiguration</a>&quot; 接口（在 [<a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407'>DOM Level 3 Core</a>] 中定义）识别的参数之外，<code>LSSerializer</code> 的 <code>DOMConfiguration</code> 对象还将添加或修改以下参数： 
 <dl>
 <dt><code>&quot;canonical-form&quot;</code></dt>
 <dd>
 <dl>
<dt><code>true</code></dt>
<dd>[<em>可选</em>] 根据在 [<a href='http://www.w3.org/TR/2001/REC-xml-c14n-20010315'>Canonical XML</a>] 中指定的规则编写文档。除 &quot;<a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-canonical-form'>canonical-form</a>》、[<a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407'>DOM Level 3 Core</a>] 中描述的行为外，将此参数设置为 <code>true</code> 将把参数 &quot;format-pretty-print&quot;、&quot;discard-default-content&quot; 和 &quot;xml-declaration &quot; 设置为 <code>false</code>。将其中的一个参数设置为 <code>true</code> 将把此参数设置为 <code>false</code>。当 &quot;canonical-form&quot; 为 <code>true</code> 时序列化 XML 1.1 文档将生成严重错误。 </dd>
<dt><code>false。</code></dt>
<dd>[<em>必需</em>]（<em>默认</em>）不规范化输出。 </dd>
 </dl></dd>
 <dt><code>&quot;discard-default-content&quot;</code></dt>
 <dd>
 <dl>
 <dt>
<code>true</code></dt>
<dd>[<em>必需</em>]（<em>默认</em>）使用 <code>Attr.specified</code> 属性来决定必须丢弃哪些属性。注意，有些实现可能使用任何可供实现使用的信息（即 XML 模式、DTD、<code>Attr.specified</code> 属性等）来决定在此参数设置为 <code>true</code> 时应丢弃哪些属性和内容。 </dd>
<dt><code>false。</code></dt>
<dd>[<em>必需</em>] 保留所有属性和所有内容。</dd>
 </dl></dd>
 <dt><code>&quot;format-pretty-print&quot;</code></dt>
 <dd>
 <dl>
 <dt>
<code>true</code></dt>
<dd>[<em>可选</em>] 通过添加空白格式化输出，以产生打印美观的、缩排的、可为人读的格式。转换的准确形式不是由此规范指定的。打印美观性可改变文档的内容，并且会影响文档的有效性，验证实现必须保留有效性。 </dd>
 <dt>
<code>false。</code></dt>
<dd>[<em>必需</em>]（<em>默认</em>）不打印美观化结果。 </dd>
 </dl></dd>
 <dt> 
 <code>&quot;ignore-unknown-character-denormalizations&quot;</code> </dt>
 <dd>
 <dl>
 <dt>
<code>true</code></dt>
<dd>[<em>必需</em>]（<em>默认</em>），如果在 [<a href='http://www.w3.org/TR/2004/REC-xml11-20040204/'>XML 1.1</a>] 受支持的情况下检查完全标准化时遇到了不能为其确定标准化属性的字符，则将引发一个 <code>&quot;unknown-character-denormalization&quot;</code> 警告（而不是像未设置此参数那样引发错误），并将忽略由这些字符引起的任何可能的反向标准化。 </dd>
 <dt>
<code>false。</code></dt>
<dd>[<em>可选</em>] 如果遇到了处理器不能为其确定标准化属性的字符，则将引发严重错误。 </dd>
 </dl></dd>
 <dt>
 <code>&quot;normalize-characters&quot;</code></dt>
<dd> 此参数与 [<a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407'>DOM Level 3 Core</a>] 中的 <code>DOMConfiguration</code> 定义的参数等效。与在 Core 中不同，此参数的默认值是 <code>true</code>。尽管根据 [<a href='http://www.w3.org/TR/2004/REC-xml11-20040204/'>XML 1.1</a>] 中的附录 E 的规定，不需要 DOM 实现支持<a href='http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm'>完全标准化</a>文档中的字符，但如果支持，则默认情况下必须激活此参数。 </dd>
 <dt>
 <code>&quot;xml-declaration&quot;</code></dt>
 <dd>
 <dl>
<dt><code>true</code></dt>
<dd>[<em>必需</em>]（<em>默认</em>）如果 <code>Document</code>、<code>Element</code> 或 <code>Entity</code> 节点被序列化，则必须包括 XML 声明或文本声明。版本（如果文档是 Level 3 文档并且版本为非 null，则使用 <code>Document.xmlVersion</code>，否则使用值 &quot;1.0&quot;）和输出编码（关于如何查找输出编码的详细信息请参见 <code>LSSerializer.write</code> ）在已序列化的 XML 声明中指定。</dd>
 <dt>
<code>false。</code></dt>
<dd>[<em>必需</em>] 不序列化 XML 和文本声明。如果这会引起问题（即已序列化的数据是 XML 版本，而不是 [<a href='http://www.w3.org/TR/2004/REC-xml-20040204'>XML 1.0</a>]，或者必须有编码才能重新解析序列化的数据），则将发出一个 <code>&quot;xml-declaration-needed&quot;</code> 警告。 </dd>
 </dl></dd>
 </dl>

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String org.w3c.dom.ls.LSSerializer.getNewLine()
<!-- END KEY -->
<!-- BEGIN DATA -->
在所写出的 XML 中使用的字符的行尾序列。任何字符都受支持，但 XML 仅将某些字符集序列视为行尾（如果序列化的内容是 XML 1.0，则请参见 [<a href='http://www.w3.org/TR/2004/REC-xml-20040204'>XML 1.0</a>] 中的 2.11 节 &quot;End-of-Line Handling&quot;，如果序列化的内容是 XML 1.1，则请参见 [<a href='http://www.w3.org/TR/2004/REC-xml11-20040204/'>XML 1.1</a>] 中的 2.11 节 &quot;End-of-Line Handling&quot;）。使用其他字符序列而不是推荐的字符序列会导致文档要么不能序列化，要么不是格式良好的文档。）<br> 检索时，此属性的默认值特定于实现的默认行尾序列。DOM 实现应该选择默认值，以符合所用环境中文本文件的常规约定。实现必须选择与 XML 1.0 或 XML 1.1 所允许的序列匹配的默认序列，具体情况取决于序列化的内容。将此属性设置为 <code>null</code> 将把其值重置为默认值。 <br> 

<!-- END DATA -->
<!-- BEGIN KEY -->
public void org.w3c.dom.ls.LSSerializer.setNewLine(String newLine)
<!-- END KEY -->
<!-- BEGIN DATA -->
在所写出的 XML 中使用的字符的行尾序列。任何字符都受支持，但 XML 仅将某些字符集序列视为行尾（如果序列化的内容是 XML 1.0，则请参见 [<a href='http://www.w3.org/TR/2004/REC-xml-20040204'>XML 1.0</a>] 中的 2.11 节 &quot;End-of-Line Handling&quot;，如果序列化的内容是 XML 1.1，则请参见 [<a href='http://www.w3.org/TR/2004/REC-xml11-20040204/'>XML 1.1</a>] 中的 2.11 节 &quot;End-of-Line Handling&quot;）。使用其他字符序列而不是推荐的字符序列会导致文档要么不能序列化，要么不是格式良好的文档。）<br> 检索时，此属性的默认值是特定于实现的默认行尾序列。DOM 实现必须选择默认值，以符合所用环境中文本文件的常规约定。实现必须选择与 XML 1.0 或 XML 1.1 所允许的序列匹配的默认序列，具体情况取决于序列化的内容。将此属性设置为 <code>null</code> 将把其值重置为默认值。 <br> 

<!-- END DATA -->
<!-- BEGIN KEY -->
public org.w3c.dom.ls.LSSerializerFilter org.w3c.dom.ls.LSSerializer.getFilter()
<!-- END KEY -->
<!-- BEGIN DATA -->
当应用程序提供过滤器时，在序列化每个节点前串行器先调出过滤器。过滤器实现可以选择从流中删除节点，或者提前终止序列化。<br> 过滤器将在使用了 <code>DOMConfiguration</code> 参数请求的操作后调用。例如，如果把 &quot;<a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-cdata-sections'>cdata-sections</a>&quot; 设置为 <code>false</code>，则不会将 CDATA 节传递给过滤器。

<!-- END DATA -->
<!-- BEGIN KEY -->
public void org.w3c.dom.ls.LSSerializer.setFilter(LSSerializerFilter filter)
<!-- END KEY -->
<!-- BEGIN DATA -->
当应用程序提供过滤器时，在序列化每个节点前串行器将先调出过滤器。过滤器实现可以选择从流中删除节点，或者提前终止序列化。<br> 过滤器将在使用了 <code>DOMConfiguration</code> 参数请求的操作后调用。例如，如果把 &quot;<a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-cdata-sections'>cdata-sections</a>&quot; 设置为 <code>false</code>，则不会将 CDATA 节传递给过滤器。 

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean org.w3c.dom.ls.LSSerializer.write(Node nodeArg, LSOutput destination) throws org.w3c.dom.ls.LSException
<!-- END KEY -->
<!-- BEGIN DATA -->
像前面对 <code>LSSerializer</code> 接口的一般介绍中所描述的那样序列化指定的节点。将输出写入所提供的 <code>LSOutput</code>。<br> 当向 <code>LSOutput</code> 写入时，编码可以通过查找可通过 <code>LSOutput</code> 获得的编码信息和按如下顺序编写的条目（或者其所有者文档）来发现：
 <ol>
 <li> <code>LSOutput.encoding</code>, 
 </li>
 <li> 
 <code>Document.inputEncoding</code>, 
 </li>
 <li> 
 <code>Document.xmlEncoding</code>. 
 </li>
 </ol>
<br>如果没有编码可通过上述属性获得，则将使用 &quot;UTF-8&quot; 的默认编码。如果指定的编码不受支持，则将引发 &quot;unsupported-encoding&quot; 严重错误。<br>如果在 <code>LSOutput</code> 中未指定输出，则将引发 &quot;no-output-specified&quot; 严重错误。<br>实现负责将适当的媒体类型与已序列化的数据相关联。<br>当向 HTTP URI 写入时，将执行 HTTP PUT。当向其他类型的 URI 写入时，向 URI 写入数据的机制具有实现依赖性。
@param nodeArg 将序列化的节点。
@param destination 已序列化 DOM 的目标。
@return 如果 <code>node</code> 被成功序列化，则返回 <code>true</code>。如果常规处理停止，但实现仍在序列化文档，则返回 <code>false</code>；序列化的结果是具有实现依赖性。
@exception LSException SERIALIZE_ERR:如果 <code>LSSerializer</code> 不能序列化节点，则引发此异常。如果 DOM 应用程序想获得有关错误的详细信息，则它必须附加上使用参数 &quot;<a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-error-handler'>error-handler</a>&quot; 的 <code>DOMErrorHandler</code>。 

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean org.w3c.dom.ls.LSSerializer.writeToURI(Node nodeArg, String uri) throws org.w3c.dom.ls.LSException
<!-- END KEY -->
<!-- BEGIN DATA -->
这是一种简便方法，其作用就像使用没有指定编码的 <code>LSOutput</code> 调用 <code>LSSerializer.write</code>，并且 <code>LSOutput.systemId</code> 被设置为 <code>uri</code> 参数。
@param nodeArg 要序列化的节点。
@param uri 要写入到的 URI。
@return 如果 <code>node</code> 被成功序列化，则返回 <code>true</code>。如果常规处理停止，但实现仍在序列化文档，则返回 <code>false</code>；序列化的结果是具有实现依赖性。
@exception LSException SERIALIZE_ERR:如果 <code>LSSerializer</code> 无法序列化节点，则引发此异常。如果 DOM 应用程序想获得有关错误的详细信息，则它必须附加上使用参数 &quot;<a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-error-handler'>error-handler</a>&quot; 的 <code>DOMErrorHandler</code>。 

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String org.w3c.dom.ls.LSSerializer.writeToString(Node nodeArg) throws org.w3c.dom.DOMException, org.w3c.dom.ls.LSException
<!-- END KEY -->
<!-- BEGIN DATA -->
像前面对 <code>LSSerializer</code> 接口的一般介绍中所描述的那样序列化指定的节点。将输出写入到返回给调用者的 <code>DOMString</code>。所使用的编码是 <code>DOMString</code> 类型的编码，即 UTF-16。注意，在 <code>DOMString</code> 对象中未生成字节顺序标记。
@param nodeArg 将序列化的节点。
@return 返回序列化的数据。
@exception DOMException DOMSTRING_SIZE_ERR: 如果得到的字符串太长，不能放在 <code>DOMString</code> 中，则将引发此异常。
@exception LSException SERIALIZE_ERR: 如果 <code>LSSerializer</code> 不能序列化节点，则引发此异常。如果 DOM 应用程序想获得有关错误的详细信息，则它必须附加上使用参数 &quot;<a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-error-handler'>error-handler</a>&quot; 的 <code>DOMErrorHandler</code>。 

<!-- END DATA -->
