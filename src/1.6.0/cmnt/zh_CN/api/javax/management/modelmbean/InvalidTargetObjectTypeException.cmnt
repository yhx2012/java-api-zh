<!-- BEGIN KEY -->
public class javax.management.modelmbean.InvalidTargetObjectTypeException extends java.lang.Exception
<!-- END KEY -->
<!-- BEGIN DATA -->
当指定了无效的目标对象类型时，抛出此异常。
<p>此类的 <b>serialVersionUID</b> 为 <code>1190536278266811217L</code>。
 
@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
private static final java.io.ObjectStreamField[] javax.management.modelmbean.InvalidTargetObjectTypeException.serialPersistentFields
<!-- END KEY -->
<!-- BEGIN DATA -->
@serialField exception Exception 封装的 {@link Exception}

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.management.modelmbean.InvalidTargetObjectTypeException()
<!-- END KEY -->
<!-- BEGIN DATA -->
默认构造方法。

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.management.modelmbean.InvalidTargetObjectTypeException(String s)
<!-- END KEY -->
<!-- BEGIN DATA -->
根据字符串进行构造的构造方法。

@param s 将被合并到此异常的消息中的 String 值。 

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.management.modelmbean.InvalidTargetObjectTypeException(Exception e, String s)
<!-- END KEY -->
<!-- BEGIN DATA -->
带有异常和字符串的构造方法。

@param e 可能已捕获并以 InvalidTargetObjectTypeException 形式重新发布的异常。我们可能希望使用该消息重写 printStackTrace() 方法，以获取指回初始抛出堆栈的数据。
@param s 将被合并到此异常的消息中的字符串值。 

<!-- END DATA -->
<!-- BEGIN KEY -->
private void javax.management.modelmbean.InvalidTargetObjectTypeException.readObject(ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException
<!-- END KEY -->
<!-- BEGIN DATA -->
从 {@link ObjectInputStream} 反序列化 {@link InvalidTargetObjectTypeException}。

<!-- END DATA -->
<!-- BEGIN KEY -->
private void javax.management.modelmbean.InvalidTargetObjectTypeException.writeObject(ObjectOutputStream out) throws java.io.IOException
<!-- END KEY -->
<!-- BEGIN DATA -->
将 {@link InvalidTargetObjectTypeException} 序列化为 {@link ObjectOutputStream}。

<!-- END DATA -->
