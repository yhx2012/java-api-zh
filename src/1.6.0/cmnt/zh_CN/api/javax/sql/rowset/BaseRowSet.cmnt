<!-- BEGIN KEY -->
public abstract class javax.sql.rowset.BaseRowSet extends java.lang.Object implements java.io.Serializable, java.lang.Cloneable
<!-- END KEY -->
<!-- BEGIN DATA -->
提供一个具有基本功能的 <code>RowSet</code> 对象的抽象类。基本功能包括设置属性和发送事件通知，这是所有 JavaBeans<sup><font size=-2>TM</font></sup> 组件都必须实现的。
 <P>
<h3>1.0 概述</h3>
<code>BaseRowSet</code> 类为所有 <code>RowSet</code> 实现提供核心功能，所有标准实现<b>可以</b>结合使用此类和一个或多个 <code>RowSet</code> 接口来提供标准特定于供应商的实现。更详细地说，即所有实现必须至少实现一个 <code>RowSet</code> 接口（<code>JdbcRowSet</code>、<code>CachedRowSet</code>、<code>JoinRowSet</code>、<code>FilteredRowSet</code> 或 <code>WebRowSet</code>）。这意味着所有扩展 <code>BaseRowSet</code> 类的实现也必须实现一个 <code>RowSet</code> 接口。
 <p>
<code>BaseRowSet</code> 类提供以下内容：
 <p>
 <UL>
<LI><b>属性</b>
     <ul>
<li>用于存储当前属性的字段
<li>用于获取和设置属性的方法
     </ul>
  <p>
<LI><b>事件通知</b>
 <P>
<LI><b>完整的设置方法集</b> 用于设置 <code>RowSet</code> 对象命令中的各个参数
  <p>
<LI> <b>流</b>
  <ul>
<li>用于存储流实例的字段
<li>指示流类型的常量
  </ul>
  <p>
 </UL>
 
<h3>2.0 设置属性</h3>
所有 rowset 都维护一个属性集，通常使用某种工具来设置这些属性。rowset 具有的属性的数量和种类各不相同，这取决于 <code>RowSet</code> 实现的用途及其获得数据的方式。例如，从 <code>ResultSet</code> 对象获得其数据的 rowset 需要设置那些建立数据库连接所需的属性。如果某个 <code>RowSet</code> 对象使用 <code>DriverManager</code> 设施建立连接，则它需要设置一个标识合适驱动程序的 JDBC URL 属性，还需要设置那些提供用户名和密码的属性。另一方面，如果 rowset 使用 <code>DataSource</code> 对象建立连接（这是首选的方法），则它无需设置 JDBC URL 属性。但是它需要设置用于数据源逻辑名的属性，以及用户名和密码的属性。
 <P>
注：要使用 <code>DataSource</code> 对象建立连接，该 <code>DataSource</code> 对象必须已经向使用 Java Naming and Directory Interface<sup><font size=-2>TM</font></sup> (JNDI) API 的命名服务注册。通常由具有系统管理员资格的人员完成此注册。
 <P>
<h3>3.0 设置命令及其参数</h3>
rowset 从关系型数据库获取其数据时，它执行一条可生成 <code>ResultSet</code> 对象的命令（查询）。此查询就是为 <code>RowSet</code> 对象的 command 属性所设置的命令。rowset 使用数据填充自身的方式是将数据从 <code>ResultSet</code> 对象读取到其自身。如果查询为要设置的值包含占位符，则使用 <code>BaseRowSet</code> 的设置方法设置这些值。如有必要，所有设置方法都允许将这些值设置为 <code>null</code>。
 <P>
以下代码片断展示了如何设置 <code>CachedRowSet</code><sup><font size=-2>TM</font></sup> 对象 <code>crs</code> 的 command 属性。注意，如果使用某种工具设置属性，则这就是该工具应使用的代码。
 <PRE>
    crs.setCommand(&quot;SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS&quot; +
                   &quot;WHERE CREDIT_LIMIT &gt; ? AND REGION = ?&quot;);
 </PRE>
 <P>
在此示例中，<code>CREDIT_LIMIT</code> 和 <code>REGION</code> 的值是占位符参数，用一个问号 (?) 指示。第一个问号是占位符参数编号 <code>1</code>，第二个问号是占位符参数编号 <code>2</code>，依此类推。执行查询前必须为占位符参数设置值。要设置这些占位符参数，<code>BaseRowSet</code> 类提供了一组与 <code>PreparedStatement</code> 接口类似的设置方法，用于设置每种数据类型的值。<code>RowSet</code> 对象内部存储该参数值，该对象的 <code>execute</code> 方法在将要执行的命令发送到 DBMS 前，使用这些值内部设置占位符参数的值。
 <P>
以下代码片断演示了如何设置前一个示例查询中的两个参数。
 <PRE>
    crs.setInt(1, 5000);
    crs.setString(2, &quot;West&quot;);
 </PRE>
如果此时调用 <code>execute</code> 方法，则发送到 DBMS 的查询是：
 <PRE>
    &quot;SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS&quot; +
                   &quot;WHERE CREDIT_LIMIT &gt; 5000 AND REGION = 'West'&quot;
 </PRE>
注：将 <code>Array</code>、<code>Clob</code>、<code>Blob</code> 和 <code>Ref</code> 对象设置为命令参数，将这些值分别存储为 <code>SerialArray</code>、<code>SerialClob</code>、<code>SerialBlob</code> 和 <code>SerialRef</code> 对象。
     
<h3>4.0 在后台处理参数</h3>

注：<code>BaseRowSet</code> 类提供两类设置方法：一类设置属性，一类设置占位符参数。此部分中讨论的设置方法是设置占位符参数的那一类。
 <P>
使用 <code>BaseRowSet</code> 的设置方法设置的占位符参数以对象的形式存储在内部 <code>Hashtable</code> 对象中。基本类型则以其 <code>Object</code> 类型存储。例如，<code>byte</code> 以 <code>Byte</code> 对象的形式存储，<code>int</code> 则以 <code>Integer</code> 对象的形式存储。调用方法 <code>execute</code> 时，<code>Hashtable</code> 对象中的值替换命令中的适当占位符参数。
 <P)>
调用方法 <code>getParams</code> 能够以 <code>Object</code> 实例数组的形式返回存储在 <code>Hashtable</code> 对象中的值。此数组中的元素可以是一个简单的 <code>Object</code> 实例，也可以是一个数组（<code>Object</code> 类型）。使用特定的设置方法可确定此数组中某个元素是 <code>Object</code> 还是数组。
 <P>
大多数设置占位符参数的方法采用两个参数，第一个参数指示要设置的占位符参数，第二个参数给出要设置的值。<code>getInt</code>、<code>getString</code>、<code>getBoolean</code> 和 <code>getLong</code> 之类的方法属于此类。调用这些方法后，调用方法 <code>getParams</code> 将返回一个数组，其中带有已经设置的值。每个数组元素都是一个 <code>Object</code> 实例，表示已经设置的值。根据传递到设置方法的 <code>int</code>（第一个参数）来确定这些值在数组中的顺序。该数组中的值就是传递给设置方法的值（第二个参数）。换句话说，数组中的第一个元素是为 <code>RowSet</code> 对象的命令中第一个占位符参数所设置的值。第二个元素是为第二个占位符参数所设置的值，依此类推。 
 <P>
一些设置方法除了要设置的值外，还发送驱动程序和 DBMS 信息。如果在使用了此类设置方法后再调用方法 <code>getParams</code>，则数组中的元素本身就是数组，以容纳附加信息。在此类别中，方法 <code>setNull</code> 是一个特例，因为它有一种形式只带有两个参数 (<code>setNull(int parameterIndex, int SqlType)</code>)。尽管如此，它仍然需要一个数组来包含要传递给驱动程序和 DBMS 的信息。此数组中的第一个元素是要设置的值，该值为 <code>null</code>；第二个元素是为 <i>sqlType</i> 提供的 <code>int</code>，指示要设置为 <code>null</code> 的 SQL 值的类型。某些 DBMS 需要此信息，因此为了确保应用程序的可移植性，此信息是必需的。当要设置为 <code>null</code> 的值是用户定义的类型时，可使用该方法的另一种形式。这种形式带有三个参数 (<code>setNull(int parameterIndex, int sqlType, String typeName)</code>)，同样需要一个数组来包含要传递给驱动程序和 DBMS 的信息。此数组中的前两个参数与第一种 <code>setNull</code> 相同。第三个参数 <i>typeName</i> 给出了用户定义类型的 SQL 名称。与其他设置方法一样，通过 <code>getParams</code> 返回的数组中元素的位置来指示要设置的占位符参数的编号。所以，举例来说，如果提供给 <code>setNull</code> 的参数是 <code>2</code>，则 <code>getParams</code> 返回的数组中的第二个元素将是一个两元素或三元素数组。
 <P>
某些方法（如 <code>setObject</code> 和 <code>setDate</code>）还有带有多于两个参数的形式，这些额外的参数为驱动程序或 DBMS 提供信息。例如，方法 <code>setDate</code>、<code>setTime</code> 和 <code>setTimestamp</code> 可将 <code>Calendar</code> 对象作为其第三个参数。如果 DBMS 没有存储时区信息，则驱动程序使用 <code>Calendar</code> 对象来构造正在设置的 <code>Date</code>、<code>Time</code> 或 <code>Timestamp</code> 对象。与提供附加信息的其他方法一样，<code>getParams</code> 返回的数组中的元素是一个数组，而不是简单的 <code>Object</code> 实例。
 <P>
方法 <code>setAsciiStream</code>、<code>setBinaryStream</code>、<code>setCharacterStream</code> 和 <code>setUnicodeStream</code>（该方法已废弃，所以应用程序应该使用 <code>getCharacterStream</code>）带有三个参数，所以对于这些方法，<code>getParams</code> 返回的数组中的元素也是一个数组。这些设置方法的不同之处在于除了由参数提供的信息外，该数组还包含一个 <code>BaseRowSet</code> 常量，指示正在设置的流类型。 
 <p>
注：由扩展此类的 <code>RowSet</code> 实现内部调用方法 <code>getParams</code>；应用程序的程序员通常不直接调用此方法。
 
<h3>5.0 事件通知</h3>
<code>BaseRowSet</code> 类为 rowset 提供了事件通知机制。它包含字段 <code>listeners</code>、添加和移除侦听器的方法，以及将更改通知给侦听器的方法。
 <P>
侦听器是一个实现了 <code>RowSetListener</code> 接口的对象。如果已经将侦听器添加到 <code>RowSet</code> 对象的侦听器列表，则 <code>RowSet</code> 对象上发生事件时它将获得通知。每个侦听器的 <code>RowSetListener</code> 方法实现定义了获得发生事件的通知时，该对象将执行的操作。 
 <P>
<code>RowSet</code> 对象有三种可能的事件：
 <OL>
<LI>光标移动
<LI>更改了个别行（更新、删除或插入）
<LI>更改了整个 <code>RowSet</code> 对象的内容
 </OL>
 <P>
用于通知的 <code>BaseRowSet</code> 方法指示已经发生事件的类型。例如，方法 <code>notifyRowChanged</code> 指示某行已经被更新、删除或插入。每种通知方法都创建 <code>RowSetEvent</code> 对象，将该对象提供给侦听器，从而标识发生事件的 <code>RowSet</code> 对象。侦听器如何使用此信息（可能不执行任何操作）取决于它的实现方式。  
 <p>
<h3>6.0 默认行为</h3>
默认的 <code>BaseRowSet</code> 对象是用很多起始值初始化的。
 
扩展 <code>BaseRowSet</code> 类的默认 <code>RowSet</code> 实例具有以下特点：
 <UL>
<LI>具有可滚动的指针并且不显示其他对象所做的更改。
<LI>是可更新的。
<LI>不显示已删除的行。
<LI>对于驱动程序要多长时间才执行 <code>RowSet</code> 对象的命令没有限制。
<LI>对于可以包含的行数没有限制。
<LI>对于一列可以包含的字节数没有限制。注：此限制仅适用于包含以下类型值的列：<code>BINARY</code>、<code>VARBINARY</code>、<code>LONGVARBINARY</code>、<code>CHAR</code>、<code>VARCHAR</code> 和 <code>LONGVARCHAR</code>。
<LI>无法看到未提交的数据（进行&ldquo;脏&rdquo;读）。
<LI>已开启转义处理。
<LI>已将其连接的类型映射设置为 <code>null</code>。
<LI>具有空的 <code>Vector</code> 对象，用于存储为 <code>RowSet</code> 对象命令中的占位符参数设置的值。
 </UL>
 <p>
如果需要其他值，则应用程序必须显式设置该属性值。例如，以下代码行将 <code>CachedRowSet</code> 对象 <i>crs</i> 的最大行数设置为 500。
 <PRE>
    crs.setMaxRows(500);
 </PRE>
对于任何违反已定义断言的情况，扩展此 <code>BaseRowSet</code> 类的方法实现<b>必须</b>抛出 <code>SQLException</code> 对象。此外，如果扩展的类重写和重新实现了任何 <code>BaseRowSet</code> 方法，并且遇到了连接性或底层数据源问题，则方法<b>可以</b>为此另外抛出 <code>SQLException</code> 对象。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int javax.sql.rowset.BaseRowSet.UNICODE_STREAM_PARAM
<!-- END KEY -->
<!-- BEGIN DATA -->
该常量向 <code>RowSetReaderImpl</code> 对象指示给定的参数是一个 Unicode 流。此 <code>RowSetReaderImpl</code> 对象作为 <code>SyncProvider</code> 抽象类的扩展来提供，该抽象类在 <code>SyncFactory</code> 静态工厂 SPI 机制中定义。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int javax.sql.rowset.BaseRowSet.BINARY_STREAM_PARAM
<!-- END KEY -->
<!-- BEGIN DATA -->
该常量向 <code>RowSetReaderImpl</code> 对象指示给定的参数是一个二进制流。此 <code>RowSetReaderImpl</code> 对象作为 <code>SyncProvider</code> 抽象类的扩展来提供，该抽象类在 <code>SyncFactory</code> 静态工厂 SPI 机制中定义。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int javax.sql.rowset.BaseRowSet.ASCII_STREAM_PARAM
<!-- END KEY -->
<!-- BEGIN DATA -->
该常量向 <code>RowSetReaderImpl</code> 对象指示给定的参数是一个 ASCII 流。此 <code>RowSetReaderImpl</code> 对象作为 <code>SyncProvider</code> 抽象类的扩展来提供，该抽象类在 <code>SyncFactory</code> 静态工厂 SPI 机制中定义。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.io.InputStream javax.sql.rowset.BaseRowSet.binaryStream
<!-- END KEY -->
<!-- BEGIN DATA -->
将由方法 <code>getBinaryStream</code> 返回的 <code>InputStream</code> 对象，该方法在 <code>ResultSet</code> 接口中指定。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.io.InputStream javax.sql.rowset.BaseRowSet.unicodeStream
<!-- END KEY -->
<!-- BEGIN DATA -->
将由方法 <code>getUnicodeStream</code> 返回的 <code>InputStream</code> 对象，该方法在 <code>ResultSet</code> 接口中指定。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.io.InputStream javax.sql.rowset.BaseRowSet.asciiStream
<!-- END KEY -->
<!-- BEGIN DATA -->
将由方法 <code>getAsciiStream</code> 返回的 <code>InputStream</code> 对象，该方法在 <code>ResultSet</code> 接口中指定。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.io.Reader javax.sql.rowset.BaseRowSet.charStream
<!-- END KEY -->
<!-- BEGIN DATA -->

将由方法 <code>getCharacterStream</code> 返回的 <code>Reader</code> 对象，该方法在 <code>ResultSet</code> 接口中指定。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private java.lang.String javax.sql.rowset.BaseRowSet.command
<!-- END KEY -->
<!-- BEGIN DATA -->
发送到 DBMS 的查询，调用方法 <code>execute</code> 时执行该查询。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private java.lang.String javax.sql.rowset.BaseRowSet.URL
<!-- END KEY -->
<!-- BEGIN DATA -->
当使用 <code>DriverManager</code> 获得连接时，reader、writer 或二者提供给方法 <code>DriverManager.getConnection</code> 的 JDBC URL。
 <P>
该 JDBC URL 标识用于建立连接的驱动程序。可在驱动程序供应商提供的文档中找到此 URL。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private java.lang.String javax.sql.rowset.BaseRowSet.dataSource
<!-- END KEY -->
<!-- BEGIN DATA -->
为了从 Java Directory and Naming Interface (JNDI) 命名服务中获取 <code>DataSource</code> 对象，reader/writer 应该使用的数据源逻辑名。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private int javax.sql.rowset.BaseRowSet.rowSetType
<!-- END KEY -->
<!-- BEGIN DATA -->
指示此 JDBC <code>RowSet</code> 对象类型的常量。它必须是以下 <code>ResultSet</code> 常量之一：<code>TYPE_FORWARD_ONLY</code>、<code>TYPE_SCROLL_INSENSITIVE</code> 或 <code>TYPE_SCROLL_SENSITIVE</code>。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private boolean javax.sql.rowset.BaseRowSet.showDeleted
<!-- END KEY -->
<!-- BEGIN DATA -->
指示已删除行在此 JDBC <code>RowSet</code> 对象中是否可见的 <code>boolean</code> 值。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private int javax.sql.rowset.BaseRowSet.queryTimeout
<!-- END KEY -->
<!-- BEGIN DATA -->
驱动程序等待执行命令的最大秒数。当此 JDBC <code>RowSet</code> 对象连接到其数据源时应用此限制，也就是用数据填充该对象和该对象将数据写回数据源时。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private int javax.sql.rowset.BaseRowSet.maxRows
<!-- END KEY -->
<!-- BEGIN DATA -->
reader 应该读取的最大行数。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private int javax.sql.rowset.BaseRowSet.maxFieldSize
<!-- END KEY -->
<!-- BEGIN DATA -->
reader 应该读取的最大字段大小。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private int javax.sql.rowset.BaseRowSet.concurrency
<!-- END KEY -->
<!-- BEGIN DATA -->
指示此 JDBC <code>RowSet</code> 对象并发性的常量。它必须是以下 <code>ResultSet</code> 常量之一：<code>CONCUR_READ_ONLY</code> 或 <code>CONCUR_UPDATABLE</code>。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private boolean javax.sql.rowset.BaseRowSet.readOnly
<!-- END KEY -->
<!-- BEGIN DATA -->
指示此 JDBC <code>RowSet</code> 对象是否为只读的 <code>boolean</code> 值。<code>true</code> 指示它是只读的；<code>false</code> 指示它是可写入的。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private boolean javax.sql.rowset.BaseRowSet.escapeProcessing
<!-- END KEY -->
<!-- BEGIN DATA -->
指示此 JDBC <code>RowSet</code> 对象的 reader 是否应该执行转义处理的 <code>boolean</code> 值。<code>true</code> 表示开启转义处理；<code>false</code> 表示关闭。默认值为 <code>true</code>。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private int javax.sql.rowset.BaseRowSet.isolation
<!-- END KEY -->
<!-- BEGIN DATA -->
指示此 JDBC <code>RowSet</code> 对象连接的隔离级别的常量。它必须是以下 <code>Connection</code> 常量之一：<code>TRANSACTION_NONE</code>、<code>TRANSACTION_READ_UNCOMMITTED</code>、<code>TRANSACTION_READ_COMMITTED</code>、<code>TRANSACTION_REPEATABLE_READ</code> 或 <code>TRANSACTION_SERIALIZABLE</code>。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private int javax.sql.rowset.BaseRowSet.fetchDir
<!-- END KEY -->
<!-- BEGIN DATA -->
用作驱动程序提示的常量，指示要从此 JDBC <code>RowSet</code> 对象获取数据时所用的方向。可能的 <code>ResultSet</code> 常量值如下：<code>FETCH_FORWARD</code>、<code>FETCH_REVERSE</code>、<code>FETCH_UNKNOWN</code>。
 <P>
目前未使用。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private int javax.sql.rowset.BaseRowSet.fetchSize
<!-- END KEY -->
<!-- BEGIN DATA -->
为驱动程序提供的提示，指示此 JDBC <code>RowSet</code> 对象中的预期行数。
 <P>
目前未使用。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private java.util.Map javax.sql.rowset.BaseRowSet.map
<!-- END KEY -->
<!-- BEGIN DATA -->
一个 <code>java.util.Map</code> 对象，其中包含的项提供了 SQL 类型名称到 Java 编程语言中类的映射，以用于用户定义类型的自定义映射。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private java.util.Vector javax.sql.rowset.BaseRowSet.listeners
<!-- END KEY -->
<!-- BEGIN DATA -->
一个 <code>Vector</code> 对象，保存已向此 <code>RowSet</code> 对象注册的侦听器所组成的列表。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
private java.util.Hashtable javax.sql.rowset.BaseRowSet.params
<!-- END KEY -->
<!-- BEGIN DATA -->
一个 <code>Vector</code> 对象，保存此 <code>RowSet</code> 对象的当前命令的参数集。
@serial

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.sql.rowset.BaseRowSet()
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个新的 <code>BaseRowSet</code> 对象，使用默认的 <code>Vector</code> 对象初始化其 <code>listeners</code> 字段。初始化时使用的其他默认值列在此类类注释的 6.0 部分。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void javax.sql.rowset.BaseRowSet.initParams()
<!-- END KEY -->
<!-- BEGIN DATA -->
执行必需的内部配置和初始化，从而允许所有 JDBC <code>RowSet</code> 实现开始使用 <code>BaseRowSet</code> 实例提供的标准设施。<b>应该</b>在实例化 <code>RowSet</code> 对象后再调用此方法，以正确地初始化所有参数。此方法永远<b>不应该</b>由应用程序调用，而应从具有扩展此类的 <code>RowSet</code> 实现的对象中调用。

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.addRowSetListener(RowSetListener listener)
<!-- END KEY -->
<!-- BEGIN DATA -->
只要在此 <code>RowSet</code> 对象上发生事件，就将通知该侦听器。
 <P>
为了准确地反映 <code>RowSet</code> 对象的当前状态，侦听器可能是一个需要更新的表或图形。
 <p>
<b>注</b>：如果 <code>RowSetListener</code> 对象为 <code>null</code>，则此方法正常丢弃该 <code>null</code> 值，不向侦听器集添加 null 引用。 
 <p>
<b>注</b>：如果已经设置了侦听器，则新的 <code>RowSetListerner</code> 实例将添加到已注册接收此 <code>RowSet</code> 事件通知的侦听器集合。

@param listener 一个对象，它已经实现了 <code>javax.sql.RowSetListener</code> 接口并且希望在此 <code>RowSet</code> 对象上发生任何事件时得到通知；可以为 null。
@see #removeRowSetListener

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.removeRowSetListener(RowSetListener listener)
<!-- END KEY -->
<!-- BEGIN DATA -->
从此 <code>RowSet</code> 对象的侦听器列表中移除指定的对象。如果给定的参数不是已注册侦听器，则此方法不执行任何操作。

<b>注</b>：如果 <code>RowSetListener</code> 对象为 <code>null</code>，则此方法正常丢弃该 <code>null</code> 值。

@param listener 位于此 <code>RowSet</code> 对象的侦听器列表中的 <code>RowSetListener</code> 对象
@see #addRowSetListener

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void javax.sql.rowset.BaseRowSet.notifyCursorMoved() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
通知向此 <code>RowSet</code> 对象注册的所有侦听器其光标已移动。 
 <P>
当应用程序调用某个方法移动光标时，该方法移动光标，然后内部调用此方法。应用程序永远<b>不应该</b>直接调用此方法。    

@throws SQLException 如果扩展 <code>BaseRowSet</code> 抽象类的类未实现 <code>RowSet</code> 接口或其某个子接口。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void javax.sql.rowset.BaseRowSet.notifyRowChanged() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
通知向此 <code>RowSet</code> 对象注册的所有侦听器其行已更改。
 <P>
当应用程序调用更改某行的方法时，如 <code>CachedRowSet</code> 方法 <code>insertRow</code>、<code>updateRow</code> 或 <code>deleteRow</code>，该方法内部调用 <code>notifyRowChanged</code>。应用程序永远<b>不应该</b>直接调用此方法。

@throws SQLException 如果扩展 <code>BaseRowSet</code> 抽象类的类未实现 <code>RowSet</code> 接口或其某个子接口。     

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void javax.sql.rowset.BaseRowSet.notifyRowSetChanged() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
通知向此 <code>RowSet</code> 对象注册的所有侦听器其整个内容已更改。
 <P>
当应用程序调用更改 <code>RowSet</code> 对象整个内容的方法时，如 <code>CachedRowSet</code> 方法 <code>execute</code>、<code>populate</code>、<code>restoreOriginal</code> 或 <code>release</code>，该方法内部调用（直接或间接）<code>notifyRowSetChanged</code>。应用程序永远<b>不应该</b>直接调用此方法。

@throws SQLException 如果扩展 <code>BaseRowSet</code> 抽象类的类未实现 <code>RowSet</code> 接口或其某个子接口。

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String javax.sql.rowset.BaseRowSet.getCommand()
<!-- END KEY -->
<!-- BEGIN DATA -->
获取作为此 <code>RowSet</code> 对象的命令的 SQL 查询。command 属性包含为填充此 <code>RowSet</code> 对象所执行的查询。
 <P>
此方法返回的 SQL 查询由 <code>RowSet</code> 方法使用，如 <code>execute</code> 和 <code>populate</code>，扩展了 <code>BaseRowSet</code> 抽象类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的任何类都可实现这些方法。
 <P>
<code>RowSet</code> 对象的 reader 使用该命令获得 <code>ResultSet</code> 对象。然后 reader 从 <code>ResultSet</code> 对象读取数据并使用该数据填充此 <code>RowSet</code> 对象。
 <P> 
<code>command</code> 属性的默认值为 <code>null</code>。

@return <code>String</code>，它是此 <code>RowSet</code> 对象的 <code>command</code> 属性的值；可以为 <code>null</code>
@see #setCommand

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setCommand(String cmd) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>RowSet</code> 对象的 <code>command</code> 属性设置为给定的 <code>String</code> 对象，并清除为前一个命令设置的参数（如果有）。
 <P>
如果 <code>RowSet</code> 对象从一个不支持 command 属性的数据源获得数据（如电子表格或其他表格文件），则不需要 <code>command</code> 属性。因此，此属性是可选的，可以为 <code>null</code>。  

@param cmd 包含 SQL 查询的 <code>String</code> 对象，该查询将被设置为此 <code>RowSet</code> 对象的 command 属性；可以为 <code>null</code> 但不能是空字符串
@throws SQLException 如果提供空字符串作为 command 值
@see #getCommand

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String javax.sql.rowset.BaseRowSet.getUrl() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->

获取此 <code>RowSet</code> 对象的 <code>javax.sql.Reader</code> 对象用来建立与关系数据库连接（使用启用 JDBC 技术的驱动程序）的 JDBC URL。
<P>
如果底层数据源是非 SQL 数据源（如电子表格或 XML 数据源），则该 <code>Url</code> 属性为 <code>null</code>。
 
@return 包含 JDBC URL 的 <code>String</code> 对象，该 URL 用来为此 <code>RowSet</code> 对象建立连接；如果未设置，则为 <code>null</code>（默认值）
@throws SQLException 如果获取 URL 值时发生错误
@see #setUrl

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setUrl(String url) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>RowSet</code> 对象的 Url 属性设置为给定的 <code>String</code> 对象，并将 dataSource 名称属性设置为 <code>null</code>。Url 属性是使用启用 JDBC 技术的驱动程序（&ldquo;JDBC 驱动程序&rdquo;）和 <code>DriverManager</code> 建立连接时所使用的 JDBC URL。在驱动程序文档中可以找到特定驱动程序要使用的恰当 JDBC URL。虽然对如何形成 JDBC URL 有很多指导方针，但驱动程序供应商可以指定除长度为 <code>0</code>（空字符串）以外的任何 <code>String</code> 对象。
 <P>
如果使用 <code>DataSource</code> 对象而不是 <code>DriverManager</code> 建立连接，则设置 Url 属性是可选的。驱动程序将使用最近一次指定的 URL 属性或 dataSourceName 属性来创建连接。如果应用程序使用 JDBC URL，则必须在使用 <code>RowSet</code> 对象连接到数据库之前加载可接受 JDBC URL 的 JDBC 驱动程序。为了读取或写入数据，<code>RowSet</code> 对象将内部使用该 URL 创建数据库连接。  
 
@param url 一个 <code>String</code> 对象，包含为此 <code>RowSet</code> 对象建立到数据库的连接时所使用的 JDBC URL；可以为 <code>null</code> 但不得为空字符串
@throws SQLException 如果设置 Url 属性时发生错误，或者提供的参数是长度为 <code>0</code> 的字符串（空字符串）
@see #getUrl

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String javax.sql.rowset.BaseRowSet.getDataSourceName()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回向使用 Java Naming and Directory Interface (JNDI) API 的命名服务所提供的逻辑名，这将获得 <code>javax.sql.DataSource</code> 对象。可使用此 <code>DataSource</code> 对象建立到它所表示的数据源的连接。 
 <P>
用户应该设置 url 或数据源名称属性。驱动程序将使用最近一次设置的属性来建立连接。

@return 一个 <code>String</code> 对象，标识建立连接所使用的 <code>DataSource</code> 对象；如果尚未设置逻辑名，则返回 <code>null</code>。
@see #setDataSourceName

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setDataSourceName(String name) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->

将此 <code>RowSet</code> 对象的 <code>DataSource</code> 名称属性设置为给定的逻辑名，并将此 <code>RowSet</code> 对象的 Url 属性设置为 <code>null</code>。该名称必须已绑定到 JNDI 命名服务中的 <code>DataSource</code> 对象，这样应用程序才可以使用该名称执行查找，以获取绑定到该名称的 <code>DataSource</code> 对象。然后可使用此 <code>DataSource</code> 对象建立到它所表示的数据源的连接。
 <P>
用户应该设置 Url 属性或 dataSourceName 属性。如果同时设置了两个属性，则驱动程序将使用最近一次设置的属性。

@param name 一个 <code>String</code> 对象，它所带的名称可提供给基于 JNDI 技术的命名服务，以获取可用于建立连接的 <code>DataSource</code> 对象；可以为 <code>null</code> 但不得为空字符串
@throws SQLException 如果提供空字符串作为 <code>DataSource</code> 名称
@see #getDataSourceName zhang

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String javax.sql.rowset.BaseRowSet.getUsername()
<!-- END KEY -->
<!-- BEGIN DATA -->

返回用于创建数据库连接的用户名。因为 username 属性不是序列化的，所以在调用方法 <code>execute</code> 之前在运行时设置该属性。
 
@return <code>String</code> 对象，包含为创建连接而提供给数据源的用户名；如果未设置，则为 <code>null</code>（默认值）
@see #setUsername

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setUsername(String name)
<!-- END KEY -->
<!-- BEGIN DATA -->

将此 <code>RowSet</code> 对象的 username 属性设置为给定的用户名。因为 username 属性不是序列化的，所以在调用方法 <code>execute</code> 之前在运行时设置该属性。

@param name <code>String</code> 对象，包含为创建连接而提供给数据源的用户名。可以为 null。
@see #getUsername

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String javax.sql.rowset.BaseRowSet.getPassword()
<!-- END KEY -->
<!-- BEGIN DATA -->

返回用于创建此 <code>RowSet</code> 对象的数据库连接的密码。因为 password 属性不是序列化的，所以在调用方法 <code>execute</code> 之前在运行时设置该属性。默认值为 <code>null</code>。

@return <code>String</code> 对象，表示为创建连接而必须提供给数据库的密码
@see #setPassword

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setPassword(String pass)
<!-- END KEY -->
<!-- BEGIN DATA -->

将用于创建此 <code>RowSet</code> 对象的数据库连接的密码设置为给定的 <code>String</code> 对象。因为 password 属性不是序列化的，所以在调用方法 <code>execute</code> 之前在运行时设置该属性。

@param pass <code>String</code> 对象，表示为创建连接而提供给数据库的密码。可以为 null。
@see #getPassword

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setType(int type) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>RowSet</code> 对象的类型设置为指定类型。默认类型是 <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>。

@param type 以下常量之一：<code>ResultSet.TYPE_FORWARD_ONLY</code>、<code>ResultSet.TYPE_SCROLL_INSENSITIVE</code> 或 <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
@throws SQLException 如果提供的参数不是以下常量之一：<code>ResultSet.TYPE_FORWARD_ONLY</code>、<code>ResultSet.TYPE_SCROLL_INSENSITIVE</code> 或 <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
@see #getConcurrency
@see #getType

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.sql.rowset.BaseRowSet.getType() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->

返回此 <code>RowSet</code> 对象的类型。类型是由创建 <code>RowSet</code> 对象的语句最初确定的。<code>RowSet</code> 对象可在任何时间调用方法 <code>setType</code> 来更改其类型。默认值是 <code>TYPE_SCROLL_INSENSITIVE</code>。

@return 此 JDBC <code>RowSet</code> 对象的类型，必须是以下值之一：<code>ResultSet.TYPE_FORWARD_ONLY</code>、<code>ResultSet.TYPE_SCROLL_INSENSITIVE</code> 或 <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
@throws SQLException 如果获得此 <code>RowSet</code> 对象的类型时发生错误
@see #setType

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setConcurrency(int concurrency) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>RowSet</code> 对象的并发性设置为指定的并发性。所有 <code>RowSet</code> 对象（连接或非连接的）的默认并发性是 <code>ResultSet.CONCUR_UPDATABLE</code>，但是可在任何时间调用此方法来更改该并发性。
 <P>
@param concurrency 以下常量之一：<code>ResultSet.CONCUR_READ_ONLY</code> 或 <code>ResultSet.CONCUR_UPDATABLE</code>
@throws SQLException 如果提供的参数不是以下常量之一：<code>ResultSet.CONCUR_UPDATABLE</code> 或 <code>ResultSet.CONCUR_READ_ONLY</code>
@see #getConcurrency
@see #isReadOnly

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.sql.rowset.BaseRowSet.isReadOnly()
<!-- END KEY -->
<!-- BEGIN DATA -->

返回一个指示此 <code>RowSet</code> 对象是否为只读的 <code>boolean</code> 值。任何试图更新只读 <code>RowSet</code> 对象将导致抛出 <code>SQLException</code>。默认情况下，如果可以进行更新，则 rowset 是可更新的。

@return 如果不能更新此 <code>RowSet</code> 对象，则返回 <code>true</code>；否则返回 <code>false</code>
@see #setConcurrency
@see #setReadOnly

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setReadOnly(boolean value)
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>RowSet</code> 对象的 readOnly 属性设置为给定的 <code>boolean</code> 值。
 
@param value 为 <code>true</code> 指示此 <code>RowSet</code> 对象是只读的；为 <code>false</code> 指示该对象是可更新的

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.sql.rowset.BaseRowSet.getTransactionIsolation()
<!-- END KEY -->
<!-- BEGIN DATA -->

返回此 <code>RowSet</code> 对象连接的事务隔离属性。此属性表示在事务中请求使用的事务隔离级别。
 <P>
对于某些 <code>RowSet</code> 实现，如在非连接环境中操作的 <code>CachedRowSet</code>，<code>SyncProvider</code> 对象提供了互补的锁定和数据完整性选项。以下描述的选项仅与连接的 <code>RowSet</code> 对象（<code>JdbcRowSet</code> 对象）有关。
 
@return 以下常量之一：<code>Connection.TRANSACTION_NONE</code>、<code>Connection.TRANSACTION_READ_UNCOMMITTED</code>、<code>Connection.TRANSACTION_READ_COMMITTED</code>、<code>Connection.TRANSACTION_REPEATABLE_READ</code> 或 <code>Connection.TRANSACTION_SERIALIZABLE</code>
@see javax.sql.rowset.spi.SyncFactory
@see javax.sql.rowset.spi.SyncProvider
@see #setTransactionIsolation

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setTransactionIsolation(int level) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->

将此 JDBC <code>RowSet</code> 对象的事务隔离属性设置为给定的常量。如果可以，DBMS 将为事务使用此事务隔离级别。
 <p>
对于某些 <code>RowSet</code> 实现，如在非连接环境中操作的 <code>CachedRowSet</code>，所用的 <code>SyncProvider</code> 对象提供了互补的锁定和数据完整性选项。以下描述的选项仅与连接的 <code>RowSet</code> 对象（<code>JdbcRowSet</code> 对象）有关。

@param level 以下常量之一，按升序列出：<code>Connection.TRANSACTION_NONE</code>、<code>Connection.TRANSACTION_READ_UNCOMMITTED</code>、<code>Connection.TRANSACTION_READ_COMMITTED</code>、<code>Connection.TRANSACTION_REPEATABLE_READ</code> 或 <code>Connection.TRANSACTION_SERIALIZABLE</code>
@throws SQLException 如果给定的参数不是 Connection 常量之一
@see javax.sql.rowset.spi.SyncFactory
@see javax.sql.rowset.spi.SyncProvider
@see #getTransactionIsolation

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Map<java.lang.String, java.lang.Class<?>> javax.sql.rowset.BaseRowSet.getTypeMap()
<!-- END KEY -->
<!-- BEGIN DATA -->
获取与此 <code>RowSet</code> 对象的 <code>Connection</code> 对象关联的类型映射表。
 <P>
支持 JDBC 3.0 API 的驱动程序将创建具有关联类型映射表的 <code>Connection</code> 对象。此类型映射表（初始为空）可以包含一个或多个完全限定的 SQL 名，以及指示命名 SQL 值所要映射的类的 <code>Class</code> 对象。当没有其他类型映射取代自定义类型映射时，在连接的类型映射表中指定的类型映射将用做自定义类型映射。
 <p>
如果向可以执行自定义映射的方法显式提供类型映射表，则该类型映射表将取代连接的类型映射表。

@return <code>java.util.Map</code> 对象，它是此 <code>RowSet</code> 对象连接的类型映射表

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setTypeMap(java.util.Map<java.lang.String, java.lang.Class<?>> map)
<!-- END KEY -->
<!-- BEGIN DATA -->
将给定的 <code>java.util.Map</code> 对象安装为与此 <code>RowSet</code> 对象的 <code>Connection</code> 对象关联的类型映射表。如果为方法显式提供了不同的类型映射表，则使用提供的类型映射表，否则将使用此类型映射表中所指示的自定义映射。

@param map 一个 <code>java.util.Map</code> 对象，包含用户定义类型 (UDT) 的 SQL 类型名称到 Java 编程语言中类的映射。<code>Map</code> 对象中每一项都由 UDT 的完全限定 SQL 名称和用于该 UDT 的 <code>SQLData</code> 实现的 <code>Class</code> 对象组成。可以为 <code>null</code>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.sql.rowset.BaseRowSet.getMaxFieldSize() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取可用于此 <code>RowSet</code> 对象列值的最大字节数。此限制仅适用于包含以下类型值的列：<code>BINARY</code>、<code>VARBINARY</code>、<code>LONGVARBINARY</code>、<code>CHAR</code>、<code>VARCHAR</code> 和 <code>LONGVARCHAR</code>。如果超过了该限制，则正常丢弃多出的数据。

@return 指示当前最大列大小限制的 <code>int</code> 值；0 表示没有限制
@throws SQLException 如果确定列大小的最大限制时内部发生错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setMaxFieldSize(int max) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将可用于此 <code>RowSet</code> 对象列值的最大字节数设置为给定数。此限制仅适用于包含以下类型值的列：<code>BINARY</code>、<code>VARBINARY</code>、<code>LONGVARBINARY</code>、<code>CHAR</code>、<code>VARCHAR</code> 和 <code>LONGVARCHAR</code>。如果超过了该限制，则正常丢弃多出的数据。为了获得最大的可移植性，建议使用大于 256 的值。

@param max 指示新的最大列大小限制的 <code>int</code> 值；0 表示没有限制
@throws SQLException 如果 (1) 设置最大列大小限制时内部发生错误 (2) 设置的大小小于 0

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.sql.rowset.BaseRowSet.getMaxRows() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此 <code>RowSet</code> 对象可以包含的最大行数。如果超过了此限制，则正常撤消多出的行。

@return 指示当前最大行数的 <code>int</code> 值；0 表示没有限制
@throws SQLException 如果确定 <code>Rowset</code> 对象可以包含的最大行数限制时内部发生错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setMaxRows(int max) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>RowSet</code> 对象可以包含的最大行数设置为给定数。如果超过了此限制，则正常撤消多出的行。

@param max 指示当前最大行数的 <code>int</code> 值；0 表示没有限制
@throws SQLException 如果设置 JDBC <code>RowSet</code> 对象可以包含的最大行数限制时内部发生错误；如果 <i>max</i> 小于 <code>0</code>；如果 <i>max</i> 小于 <code>RowSet</code> 的 <code>fetchSize</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setEscapeProcessing(boolean enable) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
设置为给定的 <code>boolean</code> 值，指示将 SQL 语句发送到数据库之前，驱动程序是否扫描转义语法并进行转义替换。默认值是驱动程序执行转义处理。
 <P>
注：因为 <code>PreparedStatement</code> 对象通常在调用此方法之前解析，所以对准备的语句禁用转义处理无效。

@param enable 为 <code>true</code> 表示启用转义处理；为 <code>false</code> 表示禁用该处理
@throws SQLException 如果设置底层启用 JDBC 技术的驱动程序处理转义语法时发生错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.sql.rowset.BaseRowSet.getQueryTimeout() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取驱动程序等待查询执行的最大秒数。如果超过该限制，则抛出 <code>SQLException</code>。

@return 当前的查询超时限制，以秒为单位；0 表示没有限制
@throws SQLException 如果确定查询超时值时发生错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setQueryTimeout(int seconds) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将驱动程序等待查询执行的最大秒数设置为给定的数。如果超过该限制，则抛出 <code>SQLException</code>。

@param seconds 新的查询超时限制，以秒为单位；0 表示没有限制；不得小于 0
@throws SQLException 如果设置查询超时值时发生错误，如果查询超时值小于 0

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.sql.rowset.BaseRowSet.getShowDeleted() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取一个 <code>boolean</code> 值，该值指示标记为删除的行是否会出现在当前行集合中。默认值为 <code>false</code>。
 <P>
注：允许保持已删除行可见会使某些方法的行为变得复杂。但是，多数 <code>RowSet</code> 对象的用户可以简单地忽略此额外细节，因为只有极其特殊的应用程序才会利用此功能。

@return 如果已删除行是可见的，则返回 <code>true</code>；否则返回 <code>false</code>
@throws SQLException 如果确定已删除行是否可见时发生错误
@see #setShowDeleted

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setShowDeleted(boolean value) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将属性 <code>showDeleted</code> 设置为给定的 <code>boolean</code> 值，该值指示标记为删除的行是否会出现在当前行集合中。

@param value 如果已删除行是可见的，则为 <code>true</code>；否则为 <code>false</code>
@throws SQLException 如果设置已删除行是否可见时发生错误
@see #getShowDeleted

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.sql.rowset.BaseRowSet.getEscapeProcessing() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->

确定是否为此 <code>RowSet</code> 对象启用了转义处理。

@return 如果开启了转义处理，则返回 <code>true</code>；否则返回 <code>false</code>
@throws SQLException 如果在确定是否启用转义处理时发生错误，或者尚未启用内部转义处理触发器

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setFetchDirection(int direction) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
为驱动程序提供一个性能提示，该提示指示处理此 <code>RowSet</code> 对象中各行时使用的方向。驱动程序可以忽略此提示。 
 <P>
<code>RowSet</code> 对象继承它从中获取数据的 <code>ResultSet</code> 对象的默认属性。该 <code>ResultSet</code> 对象的默认获取方向由创建它的 <code>Statement</code> 对象设置。
 <P>
仅在 <code>RowSet</code> 对象已使用 JDBC 驱动程序连接到数据库时，此方法才适用。
 <p>
<code>RowSet</code> 对象可在任何时间使用此方法来更改其有关获取方向的设置。

@param direction <code>ResultSet.FETCH_FORWARD</code>、<code>ResultSet.FETCH_REVERSE</code> 或 <code>ResultSet.FETCH_UNKNOWN</code> 之一
@throws SQLException 如果 (1) <code>RowSet</code> 类型是 <code>TYPE_FORWARD_ONLY</code> 并且给定的获取方向不是 <code>FETCH_FORWARD</code> (2) 给定的获取方向不是以下值之一：ResultSet.FETCH_FORWARD、ResultSet.FETCH_REVERSE 或 ResultSet.FETCH_UNKNOWN
@see #getFetchDirection

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.sql.rowset.BaseRowSet.getFetchDirection() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取此 <code>RowSet</code> 对象的当前有关获取方向的设置。默认类型是 <code>ResultSet.FETCH_FORWARD</code>。

@return <code>ResultSet.FETCH_FORWARD</code>、<code>ResultSet.FETCH_REVERSE</code> 或 <code>ResultSet.FETCH_UNKNOWN</code> 之一
@throws SQLException 如果确定获取行的当前获取方向时发生错误
@see #setFetchDirection

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setFetchSize(int rows) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>RowSet</code> 对象的获取大小设置为给定的行数。获取大小为启用 JDBC 技术的驱动程序（&ldquo;JDBC 驱动程序&rdquo;）提供了一个提示，该提示指示此 <code>RowSet</code> 对象还需要行时应该从数据库获取的行数。如果指定的获取大小为 0，则驱动程序忽略该值，随意对获取大小作出它自己的最佳猜测。  
 <P>
<code>RowSet</code> 对象继承它从中获取数据的 <code>ResultSet</code> 对象的默认属性。该 <code>ResultSet</code> 对象的默认获取大小由创建它的 <code>Statement</code> 对象设置。
 <P>
仅在 <code>RowSet</code> 对象已使用 JDBC 驱动程序连接到数据库时，此方法才适用。对于连接的 <code>RowSet</code> 实现（如 <code>JdbcRowSet</code>），此方法对底层 JDBC 驱动程序直接并立即产生影响。
 <P>
<code>RowSet</code> 对象可在任何时间使用此方法来更改其有关获取大小的设置。
 <p>
对于某些 <code>RowSet</code> 实现，如在非连接环境中操作的 <code>CachedRowSet</code>，正在使用的 <code>SyncProvider</code> 对象可以利用获取大小来轮询数据源、获取不超过该获取大小的多个行，以及获取可以形成原始查询所返回的实际行子集的多个行。这种实现的变化由非连接 <code>RowSet</code> 对象所使用的具体 <code>SyncProvider</code> 对象确定。
 <P>

@param rows 要获取的行数；<code>0</code> 让驱动程序决定最佳的获取大小；不得小于 <code>0</code> 或大于此 <code>RowSet</code> 对象允许的最大行数（调用方法 {@link #getMaxRows} 返回的数目）
@throws SQLException 如果指定的获取大小小于 <code>0</code> 或大于最大行数限制
@see #getFetchSize

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.sql.rowset.BaseRowSet.getFetchSize() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>RowSet</code> 对象的获取大小。默认值为 0。

@return 当此 <code>RowSet</code> 对象还需要从数据库获取行时，建议作为获取大小的行数
@throws SQLException 如果确定当前获取大小中的行数时发生错误
@see #setFetchSize

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.sql.rowset.BaseRowSet.getConcurrency() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>RowSet</code> 对象的并发性。对于连接和非连接 <code>RowSet</code> 对象而言，默认值都是 <code>CONCUR_UPDATABLE</code>。
 <P>
应用程序可以在任何时间调用方法 <code>setConcurrency</code> 来更改 <code>RowSet</code> 对象的并发性。 
 <p>
@return 此 <code>RowSet</code> 对象的并发性类型，必须是以下值之一：<code>ResultSet.CONCUR_READ_ONLY</code> 或 <code>ResultSet.CONCUR_UPDATABLE</code>
@throws SQLException 如果获得此 <code>RowSet</code> 对象的并发性时发生错误
@see #setConcurrency
@see #isReadOnly

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setNull(int parameterIndex, int sqlType) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 SQL <code>NULL</code>。注意，必须使用 <code>java.sql.Types</code> 中定义的某个类型代码指定参数的 SQL 类型。在第二个参数中指定此 SQL 类型。 
 <p>
注意，第二个参数告知 DBMS 值的数据类型被设置为 <code>NULL</code>。某些 DBMS 需要此信息，所以为了使代码更容易移植，此信息是必需的。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <P>
调用这种形式的 <code>setNull</code> 后再调用方法 <code>getParams</code> 将返回一个 <code>Object</code> 数组，其中包含已经设置的参数值。在该数组中，表示使用此方法所设置的值的元素本身也是一个数组。该数组的第一个元素为 <code>null</code>。第二个元素是为 <i>sqlType</i> 设置的值。参数编号由方法 <code>getParams</code> 返回的数组中元素的位置指示，第一个元素是第一个占位符参数的值，第二个元素是第二个占位符参数的值，依此类推。换句话说，如果将第二个占位符参数设置为 <code>null</code>，则包含该值的数组是 <code>getParams</code> 返回的数组中的第二个元素。
 <P>
注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是 <i>parameterIndex</i> -1。

@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param sqlType 一个 <code>int</code> 值，是类 {@link java.sql.Types} 中定义的 SQL 类型代码之一。如果提供了非标准的 <i>sqlType</i>，则此方法不会抛出 <code>SQLException</code>。这隐含着对非标准 SQL 类型的支持。
@throws SQLException 如果发生数据库访问错误或者给定的参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setNull(int parameterIndex, int sqlType, String typeName) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 SQL <code>NULL</code>。
 
虽然这种形式的 <code>setNull</code> 方法用于用户定义的参数和 <code>REF</code> 参数，但是也可使用此方法设置任意 JDBC 类型的 null 参数。以下是用户定义的类型：<code>STRUCT</code>、<code>DISTINCT</code>、<code>JAVA_OBJECT</code> 和指定数组类型。
  
<P><B>注：</B>为了便于移植，在指定 <code>NULL</code> 用户定义参数或 <code>REF</code> 参数时，应用程序必须提供 SQL 类型代码和完全限定的 SQL 类型名称。在用户定义类型的情况下，名称是参数本身的类型名称。对于 <code>REF</code> 参数，名称是所引用类型的类型名称。如果启用 JDBC 技术的驱动程序不需要类型代码和类型名称信息，那么它可以忽略这些信息。
 <P> 
如果该参数没有用户定义的类型或 <code>REF</code> 类型，则忽略给定的 <code>typeName</code> 参数。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <P>
调用这种形式的 <code>setNull</code> 后再调用方法 <code>getParams</code> 将返回一个 <code>Object</code> 数组，其中包含已经设置的参数值。在该数组中，表示使用此方法所设置的值的元素本身也是一个数组。该数组的第一个元素为 <code>null</code>。第二个元素是为 <i>sqlType</i> 设置的值，第三个元素是为 <i>typeName</i> 设置的值。参数编号由方法 <code>getParams</code> 返回的数组中元素的位置指示，第一个元素是第一个占位符参数的值，第二个元素是第二个占位符参数的值，依此类推。换句话说，如果将第二个占位符参数设置为 <code>null</code>，则包含该值的数组是 <code>getParams</code> 返回的数组中的第二个元素。
 <P>
注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是 <i>parameterIndex</i> -1。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param sqlType <code>java.sql.Types</code> 中的值
@param typeName SQL 用户定义类型的完全限定名，如果该参数不是用户定义类型或 <code>REF</code> 值，则忽略该参数
@throws SQLException 如果发生错误或者给定的参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setBoolean(int parameterIndex, boolean x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 Java 编程语言中的给定 <code>boolean</code> 值。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>BIT</code> 值。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <p>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。     
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 参数值
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setByte(int parameterIndex, byte x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 Java 编程语言中的给定 <code>byte</code> 值。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>TINYINT</code> 值。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。     
 <p>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 参数值
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setShort(int parameterIndex, short x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 Java 编程语言中的给定 <code>short</code> 值。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>SMALLINT</code> 值。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。     
 <p>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <p>
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 参数值
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setInt(int parameterIndex, int x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 Java 编程语言中的 <code>int</code> 值。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>INTEGER</code> 值。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 参数值
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setLong(int parameterIndex, long x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 Java 编程语言中的给定 <code>long</code> 值。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>BIGINT</code> 值。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <P> 
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
  
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 参数值
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setFloat(int parameterIndex, float x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 Java 编程语言中的给定 <code>float</code> 值。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>FLOAT</code> 值。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 参数值
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setDouble(int parameterIndex, double x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 Java 编程语言中的给定 <code>double</code> 值。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>DOUBLE</code> 值。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。    
 <P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 参数值
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setBigDecimal(int parameterIndex, BigDecimal x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>java.lang.BigDecimal</code> 值。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>NUMERIC</code> 值。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 参数值
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setString(int parameterIndex, String x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>String</code> 值。在将此值发送给数据库时，驱动程序将它转换成一个 SQL <code>VARCHAR</code> 或 <code>LONGVARCHAR</code> 值（取决于该参数相对于驱动程序在 <code>VARCHAR</code> 值上的限制的相对大小）。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <p>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <p>
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 参数值
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setBytes(int parameterIndex, byte[] x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 byte 数组。在将此值发送给数据库时，驱动程序将它转换成一个 SQL <code>VARBINARY</code> 或 <code>LONGVARBINARY</code> 值（取决于该参数相对于驱动程序在 <code>VARBINARY</code> 值上的限制的相对大小）。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <p>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 参数值
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setDate(int parameterIndex, Date x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>java.sql.Date</code> 值。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>DATE</code> 值。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <P>
调用这种形式的 <code>setDate</code> 后再调用方法 <code>getParams</code> 将返回一个数组，其中要为占位符参数编号 <i>parameterIndex</i> 设置的值是作为第二个参数提供的 <code>Date</code> 对象。注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是 <i>parameterIndex</i> -1。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 参数值
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setTime(int parameterIndex, Time x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>java.sql.Time</code> 值。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>TIME</code> 值。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <P>
调用这种形式的 <code>setTime</code> 方法后再调用方法 <code>getParams</code> 将返回一个已经设置的参数所组成的数组。要为参数占位符编号 <i>parameterIndex</i> 进行设置的参数是设置为此方法第二个参数的 <code>Time</code> 对象。
 <P>
注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是 <i>parameterIndex</i> -1。

@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 一个 <code>java.sql.Time</code> 对象，将设置为占位符参数 <i>parameterIndex</i> 的值
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setTimestamp(int parameterIndex, Timestamp x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>java.sql.Timestamp</code> 值。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>TIMESTAMP</code> 值。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <P>
调用这种形式的 <code>setTimestamp</code> 后再调用方法 <code>getParams</code> 将返回一个数组，其中占位符参数编号 <i>parameterIndex</i> 的值是作为此方法第二个参数提供的 <code>Timestamp</code> 对象。注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是 <i>parameterIndex</i> -1。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 一个 <code>java.sql.Timestamp</code> 对象
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setAsciiStream(int parameterIndex, InputStream x, int length) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>java.io.InputStream</code> 对象，该对象将具有指定的字节数。将读取该流的内容并发送到数据库。如果读取并发送到数据库的字节数不等于 <i>length</i>，则此方法抛出 <code>SQLException</code> 对象。
 <P>
在将一个非常大的 ASCII 值输入到 <code>LONGVARCHAR</code> 参数时，通过 <code>java.io.InputStream</code> 对象将它发送给参数可能更实际一些。在到达文件末尾之前，启用 JDBC 技术的驱动程序将根据需要从该流读取数据。驱动程序将执行从 ASCII 到数据库 <code>CHAR</code> 格式的任何必要转换。
   
<P><B>注：</B>此流对象既可以是一个标准 Java 流对象，也可以是实现标准接口的用户自己的子类。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。     
 <P>
调用 <code>setAsciiStream</code> 后再调用方法 <code>getParams</code> 将返回一个数组，其中包含已经设置的参数值。在该数组中，表示使用此方法所设置的值的元素本身也是一个数组。该数组的第一个元素是给定的 <code>java.io.InputStream</code> 对象。第二个元素是为 <i>length</i> 设置的值。第三个元素是内部 <code>BaseRowSet</code> 常量，指示传递到此方法的流是一个 ASCII 流。参数编号由方法 <code>getParams</code> 返回的数组中元素的位置指示，第一个元素是第一个占位符参数的值，第二个元素是第二个占位符参数的值，依此类推。换句话说，如果正在设置的输入流是第二个占位符参数的值，则包含该值的数组将是 <code>getParams</code> 返回数组中的第二个元素。
 <P>
注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是元素编号 <i>parameterIndex</i> -1。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 包含 ASCII 参数值的 Java 输入流
@param length 流中的字节数。这是驱动程序要发送到 DBMS 的字节数；长度为 0 或小于 0 是未定义的，但会导致在底层 JDBC 驱动程序中抛出无效长度异常。
@throws SQLException 如果发生错误、参数索引超出范围，或者当连接到数据源时，驱动程序读取和发送到数据库的字节数不等于 <i>length</i> 中指定的字节数
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setAsciiStream(int parameterIndex, InputStream x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>RowSet</code> 对象命令中的指定参数设置为给定输入流。在将一个非常大的 ASCII 值输入到 <code>LONGVARCHAR</code> 参数时，通过 <code>java.io.InputStream</code> 发送它可能更为实际。将根据需要从流中读取数据，一直读取到文件末尾。JDBC 驱动程序将执行从 ASCII 到数据库 char 格式的任何必要转换。

<P><B>注：</B> 此流对象既可以是一个标准 Java 流对象，也可以是实现标准接口的用户自己的子类。
<P><B>注：</B> 请参考 JDBC 驱动程序文档确定使用带有长度参数的 <code>setAsciiStream</code> 是否更有效。

 @param parameterIndex 第一个参数的索引是 1，第二个参数的索引是 2 ……
 @param x 包含 ASCII 参数值的 Java 输入流
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>PreparedStatement</code> 上调用此方法
 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setBinaryStream(int parameterIndex, InputStream x, int length) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->

将指定参数设置为给定的 <code>java.io.InputStream</code> 对象，该对象具有指定的字节数。将读取该流的内容并发送到数据库。如果读取并发送到数据库的字节数不等于 <i>length</i>，则此方法抛出 <code>SQLException</code> 对象。
 <P>
在将一个非常大的二进制值输入到 <code>LONGVARBINARY</code> 参数时，通过 <code>java.io.InputStream</code> 对象发送它可能更为实际。在到达文件末尾之前，启用 JDBC 技术的驱动程序将根据需要从该流读取数据。 
   
<P><B>注：</B>此流对象既可以是一个标准 Java 流对象，也可以是实现标准接口的用户自己的子类。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
<P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <P>
调用 <code>setBinaryStream</code> 后再调用方法 <code>getParams</code> 将返回一个数组，其中包含已经设置的参数值。在该数组中，表示使用此方法所设置的值的元素本身也是一个数组。该数组的第一个元素是给定的 <code>java.io.InputStream</code> 对象。第二个元素是为 <i>length</i> 设置的值。第三个元素是内部 <code>BaseRowSet</code> 常量，指示传递到此方法的流是一个二进制流。参数编号由方法 <code>getParams</code> 返回的数组中元素的位置指示，第一个元素是第一个占位符参数的值，第二个元素是第二个占位符参数的值，依此类推。换句话说，如果正在设置的输入流是第二个占位符参数的值，则包含该值的数组将是 <code>getParams</code> 返回数组中的第二个元素。
 <P>
注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是元素编号 <i>parameterIndex</i> -1。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 包含要设置的二进制值的输入流
@param length 流中的字节数；长度为 0 或小于 0 是未定义的，但会导致在底层 JDBC 驱动程序中抛出无效长度异常。
@throws SQLException 如果发生错误、参数索引超出范围，或者当连接到数据源时，驱动程序读取和发送到数据库的字节数不等于 <i>length</i> 中指定的字节数
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setBinaryStream(int parameterIndex, InputStream x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>RowSet</code> 对象命令中的指定参数设置为给定输入流。在将一个非常大的二进制值输入到 <code>LONGVARBINARY</code> 参数时，通过 <code>java.io.InputStream</code> 对象发送它可能更为实际。将根据需要从流中读取数据，一直读取到文件末尾。

<P><B>注：</B> 此流对象既可以是一个标准 Java 流对象，也可以是实现标准接口的用户自己的子类。
<P><B>注：</B> 请参考 JDBC 驱动程序文档确定使用带有长度参数的 <code>setBinaryStream</code> 是否更有效。

 @param parameterIndex 第一个参数的索引是 1，第二个参数的索引是 2 ……
 @param x 包含二进制参数值的 java 输入流
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>PreparedStatement</code> 上调用此方法  
 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setUnicodeStream(int parameterIndex, InputStream x, int length) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->

将指定参数设置为给定的 <code>java.io.InputStream</code> 对象，该对象具有指定的字节数。将读取该流的内容并发送到数据库。如果读取和发送到数据库的字节数不等于 <i>length</i>，则此方法抛出 <code>SQLException</code>。
 <P>
在将一个非常大的 Unicode 值输入到 <code>LONGVARCHAR</code> 参数时，通过 <code>java.io.InputStream</code> 对象发送它可能更为实际。在到达文件末尾之前，启用 JDBC 技术的驱动程序将根据需要从该流读取数据。驱动程序将执行从 Unicode 到数据库 <code>CHAR</code> 格式的任何必要转换。Unicode 流的字节格式必须是 Java UTF-8，这在 Java 虚拟机规范中定义。
   
<P><B>注：</B>此流对象既可以是一个标准 Java 流对象，也可以是实现标准接口的用户自己的子类。
 <P>
此方法已废弃，应该使用 <code>getCharacterStream</code> 替代它。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。调用 <code>setUnicodeStream</code> 后再调用方法 <code>getParams</code> 将返回一个数组，其中包含已经设置的参数值。在该数组中，表示使用此方法所设置的值的元素本身也是一个数组。该数组的第一个元素是给定的 <code>java.io.InputStream</code> 对象。第二个元素是为 <i>length</i> 设置的值。第三个元素是内部 <code>BaseRowSet</code> 常量，指示传递到此方法的流是一个 Unicode 流。参数编号由方法 <code>getParams</code> 返回的数组中元素的位置指示，第一个元素是第一个占位符参数的值，第二个元素是第二个占位符参数的值，依此类推。换句话说，如果正在设置的输入流是第二个占位符参数的值，则包含该值的数组将是 <code>getParams</code> 返回数组中的第二个元素。
 <P>
注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是元素编号 <i>parameterIndex</i> -1。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 包含 UNICODE 参数值的 <code>java.io.InputStream</code> 对象
@param length 输入流中的字节数
@throws SQLException 如果发生错误、参数索引超出范围，或者驱动程序读取和发送到数据库的字节数不等于 <i>length</i> 中指定的字节数
@deprecated 应该使用 getCharacterStream 替代它
@see #getParams 

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setCharacterStream(int parameterIndex, Reader reader, int length) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>java.io.Reader</code> 对象，该对象具有指定的字符数。将读取该 reader 的内容并发送到数据库。如果读取和发送到数据库的字节数不等于 <i>length</i>，则此方法抛出 <code>SQLException</code>。
 <P>
在将一个非常大的 Unicode 值输入到 <code>LONGVARCHAR</code> 参数时，通过 <code>Reader</code> 对象发送它可能更为实际。在到达文件末尾之前，启用 JDBC 技术的驱动程序将根据需要从该流读取数据。驱动程序将执行从 Unicode 到数据库 <code>CHAR</code> 格式的任何必要转换。Unicode 流的字节格式必须是 Java UTF-8，这在 Java 虚拟机规范中定义。
  
<P><B>注：</B>此流对象既可以是一个标准 Java 流对象，也可以是实现标准接口的用户自己的子类。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <P>
调用 <code>setCharacterStream</code> 后再调用方法 <code>getParams</code> 将返回一个数组，其中包含已经设置的参数值。在该数组中，表示使用此方法所设置的值的元素本身也是一个数组。该数组的第一个元素是给定的 <code>java.io.Reader</code> 对象。第二个元素是为 <i>length</i> 设置的值。参数编号由方法 <code>getParams</code> 返回的数组中元素的位置指示，第一个元素是第一个占位符参数的值，第二个元素是第二个占位符参数的值，依此类推。换句话说，如果正在设置的 reader 是第二个占位符参数的值，则包含该值的数组将是 <code>getParams</code> 返回数组中的第二个元素。
 <P>
注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是元素编号 <i>parameterIndex</i> -1。

@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param reader 包含 Unicode 数据的 <code>Reader</code> 对象
@param length 流中的字符数；长度为 0 或小于 0 是未定义的，但会导致在底层 JDBC 驱动程序中抛出无效长度异常。
@throws SQLException 如果发生错误、参数索引超出范围，或者当连接到数据源时，驱动程序读取和发送到数据库的字节数不等于 <i>length</i> 中指定的字节数
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setCharacterStream(int parameterIndex, Reader reader) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>RowSet</code> 对象命令中的指定参数设置为给定的 <code>Reader</code> 对象。在将一个非常大的 UNICODE 值输入到 <code>LONGVARCHAR</code> 参数时，通过 <code>java.io.Reader</code> 对象发送它可能更为实际。将根据需要从流中读取数据，一直读取到文件末尾。JDBC 驱动程序将执行从 UNICODE 到数据库 char 格式的任何必要转换。

<P><B>注：</B> 此流对象既可以是一个标准 Java 流对象，也可以是实现标准接口的用户自己的子类。
<P><B>注：</B> 请参考 JDBC 驱动程序文档确定使用带有长度参数的 <code>setCharacterStream</code> 是否更有效。

 @param parameterIndex 第一个参数的索引是 1，第二个参数的索引是 2 …… 
 @param reader 包含 Unicode 数据的 <code>java.io.Reader</code> 对象
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>PreparedStatement</code> 上调用此方法 
 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setObject(int parameterIndex, Object x, int targetSqlType, int scale) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 Java 编程语言中的 <code>Object</code>。第二个参数必须是 <code>Object</code> 类型。对于整数值，应该使用 <code>java.lang</code> 等效对象。例如，为 <code>int</code> 使用类 <code>Integer</code>。
 <P>
将此对象发送到数据库前，驱动程序将它转换成指定的目标 SQL 类型。如果对象具有自定义映射（属于实现 <code>SQLData</code> 的类），则驱动程序应该调用 <code>SQLData.writeSQL</code> 方法将该对象写入 SQL 数据流中。另一方面，如果该对象是实现 <code>Ref</code>、<code>Blob</code>、<code>Clob</code>、<code>Struct</code> 或 <code>Array</code> 的类，则驱动程序应该将它作为相应 SQL 类型的值传递给数据库。
 <P> 
<p>注意，此方法可用于传递特定于数据库的抽象数据类型。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。调用这种形式的 <code>setObject</code> 后再调用方法 <code>getParams</code> 将返回一个数组，其中包含已经设置的参数值。在该数组中，表示使用此方法所设置的值的元素本身也是一个数组。该数组的第一个元素是给定的 <code>Object</code> 实例。第二个元素是为 <i>targetSqlType</i> 设置的值。第三个元素是为 <i>scale</i> 设置的值，如果要设置的对象类型不是 <code>java.sql.Types.NUMERIC</code> 或 <code>java.sql.Types.DECIMAL</code>，则驱动程序忽略该值。参数编号由方法 <code>getParams</code> 返回的数组中的元素位置指示，第一个元素是第一个占位符参数的值，第二个元素是第二个占位符参数的值，依此类推。换句话说，如果正在设置的对象是第二个占位符参数的值，则包含该值的数组是 <code>getParams</code> 返回数组中的第二个元素。
<P>
注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是元素编号 <i>parameterIndex</i> -1。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 包含输入参数值的 <code>Object</code>；必须是 <code>Object</code> 类型
@param targetSqlType 要发送到数据库的 SQL 类型（在 <code>java.sql.Types</code> 中定义）。<code>scale</code> 参数可以进一步限定此类型。如果提供了非标准的 <i>targetSqlType</i>，则此方法不会抛出 <code>SQLException</code>。这隐含着对非标准 SQL 类型的支持。
@param scale 对于类型 <code>java.sql.Types.DECIMAL</code> 和 <code>java.sql.Types.NUMERIC</code>，该值是小数点后的位数。对于所有其他类型，将忽略此值。
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setObject(int parameterIndex, Object x, int targetSqlType) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用给定 <code>Object</code> 值设置指定参数的值。此方法类似于 <code>setObject(int parameterIndex, Object x, int targetSqlType, int scale)</code>，不同之处在于它假定 scale 为 0。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <P>
调用这种形式的 <code>setObject</code> 后再调用方法 <code>getParams</code> 将返回一个数组，其中包含已经设置的参数值。在该数组中，表示使用此方法所设置的值的元素本身也是一个数组。该数组的第一个元素是给定的 <code>Object</code> 实例。第二个元素是为 <i>targetSqlType</i> 设置的值。参数编号由方法 <code>getParams</code> 返回的数组中元素的位置指示，第一个元素是第一个占位符参数的值，第二个元素是第二个占位符参数的值，依此类推。换句话说，如果正在设置的对象是第二个占位符参数的值，则包含该值的数组是 <code>getParams</code> 返回数组中的第二个元素。
 <P>
注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是元素编号 <i>parameterIndex</i> -1。

@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 包含输入参数值的 <code>Object</code>；必须是 <code>Object</code> 类型
@param targetSqlType 要发送到数据库的 SQL 类型（在 <code>java.sql.Types</code> 中定义）。如果提供了非标准的 <i>targetSqlType</i>，则此方法不会抛出 <code>SQLException</code>。这隐含着对非标准 SQL 类型的支持。
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setObject(int parameterIndex, Object x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 Java 编程语言中的 <code>Object</code>。第二个参数必须是 <code>Object</code> 类型。对于整数值，应该使用 <code>java.lang</code> 等效对象。例如，为 <code>int</code> 使用类 <code>Integer</code>。
 <P>
JDBC 规范定义了一个从 Java <code>Object</code> 类型到 SQL 类型的标准映射。在将给定的对象发送到数据库之前，驱动程序使用此标准映射将其转换为对应的 SQL 类型。如果对象具有自定义映射（属于实现 <code>SQLData</code> 的类），则驱动程序应该调用 <code>SQLData.writeSQL</code> 方法将该对象写入 SQL 数据流中。
 <P>
另一方面，如果该对象是实现 <code>Ref</code>、<code>Blob</code>、<code>Clob</code>、<code>Struct</code> 或 <code>Array</code> 的类，则驱动程序应该将它作为相应 SQL 类型的值传递给数据库。
 <P> 
如果出现混淆，例如如果该对象是实现多个接口的类，则此方法抛出异常。
 <P> 
注意，此方法可用于传递特定于数据库的抽象数据类型。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <p>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <P>
调用此方法后再调用方法 <code>getParams</code> 将返回一个当前命令参数的 object 数组，其中包括已为占位符参数编号 <code>parameterIndex</code> 设置的 <code>Object</code>。注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是元素编号 <i>parameterIndex</i> -1。

@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 包含输入参数值的对象
@throws SQLException 如果发生错误、参数索引超出范围，或者在要设置的对象实现方面存在混淆
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setRef(int parameterIndex, Ref ref) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 Java 编程语言中的给定 <code>Ref</code> 对象。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>REF</code> 值。在内部，该 <code>Ref</code> 被表示成 <code>SerialRef</code>，以确保可序列化性。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <p>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <p>
调用此方法后再调用方法 <code>getParams</code> 将返回一个当前命令参数的 object 数组，其中包括已为占位符参数编号 <code>parameterIndex</code> 设置的 <code>Ref</code> 对象。注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是元素编号 <i>parameterIndex</i> -1。

@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param ref 表示 SQL <code>REF</code> 值的 <code>Ref</code> 对象；不能为 null
@throws SQLException 如果发生错误、参数索引超出范围，或者 <code>Ref</code> 对象为 <code>null</code>；或者 <code>Ref</code> 对象返回 <code>null</code> 基本类型名称。
@see #getParams
@see javax.sql.rowset.serial.SerialRef

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setBlob(int parameterIndex, Blob x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 Java 编程语言中的给定 <code>Blob</code> 对象。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>BLOB</code> 值。在内部，该 <code>Blob</code> 被表示成 <code>SerialBlob</code>，以确保可序列化性。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <p>
调用此方法后再调用方法 <code>getParams</code> 将返回一个当前命令参数的 object 数组，其中包括已为占位符参数编号 <code>parameterIndex</code> 设置的 <code>Blob</code> 对象。注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是元素编号 <i>parameterIndex</i> -1。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 表示 SQL <code>BLOB</code> 值的 <code>Blob</code> 对象
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams
@see javax.sql.rowset.serial.SerialBlob

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setClob(int parameterIndex, Clob x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 Java 编程语言中的给定 <code>Clob</code> 对象。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>CLOB</code> 值。在内部，该 <code>Clob</code> 被表示成 <code>SerialClob</code>，以确保可序列化性。     
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <p>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <p>
调用此方法后再调用方法 <code>getParams</code> 将返回一个当前命令参数的 object 数组，其中包括已为占位符参数编号 <code>parameterIndex</code> 设置的 <code>Clob</code> 对象。注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是元素编号 <i>parameterIndex</i> -1。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 表示 SQL <code>CLOB</code> 值的 <code>Clob</code> 对象；不能为 null
@throws SQLException 如果发生错误、参数索引超出范围，或者 <code>Clob</code> 为 null
@see #getParams
@see javax.sql.rowset.serial.SerialBlob

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setArray(int parameterIndex, Array array) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 Java 编程语言中的 <code>Array</code> 对象。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>ARRAY</code> 值。在内部，该 <code>Array</code> 被表示成 <code>SerialArray</code>，以确保可序列化性。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <p>
调用此方法后再调用方法 <code>getParams</code> 将返回一个当前命令参数的 object 数组，其中包括已为占位符参数编号 <code>parameterIndex</code> 设置的 <code>Array</code> 对象。注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是元素编号 <i>parameterIndex</i> -1。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param array 表示 SQL <code>ARRAY</code> 值的 <code>Array</code> 对象，不能为 null。传递到此方法的 <code>Array</code> 对象必须对所有调用的 <code>getArray()</code> 方法返回非 null 的 Object。null 值将导致抛出 <code>SQLException</code>。
@throws SQLException 如果发生错误、参数索引超出范围或者 <code>ARRAY</code> 为 null
@see #getParams
@see javax.sql.rowset.serial.SerialArray

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setDate(int parameterIndex, Date x, Calendar cal) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>java.sql.Date</code> 对象。当 DBMS 不存储时区信息时，驱动程序将使用给定的 <code>Calendar</code> 对象构造要发送到数据库的 SQL <code>DATE</code> 值。利用 <code>Calendar</code> 对象，驱动程序可以在考虑自定义时区的情况下计算日期。如果没有指定任何 <code>Calendar</code> 对象，则驱动程序使用运行应用程序的虚拟机所在的时区。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <P>
调用这种形式的 <code>setDate</code> 后再调用方法 <code>getParams</code> 将返回一个数组，其中包含已经设置的参数值。在该数组中，表示使用此方法所设置的值的元素本身也是一个数组。该数组的第一个元素是给定的 <code>java.sql.Date</code> 对象。第二个元素是为 <i>cal</i> 设置的值。参数编号由方法 <code>getParams</code> 返回的数组中元素的位置指示，第一个元素是第一个占位符参数的值，第二个元素是第二个占位符参数的值，依此类推。换句话说，如果正在设置的 date 是第二个占位符参数的值，则包含该值的数组是 <code>getParams</code> 返回数组中的第二个元素。
 <P>
注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是 <i>parameterIndex</i> -1。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 表示 SQL <code>DATE</code> 值的 <code>java.sql.Date</code> 对象
@param cal 构造日期时所使用的 <code>java.util.Calendar</code> 对象
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setTime(int parameterIndex, Time x, Calendar cal) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>java.sql.Time</code> 对象。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>TIME</code> 值。
 <P>
当 DBMS 不存储时区信息时，驱动程序将使用给定的 <code>Calendar</code> 对象构造要发送到数据库的 SQL <code>TIME</code> 值。利用 <code>Calendar</code> 对象，驱动程序可以在考虑自定义时区的情况下计算日期。如果没有指定任何 <code>Calendar</code> 对象，则驱动程序使用运行应用程序的虚拟机所在的时区。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <P>
调用这种形式的 <code>setTime</code> 后再调用方法 <code>getParams</code> 将返回一个数组，其中包含已经设置的参数值。在该数组中，表示使用此方法所设置的值的元素本身也是一个数组。该数组的第一个元素是给定的 <code>java.sql.Time</code> 对象。第二个元素是为 <i>cal</i> 设置的值。参数编号由方法 <code>getParams</code> 返回的数组中元素的位置指示，第一个元素是第一个占位符参数的值，第二个元素是第二个占位符参数的值，依此类推。换句话说，如果正在设置的 time 是第二个占位符参数的值，则包含该值的数组是 <code>getParams</code> 返回数组中的第二个元素。
 <P>
注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是 <i>parameterIndex</i> -1。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 一个 <code>java.sql.Time</code> 对象
@param cal 驱动程序可用来构造时间的 <code>java.util.Calendar</code> 对象
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setTimestamp(int parameterIndex, Timestamp x, Calendar cal) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>java.sql.Timestamp</code> 对象。在将该对象发送到数据库时，驱动程序将它转换成一个 SQL <code>TIMESTAMP</code> 值。
 <P>
当 DBMS 不存储时区信息时，驱动程序将使用给定的 <code>Calendar</code> 对象构造要发送到数据库的 SQL <code>TIMESTAMP</code> 值。利用 <code>Calendar</code> 对象，驱动程序可以在考虑自定义时区的情况下计算 timestamp。如果没有指定任何 <code>Calendar</code> 对象，则驱动程序使用运行应用程序的虚拟机所在的时区。
 <P>
此方法设置的参数值是内部存储的，当调用方法 <code>execute</code> 时，将该值作为此 <code>RowSet</code> 对象命令中的适当参数提供。必须在扩展此类和实现了一个或多个标准 JSR-114 <code>RowSet</code> 接口的所有类中提供 <code>execute</code> 和 <code>populate</code> 之类的方法。
 <P>
注：<code>JdbcRowSet</code> 不需要 <code>populate</code> 方法，因为它没有在此类中定义。
 <P>
调用这种形式的 <code>setTimestamp</code> 后再调用方法 <code>getParams</code> 将返回一个数组，其中包含已经设置的参数值。在该数组中，表示使用此方法所设置的值的元素本身也是一个数组。该数组的第一个元素是给定的 <code>java.sql.Timestamp</code> 对象。第二个元素是为 <i>cal</i> 设置的值。参数编号由方法 <code>getParams</code> 返回的数组中元素的位置指示，第一个元素是第一个占位符参数的值，第二个元素是第二个占位符参数的值，依此类推。换句话说，如果正在设置的 timestamp 是第二个占位符参数的值，则包含该值的数组是 <code>getParams</code> 返回数组中的第二个元素。
 <P>
注意，因为数组中的元素编号从 0 开始，所以对应于占位符参数编号 <i>parameterIndex</i> 的数组元素是 <i>parameterIndex</i> -1。
   
@param parameterIndex 此 <code>RowSet</code> 对象命令中要设置的占位符参数的序号。第一个参数是 1，第二个参数是 2，依此类推；必须大于等于 <code>1</code>
@param x 一个 <code>java.sql.Timestamp</code> 对象
@param cal 驱动程序构造 timestamp 所使用的 <code>java.util.Calendar</code> 对象
@throws SQLException 如果发生错误或者参数索引超出范围
@see #getParams

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.clearParameters() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
清除所有此 <code>RowSet</code> 对象的内部参数表示形式的当前参数值，这些参数值将在执行此 <code>RowSet</code> 对象的命令时在其中设置这些参数。
 <P>
通常参数值对此 <code>RowSet</code> 对象的重复使用仍然有效。使用设置方法设置参数值可自动清除指定参数的值，并用新的指定值替换该值。
 <P>
此方法由 <code>setCommand</code> 方法内部调用，以清除前一条命令设置的所有参数。
 <P>
另外，此方法与 <code>initParams</code> 方法的不同之处在于它保持 <code>RowSet</code> 对象的模式。

@throws SQLException 如果清除参数时发生错误

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.Object[] javax.sql.rowset.BaseRowSet.getParams() throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
获取一个数组，其中包含为此 <code>RowSet</code> 对象命令设置的参数值（包括 Object 和基本类型），如果尚未设置任何参数，则抛出 <code>SQLException</code> 对象。将命令发送到 DBMS 执行前，这些参数将替换 <code>PreparedStatement</code> 对象中的占位符参数，该对象是用于扩展了 <code>BaseRowSet</code> 类的 <code>RowSet</code> 实现的命令。
 <P>
返回数组的每个元素都是一个 <code>Object</code> 实例，包含提供给设置方法的参数值。元素的顺序由提供给 <i>parameterIndex</i> 的值确定。如果设置方法仅带有参数索引和要设置的值（可能为 null），则数组元素将包含要设置的值（以 <code>Object</code> 的形式表示）。如果还有附加参数，则数组元素本身就是一个数组，包含要设置的值和所有提供给设置方法的附加参数值。如果该方法设置一个流，则数组元素包括将提供给该方法的流类型。这些附加参数供驱动程序或 DBMS 使用，可以使用这些参数，也可以不使用。
 <P>
注：类型 <code>Array</code>、<code>Blob</code>、<code>Clob</code> 和 <code>Ref</code> 的已存储参数值分别以 <code>SerialArray</code>、<code>SerialBlob</code>、<code>SerialClob</code> 和 <code>SerialRef</code> 的形式返回。

@return <code>Object</code> 实例所组成的数组，包括在此 <code>RowSet</code> 对象的命令中所设置的参数值；如果尚未设置任何参数，则返回空数组
@throws SQLException 如果获取此 <code>RowSet</code> 对象参数的对象数组时发生错误，或者并非所有的参数都已经设置

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setNull(String parameterName, int sqlType) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 将指定参数设置为 SQL <code>NULL</code>。

 <P><B>注：</B> 必须指定参数的 SQL 类型。

 @param parameterName 参数的名称
 @param sqlType <code>java.sql.Types</code> 中定义的 SQL 类型代码
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setNull(String parameterName, int sqlType, String typeName) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 SQL <code>NULL</code>。这种 <code>setNull</code> 方法应该用于用户定义类型和 REF 类型参数。用户定义类型的示例有：STRUCT、DISTINCT、JAVA_OBJECT 和指定数组类型。

<P><B>注：</B> 为了便于移植，在指定 NULL 用户定义参数或 REF 参数时，应用程序必须提供 SQL 类型代码和完全限定的 SQL 类型名称。对于用户定义类型，名称是参数本身的类型名称。对于 REF 参数，名称是所引用类型的类型名称。 如果 JDBC 驱动程序不需要类型代码或类型名称信息，那么它可以忽略这些信息。

尽管此方法供用户定义参数和 Ref 参数使用，但也可以使用它来设置任何 JDBC 类型的 null 参数。如果该参数不具有用户定义类型或 REF 类型，则忽略给定 typeName。


 @param parameterName 参数的名称
 @param sqlType 取自 <code>java.sql.Types</code> 的值
 @param typeName SQL 用户定义类型的完全限定名称；如果该参数不是用户定义类型或 SQL <code>REF</code> 值，则忽略它
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setBoolean(String parameterName, boolean x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 Java <code>boolean</code> 值。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>BIT</code> 或 <code>BOOLEAN</code> 值。

 @param parameterName 参数的名称
 @param x 参数值
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @see #getBoolean
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setByte(String parameterName, byte x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 将指定参数设置为给定的 Java <code>byte</code> 值。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>TINYINT</code> 值。

 @param parameterName 参数的名称
 @param x 参数值
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @see #getByte
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setShort(String parameterName, short x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 将指定参数设置为给定的 Java <code>short</code> 值。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>SMALLINT</code> 值。

 @param parameterName 参数的名称
 @param x 参数值
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @see #getShort
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setInt(String parameterName, int x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 将指定参数设置为给定的 Java <code>int</code> 值。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>INTEGER</code> 值。

 @param parameterName 参数的名称
 @param x 参数值
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @see #getInt
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setLong(String parameterName, long x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 将指定参数设置为给定的 Java <code>long</code> 值。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>BIGINT</code> 值。

 @param parameterName 参数的名称
 @param x 参数值
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @see #getLong
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setFloat(String parameterName, float x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 将指定参数设置为给定的 Java <code>float</code> 值。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>FLOAT</code> 值。

 @param parameterName 参数的名称
 @param x 参数值
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @see #getFloat
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setDouble(String parameterName, double x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 将指定参数设置为给定的 Java <code>double</code> 值。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>DOUBLE</code> 值。

 @param parameterName 参数的名称
 @param x 参数值
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @see #getDouble
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setBigDecimal(String parameterName, BigDecimal x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 将指定参数设置为给定的 <code>java.math.BigDecimal</code> 值。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>NUMERIC</code> 值。

 @param parameterName 参数的名称
 @param x 参数值
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @see #getBigDecimal
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setString(String parameterName, String x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 Java <code>String</code> 值。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>VARCHAR</code> 或 <code>LONGVARCHAR</code> 值（具体取决于该参数相对于驱动程序在 <code>VARCHAR</code> 值上的限制的大小）。

 @param parameterName 参数的名称
 @param x 参数值
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @see #getString
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setBytes(String parameterName, byte[] x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 Java byte 数组。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>VARBINARY</code> 或 <code>LONGVARBINARY</code> 值（具体取决于该参数相对于驱动程序在 <code>VARBINARY</code> 值上的限制的大小）。

 @param parameterName 参数的名称
 @param x 参数值
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @see #getBytes
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setTimestamp(String parameterName, Timestamp x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 将指定参数设置为给定的 <code>java.sql.Timestamp</code> 值。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>TIMESTAMP</code> 值。

 @param parameterName 参数的名称
 @param x 参数值
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @see #getTimestamp
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setAsciiStream(String parameterName, InputStream x, int length) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定输入流，该输入流将拥有指定字节数。在将一个非常大的 ASCII 值输入到 <code>LONGVARCHAR</code> 参数时，通过 <code>java.io.InputStream</code> 发送它可能更为实际。将根据需要从流中读取数据，一直读取到文件末尾。JDBC 驱动程序将执行从 ASCII 到数据库 char 格式的任何必要转换。

 <P><B>注：</B> 此流对象既可以是一个标准 Java 流对象，也可以是实现标准接口的用户自己的子类。

 @param parameterName 参数的名称
 @param x 包含 ASCII 参数值的 Java 输入流
 @param length 流中的字节数
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setBinaryStream(String parameterName, InputStream x, int length) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的输入流，该输入流将拥有指定的字节数。在将一个非常大的二进制值输入到 <code>LONGVARBINARY</code> 参数时，通过 <code>java.io.InputStream</code> 对象发送它可能更为实际。将根据需要从流中读取数据，一直读取到文件末尾。 

 <P><B>注：</B> 此流对象既可以是一个标准 Java 流对象，也可以是实现标准接口的用户自己的子类。

 @param parameterName 参数的名称
 @param x 包含二进制参数值的 java 输入流
 @param length 流中的字节数
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setCharacterStream(String parameterName, Reader reader, int length) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>Reader</code> 对象，该对象是给定的字符长度数目。在将一个非常大的 UNICODE 值输入到 <code>LONGVARCHAR</code> 参数时，通过 <code>java.io.Reader</code> 对象发送它可能更为实际。将根据需要从流中读取数据，一直读取到文件末尾。JDBC 驱动程序将执行从 UNICODE 到数据库 char 格式的任何必要转换。

<P><B>注：</B> 此流对象既可以是一个标准 Java 流对象，也可以是实现标准接口的用户自己的子类。

 @param parameterName 参数的名称
 @param reader 包含用作指定参数的 UNICODE 数据的 <code>java.io.Reader</code> 对象
 @param length 流中的字符数
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setAsciiStream(String parameterName, InputStream x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的输入流。在将一个非常大的 ASCII 值输入到 <code>LONGVARCHAR</code> 参数时，通过 <code>java.io.InputStream</code> 发送它可能更为实际。将根据需要从流中读取数据，一直读取到文件末尾。JDBC 驱动程序将执行从 ASCII 到数据库 char 格式的任何必要转换。

<P><B>注：</B> 此流对象既可以是一个标准 Java 流对象，也可以是实现标准接口的用户自己的子类。
<P><B>注：</B> 请参考 JDBC 驱动程序文档确定使用带有长度参数的 <code>setAsciiStream</code> 是否更有效。

 @param parameterName 参数的名称
 @param x 包含 ASCII 参数值的 Java 输入流
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @throws SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setBinaryStream(String parameterName, InputStream x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定输入流。在将一个非常大的二进制值输入到 <code>LONGVARBINARY</code> 参数时，通过 <code>java.io.InputStream</code> 对象发送它可能更为实际。将根据需要从流中读取数据，一直读取到文件末尾。

<P><B>注：</B> 此流对象既可以是一个标准 Java 流对象，也可以是实现标准接口的用户自己的子类。
<P><B>注：</B> 请参考 JDBC 驱动程序文档确定使用带有长度参数的 <code>setBinaryStream</code> 是否更有效。

 @param parameterName 参数的名称
 @param x 包含二进制参数值的 Java 输入流
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setCharacterStream(String parameterName, Reader reader) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定 <code>Reader</code> 对象。在将一个非常大的 UNICODE 值输入到 <code>LONGVARCHAR</code> 参数时，通过 <code>java.io.Reader</code> 对象发送它可能更为实际。将根据需要从流中读取数据，一直读取到文件末尾。JDBC 驱动程序将执行从 UNICODE 到数据库 char 格式的任何必要转换。

<P><B>注：</B> 此流对象既可以是一个标准 Java 流对象，也可以是实现标准接口的用户自己的子类。
<P><B>注：</B> 请参考 JDBC 驱动程序文档确定使用带有长度参数的 <code>setCharacterStream</code> 是否更有效。

 @param parameterName 参数的名称
 @param reader 包含 Unicode 数据的 <code>java.io.Reader</code> 对象
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法    
 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setNCharacterStream(int parameterIndex, Reader value) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>RowSet</code> 对象命令中的指定参数设置为 <code>Reader</code> 对象。<code>Reader</code> 读取数据，一直读取到文件末尾。驱动程序将执行从 Java 字符格式到数据库中国家字符集 (national character set) 的必要转换。

<P><B>注：</B> 此流对象既可以是一个标准 Java 流对象，也可以是实现标准接口的用户自己的子类。
<P><B>注：</B> 请参考 JDBC 驱动程序文档确定使用带有长度参数的 <code>setNCharacterStream</code> 是否更有效。

 @param parameterIndex 第一个参数的索引是 1，第二个参数的索引是 2 ……
 @param value 参数值
 @throws SQLException 如果驱动程序不支持国家字符集；如果驱动程序检测到可能发生数据转换错误；如果发生数据库访问错误；如果在关闭的 <code>PreparedStatement</code> 上调用此方法
 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setObject(String parameterName, Object x, int targetSqlType, int scale) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用给定对象设置指定参数的值。第二个参数必须是一个对象类型；对于整数值，应该使用 <code>java.lang</code> 的等效对象。

<p>在发送到数据库之前，给定 Java 对象将被转换为给定的 targetSqlType。

如果对象具有自定义映射关系（属于实现 <code>SQLData</code> 接口的类），则 JDBC 驱动程序应该调用 <code>SQLData.writeSQL</code> 方法将它写入 SQL 数据流中。另一方面，如果对象是实现 <code>Ref</code>、<code>Blob</code>、<code>Clob</code>、<code>NClob</code>、<code>Struct</code>、<code>java.net.URL</code> 或 <code>Array</code> 的类，则驱动程序应该将其作为相应 SQL 类型的值传递给数据库。
 <P>
注意，此方法可用于传递特定于数据库的抽象数据类型。 

 @param parameterName 参数的名称
 @param x 包含输入参数值的对象
 @param targetSqlType 将发送给数据库的 SQL 类型（在 java.sql.Types 中定义）。scale 参数可以进一步限定此类型。
 @param scale 对于 java.sql.Types.DECIMAL 或 java.sql.Types.NUMERIC 类型，该值是小数点后的位数。对于所有其他类型，将忽略此值。
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 <code>targetSqlType</code> 是 <code>ARRAY</code>、<code>BLOB</code>、<code>CLOB</code>、<code>DATALINK</code>、<code>JAVA_OBJECT</code>、<code>NCHAR</code>、<code>NCLOB</code>、<code>NVARCHAR</code>、<code>LONGNVARCHAR</code>、<code>REF</code>、<code>ROWID</code>、<code>SQLXML</code> 或 <code>STRUCT</code> 数据类型并且 JDBC 驱动程序不支持此数据类型
 @see Types
 @see #getObject
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setObject(String parameterName, Object x, int targetSqlType) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 使用给定对象设置指定参数的值。此方法类似于上面的 <code>setObject</code> 方法，不同之处在于它假定 scale 为 0。

 @param parameterName 参数的名称
 @param x 包含输入参数值的对象
 @param targetSqlType 将发送给数据库的 SQL 类型（在 java.sql.Types 中定义）
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 <code>targetSqlType</code> 是 <code>ARRAY</code>、<code>BLOB</code>、<code>CLOB</code>、<code>DATALINK</code>、<code>JAVA_OBJECT</code>、<code>NCHAR</code>、<code>NCLOB</code>、<code>NVARCHAR</code>、<code>LONGNVARCHAR</code>、<code>REF</code>、<code>ROWID</code>、<code>SQLXML</code> 或 <code>STRUCT</code> 数据类型并且 JDBC 驱动程序不支持此数据类型
 @see #getObject
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setObject(String parameterName, Object x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用给定对象设置指定参数的值。第二个参数必须是 <code>Object</code> 类型；所以，应该对内置类型使用 <code>java.lang</code> 的等效对象。

<p>JDBC 规范指定一个从 Java <code>Object</code> 类型到 SQL 类型的标准映射关系。在发送到数据库之前，给定参数将被转换为相应的 SQL 类型。

<p>注意，通过使用特定于驱动程序的 Java 类型，此方法可用于传递特定于数据库的抽象数据类型。

如果对象是实现 <code>SQLData</code> 接口的类，则 JDBC 驱动程序应该调用 <code>SQLData.writeSQL</code> 方法将它写入 SQL 数据流中。另一方面，如果对象是实现 <code>Ref</code>、<code>Blob</code>、<code>Clob</code>、<code>NClob</code>、<code>Struct</code>、<code>java.net.URL</code> 或 <code>Array</code> 的类，则驱动程序应该将其作为相应 SQL 类型的值传递给数据库。
 <P>
如果出现混淆，例如，此对象是实现多个上述指定接口的类，则此方法抛出异常。

 @param parameterName 参数的名称
 @param x 包含输入参数值的对象
 @exception SQLException 如果发生数据库访问错误，在关闭的 <code>CallableStatement</code> 上调用此方法或者给定 <code>Object</code> 参数不明确
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @see #getObject
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setBlob(int parameterIndex, InputStream inputStream, long length) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 <code>InputStream</code> 对象。inputstream 必须包含 length 所指定的字符数，否则，在执行 <code>PreparedStatement</code> 时将生成 <code>SQLException</code>。此方法不同于 <code>setBinaryStream (int, InputStream, int)</code> 方法，因为它通知驱动程序参数值应该以 <code>BLOB</code> 的形式发送到服务器。使用 <code>setBinaryStream</code> 方法时，驱动程序必须做额外的工作来确定参数数据是以 <code>LONGVARBINARY</code> 还是 <code>BLOB</code> 的形式发送到服务器。
 @param parameterIndex 第一个参数的索引是 1，第二个参数的索引是 2 ……
 @param inputStream 包含用来设置参数值的数据的对象。
 @param length 参数数据中的字节数。
 @throws SQLException 如果发生数据库访问错误；如果在关闭的 <code>PreparedStatement</code> 上调用此方法；如果 parameterIndex 不对应 SQL 语句中的参数标记；如果指定长度小于 0 或者 inputstream 中的字节数不匹配指定长度。
 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法

 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setBlob(int parameterIndex, InputStream inputStream) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 <code>InputStream</code> 对象。此方法不同于 <code>setBinaryStream (int, InputStream)</code> 方法，因为它通知驱动程序参数值应该以 <code>BLOB</code> 的形式发送到服务器。使用 <code>setBinaryStream</code> 方法时，驱动程序必须做额外的工作来确定参数数据是以 <code>LONGVARBINARY</code> 还是 <code>BLOB</code> 的形式发送到服务器。

<P><B>注：</B> 请参考 JDBC 驱动程序文档确定使用带有长度参数的 <code>setBlob</code> 是否更有效。

 @param parameterIndex 第一个参数的索引是 1，第二个参数的索引是 2 ……
 @param inputStream 包含用来设置参数值的数据的对象。
 @throws SQLException 如果发生数据库访问错误，在关闭的 <code>PreparedStatement</code> 上调用此方法或者 parameterIndex 不对应 SQL 语句中的参数标记
 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法

 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setBlob(String parameterName, InputStream inputStream, long length) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 <code>InputStream</code> 对象。 <code>inputstream</code> 必须包含 length 所指定的字符数，否则，在执行 <code>CallableStatement</code> 时将生成 <code>SQLException</code>。此方法不同于 <code>setBinaryStream (int, InputStream, int)</code> 方法，因为它通知驱动程序参数值应该以 <code>BLOB</code> 的形式发送到服务器。使用 <code>setBinaryStream</code> 方法时，驱动程序必须做额外的工作来确定参数数据是以 <code>LONGVARBINARY</code> 还是 <code>BLOB</code> 的形式发送到服务器。

 @param parameterName 要设置的参数名称

 @param inputStream 包含用来设置参数值的数据的对象。
 @param length 参数数据中的字节数。
 @throws SQLException  如果 parameterIndex 不对应 SQL 语句中的参数标记，或者指定长度小于 0；如果 inputstream 中的字节数不匹配指定长度；如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法

 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setBlob(String parameterName, Blob x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>java.sql.Blob</code> 对象。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>BLOB</code> 值。

 @param parameterName 参数的名称
 @param x 映射 SQL <code>BLOB</code> 值的 <code>Blob</code> 对象
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setBlob(String parameterName, InputStream inputStream) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 <code>InputStream</code> 对象。此方法不同于 <code>setBinaryStream (int, InputStream)</code> 方法，因为它通知驱动程序参数值应该以 <code>BLOB</code> 的形式发送到服务器。使用 <code>setBinaryStream</code> 方法时，驱动程序必须做额外的工作来确定参数数据是以 <code>LONGVARBINARY</code> 还是 <code>BLOB</code> 的形式发送到服务器。

<P><B>注：</B> 请参考 JDBC 驱动程序文档确定使用带有长度参数的 <code>setBlob</code> 是否更有效。

 @param parameterName 参数的名称
 @param inputStream 包含用来设置参数值的数据的对象。
 @throws SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法

 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setClob(int parameterIndex, Reader reader, long length) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 <code>Reader</code> 对象。reader 必须包含 length 所指定的字符数，否则，在执行 <code>PreparedStatement</code> 时将生成 <code>SQLException</code>。此方法不同于 <code>setCharacterStream (int, Reader, int)</code> 方法，因为它通知驱动程序参数值应该以 <code>CLOB</code> 的形式发送到服务器。使用 <code>setCharacterStream</code> 方法时，驱动程序必须做额外的工作来确定参数数据是以 <code>LONGVARCHAR</code> 还是 <code>CLOB</code> 的形式发送到服务器。
 @param parameterIndex 第一个参数的索引是 1，第二个参数的索引是 2 ……
 @param reader 包含用来设置参数值的数据的对象。
 @param length 参数数据中的字符数。
 @throws SQLException 如果发生数据库访问错误，或者在关闭的 <code>PreparedStatement</code> 上调用此方法；如果 parameterIndex 不对应 SQL 语句中的参数标记，或者指定长度小于 0。

 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setClob(int parameterIndex, Reader reader) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 <code>Reader</code> 对象。此方法不同于 <code>setCharacterStream (int, Reader)</code> 方法，因为它通知驱动程序参数值应该以 <code>CLOB</code> 的形式发送到服务器。使用 <code>setCharacterStream</code> 方法时，驱动程序必须做额外的工作来确定参数数据是以 <code>LONGVARCHAR</code> 还是 <code>CLOB</code> 的形式发送到服务器。

<P><B>注：</B> 请参考 JDBC 驱动程序文档确定使用带有长度参数的 <code>setClob</code> 是否更有效。

 @param parameterIndex 第一个参数的索引是 1，第二个参数的索引是 2 ……
 @param reader 包含用来设置参数值的数据的对象。
 @throws SQLException 如果发生数据库访问错误，在关闭的 <code>PreparedStatement</code> 上调用此方法或者 parameterIndex 不对应 SQL 语句中的参数标记

 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setClob(String parameterName, Reader reader, long length) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 <code>Reader</code> 对象。<code>reader</code> 必须包含 length 所指定的字符数，否则，在执行 <code>CallableStatement</code> 时将生成 <code>SQLException</code>。此方法不同于 <code>setCharacterStream (int, Reader, int)</code> 方法，因为它通知驱动程序参数值应该以 <code>CLOB</code> 的形式发送到服务器。使用 <code>setCharacterStream</code> 方法时，驱动程序必须做额外的工作来确定参数数据是以 <code>LONGVARCHAR</code> 还是 <code>CLOB</code> 的形式发送到服务器。
 @param parameterName 要设置的参数的名称
 @param reader 包含用来设置参数值的数据的对象。
 @param length 参数数据中的字符数。
 @throws SQLException 如果 parameterIndex 不对应 SQL 语句中的参数标记；如果指定长度小于 0；如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法

 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setClob(String parameterName, Clob x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>java.sql.Clob</code> 对象。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>CLOB</code> 值。

 @param parameterName 参数的名称
 @param x 映射 SQL <code>CLOB</code> 值的 <code>Clob</code> 对象
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setClob(String parameterName, Reader reader) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 <code>Reader</code> 对象。此方法不同于 <code>setCharacterStream (int, Reader)</code> 方法，因为它通知驱动程序参数值应该以 <code>CLOB</code> 的形式发送到服务器。使用 <code>setCharacterStream</code> 方法时，驱动程序必须做额外的工作来确定参数数据是以 <code>LONGVARCHAR</code> 还是 <code>CLOB</code> 的形式发送到服务器。

<P><B>注：</B> 请参考 JDBC 驱动程序文档确定使用带有长度参数的 <code>setClob</code> 是否更有效。

 @param parameterName 参数的名称
 @param reader 包含用来设置参数值的数据的对象。
 @throws SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法

 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setDate(String parameterName, Date x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用运行应用程序的虚拟机所在的默认时区将指定参数设置为给定的 <code>java.sql.Date</code> 值。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>DATE</code> 值。

 @param parameterName 参数的名称
 @param x 参数值
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @see #getDate
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setDate(String parameterName, Date x, Calendar cal) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用给定 <code>Calendar</code> 对象将指定参数设置为给定的 <code>java.sql.Date</code> 值。驱动程序使用 <code>Calendar</code> 对象构造一个 SQL <code>DATE</code> 值，该值随后被驱动程序发送到数据库。利用 <code>Calendar</code> 对象，驱动程序可以在考虑自定义时区的情况下计算日期。如果没有指定任何 <code>Calendar</code> 对象，则驱动程序使用默认时区，该时区是运行应用程序的虚拟机所在的时区。

 @param parameterName 参数的名称
 @param x 参数值
 @param cal 驱动程序将用来构造日期的 <code>Calendar</code> 对象
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @see #getDate
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setTime(String parameterName, Time x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>java.sql.Time</code> 值。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>TIME</code> 值。

 @param parameterName 参数的名称
 @param x 参数值
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @see #getTime
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setTime(String parameterName, Time x, Calendar cal) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用给定 <code>Calendar</code> 对象将指定参数设置为给定的 <code>java.sql.Time</code> 值。驱动程序使用 <code>Calendar</code> 对象构造一个 SQL <code>TIME</code> 值，该值随后被驱动程序发送到数据库。利用 <code>Calendar</code> 对象，驱动程序可以在考虑自定义时区的情况下计算时间。如果没有指定任何 <code>Calendar</code> 对象，则驱动程序使用默认时区，该时区是运行应用程序的虚拟机所在的时区。

 @param parameterName 参数的名称
 @param x 参数值
 @param cal 驱动程序将用来构造时间的 <code>Calendar</code> 对象
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @see #getTime
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setTimestamp(String parameterName, Timestamp x, Calendar cal) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
使用给定 <code>Calendar</code> 对象将指定参数设置为给定的 <code>java.sql.Timestamp</code> 值。驱动程序使用 <code>Calendar</code> 对象构造一个 SQL <code>TIMESTAMP</code> 值，该值随后被驱动程序发送到数据库。利用 <code>Calendar</code> 对象，驱动程序可以在考虑自定义时区的情况下计算时间戳。如果没有指定任何 <code>Calendar</code> 对象，则驱动程序使用默认时区，该时区是运行应用程序的虚拟机所在的时区。

 @param parameterName 参数的名称
 @param x 参数值
 @param cal 驱动程序将用来构造时间戳的 <code>Calendar</code> 对象
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @see #getTimestamp
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setSQLXML(int parameterIndex, SQLXML xmlObject) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 将指定参数设置为给定 <code>java.sql.SQLXML</code> 对象。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>XML</code> 值。
 @param parameterIndex 第一个参数的索引是 1，第二个参数的索引是 2 ……
 @param xmlObject 映射 SQL <code>XML</code> 值的 <code>SQLXML</code> 对象
 @throws SQLException 如果发生数据库访问错误，在关闭的结果集上调用此方法，没有为 <code>SQLXML</code> 对象关闭 <code>java.xml.transform.Result</code>、<code>Writer</code> 或 <code>OutputStream</code>，或者在处理 XML 值时发生错误。异常的 <code>getCause</code> 方法可以提供更详细的异常，例如，如果该流不包含有效的 XML。
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setSQLXML(String parameterName, SQLXML xmlObject) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 将指定参数设置为给定的 <code>java.sql.SQLXML</code> 对象。在将此值发送到数据库时，驱动程序将其转换为 <code>SQL XML</code> 值。 
 @param parameterName 参数的名称
 @param xmlObject 映射 <code>SQL XML</code> 值的 <code>SQLXML</code> 对象
 @throws SQLException 如果发生数据库访问错误，在关闭的结果集上调用此方法，没有为 <code>SQLXML</code> 对象关闭 <code>java.xml.transform.Result</code>、<code>Writer</code> 或 <code>OutputStream</code>，或者在处理 XML 值时发生错误。异常的 <code>getCause</code> 方法可以提供更详细的异常，例如，如果该流不包含有效的 XML。
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setRowId(int parameterIndex, RowId x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>java.sql.RowId</code> 对象。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>ROWID</code> 值。  

 @param parameterIndex 第一个参数的索引是 1，第二个参数的索引是 2 ……
 @param x 参数值
 @throws SQLException 如果发生数据库访问错误

 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setRowId(String parameterName, RowId x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 将指定参数设置为给定的 <code>java.sql.RowId</code> 对象。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>ROWID</code>。  

 @param parameterName 参数的名称
 @param x 参数值
 @throws SQLException 如果发生数据库访问错误
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setNString(int parameterIndex, String value) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>String</code> 对象。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>NCHAR</code>、<code>NVARCHAR</code> 或 <code>LONGNVARCHAR</code> 值（具体取决于该参数相对于驱动程序在 <code>NVARCHAR</code> 值上的限制的大小）。 

 @param parameterIndex 第一个参数的索引是 1，第二个参数的索引是 2 ……
 @param value 参数值
 @throws SQLException 如果驱动程序不支持国家字符集；如果驱动程序检测到可能发生数据转换错误；或者发生数据库访问错误
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setNString(String parameterName, String value) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 将指定参数设置为给定的 <code>String</code> 对象。驱动程序将此值转换为 SQL <code>NCHAR</code>、<code>NVARCHAR</code> 或 <code>LONGNVARCHAR</code>
 @param parameterName 要设置的列的名称
 @param value 参数值
 @throws SQLException 如果驱动程序不支持国家字符集；如果驱动程序检测到可能发生数据转换错误；或者发生数据库访问错误
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setNCharacterStream(int parameterIndex, Reader value, long length) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 <code>Reader</code> 对象。<code>Reader</code> 读取数据，一直读取到文件末尾。驱动程序将执行从 Java 字符格式到数据库中国家字符集的必要转换。
 @param parameterIndex 第一个参数的索引是 1，第二个参数的索引是 2 ……
 @param value 参数值
 @param length 参数数据中的字符数。
 @throws SQLException 如果驱动程序不支持国家字符集；如果驱动程序检测到可能发生数据转换错误；或者发生数据库访问错误
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setNCharacterStream(String parameterName, Reader value, long length) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 <code>Reader</code> 对象。<code>Reader</code> 读取数据，一直读取到文件末尾。驱动程序将执行从 Java 字符格式到数据库中国家字符集的必要转换。
 @param parameterName 要设置的列的名称
 @param value 参数值
 @param length 参数数据中的字符数。
 @throws SQLException 如果驱动程序不支持国家字符集；如果驱动程序检测到可能发生数据转换错误；或者发生数据库访问错误
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setNCharacterStream(String parameterName, Reader value) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 <code>Reader</code> 对象。<code>Reader</code> 读取数据，一直读取到文件末尾。驱动程序将执行从 Java 字符格式到数据库中国家字符集的必要转换。

<P><B>注：</B> 此流对象既可以是一个标准 Java 流对象，也可以是实现标准接口的用户自己的子类。
<P><B>注：</B> 请参考 JDBC 驱动程序文档确定使用带有长度参数的 <code>setNCharacterStream</code> 是否更有效。

 @param parameterName 参数的名称
 @param value 参数值 
 @throws SQLException 如果驱动程序不支持国家字符集；如果驱动程序检测到可能发生数据转换错误；如果发生数据库访问错误；或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setNClob(String parameterName, NClob value) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 将指定参数设置为 <code>java.sql.NClob</code> 对象。该对象实现 <code>java.sql.NClob</code> 接口。此 <code>NClob</code> 对象映射到 SQL <code>NCLOB</code>。
 @param parameterName 要设置的列的名称
 @param value 参数值 
 @throws SQLException 如果驱动程序不支持国家字符集；如果驱动程序检测到可能发生数据转换错误；或者发生数据库访问错误
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setNClob(String parameterName, Reader reader, long length) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 <code>Reader</code> 对象。<code>reader</code> 必须包含 length 所指定的字符数，否则，在执行 <code>CallableStatement</code> 时将生成 <code>SQLException</code>。此方法不同于 <code>setCharacterStream (int, Reader, int)</code> 方法，因为它通知驱动程序参数值应该以 <code>NCLOB</code> 的形式发送到服务器。使用 <code>setCharacterStream</code> 方法时，驱动程序必须做额外的工作来确定参数数据是以 <code>LONGNVARCHAR</code> 还是 <code>NCLOB</code> 的形式发送到服务器。

 @param parameterName 要设置的参数的名称
 @param reader 包含用来设置参数值的数据的对象。
 @param length 参数数据中的字符数。
 @throws SQLException 如果 parameterIndex 不对应 SQL 语句中的参数标记；如果指定长度小于 0；如果驱动程序不支持国家字符集；如果驱动程序检测到可能发生数据转换错误；如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @exception SQLFeatureNotSupportedException 如果 JDBC 驱动程序不支持此方法
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setNClob(String parameterName, Reader reader) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 <code>Reader</code> 对象。此方法不同于 <code>setCharacterStream (int, Reader)</code> 方法，因为它通知驱动程序参数值应该以 <code>NCLOB</code> 的形式发送到服务器。使用 <code>setCharacterStream</code> 方法时，驱动程序必须做额外的工作来确定参数数据是以 <code>LONGNVARCHAR</code> 还是 <code>NCLOB</code> 的形式发送到服务器。
<P><B>注：</B> 请参考 JDBC 驱动程序文档确定使用带有长度参数的 <code>setNClob</code> 是否更有效。

 @param parameterName 参数的名称
 @param reader 包含用来设置参数值的数据的对象。
 @throws SQLException 如果驱动程序不支持国家字符集；如果驱动程序检测到可能发生数据转换错误；如果发生数据库访问错误或者在关闭的 <code>CallableStatement</code> 上调用此方法
 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法

 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setNClob(int parameterIndex, Reader reader, long length) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 <code>Reader</code> 对象。reader 必须包含 length 所指定的字符数，否则，在执行 <code>PreparedStatement</code> 时将会生成 <code>SQLException</code>。此方法不同于 <code>setCharacterStream (int, Reader, int)</code> 方法，因为它通知驱动程序参数值应该以 <code>NCLOB</code> 的形式发送到服务器。使用 <code>setCharacterStream</code> 方法时，驱动程序必须做额外的工作来确定参数数据是以 <code>LONGNVARCHAR</code> 还是 <code>NCLOB</code> 的形式发送到服务器。
 @param parameterIndex 第一个参数的索引是 1，第二个参数的索引是 2 ……
 @param reader 包含用来设置参数值的数据的对象。
 @param length 参数数据中的字符数。
 @throws SQLException 如果 parameterIndex 不对应 SQL 语句中的参数标记；如果指定长度小于 0；如果驱动程序不支持国家字符集；如果驱动程序检测到可能发生数据转换错误；如果发生数据库访问错误或者在关闭的 <code>PreparedStatement</code> 上调用此方法
 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法

 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setNClob(int parameterIndex, NClob value) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
 将指定参数设置为 <code>java.sql.NClob</code> 对象。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>NCLOB</code> 值。
 @param parameterIndex 第一个参数的索引是 1，第二个参数的索引是 2 ……
 @param value 参数值
 @throws SQLException 如果驱动程序不支持国家字符集；如果驱动程序检测到可能发生数据转换错误；或者发生数据库访问错误
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setNClob(int parameterIndex, Reader reader) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为 <code>Reader</code> 对象。此方法不同于 <code>setCharacterStream (int, Reader)</code> 方法，因为它通知驱动程序参数值应该以 <code>NCLOB</code> 的形式发送到服务器。使用 <code>setCharacterStream</code> 方法时，驱动程序必须做额外的工作来确定参数数据是以 <code>LONGNVARCHAR</code> 还是 <code>NCLOB</code> 的形式发送到服务器
<P><B>注：</B> 请参考 JDBC 驱动程序文档确定使用带有长度参数的 <code>setNClob</code> 是否更有效。

 @param parameterIndex 第一个参数的索引是 1，第二个参数的索引是 2 ……
 @param reader 包含用来设置参数值的数据的对象。
 @throws SQLException 如果 parameterIndex 不对应 SQL 语句中的参数标记；如果驱动程序不支持国家字符集；如果驱动程序检测到可能发生数据转换错误；如果发生数据库访问错误或者在关闭的 <code>PreparedStatement</code> 上调用此方法
 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法

 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.sql.rowset.BaseRowSet.setURL(int parameterIndex, URL x) throws java.sql.SQLException
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定参数设置为给定的 <code>java.net.URL</code> 值。在将此值发送到数据库时，驱动程序将其转换为 SQL <code>DATALINK</code> 值。

 @param parameterIndex 第一个参数的索引是 1，第二个参数的索引是 2 ……
 @param x 要设置的 <code>java.net.URL</code> 对象
 @exception SQLException 如果发生数据库访问错误或者在关闭的 <code>PreparedStatement</code> 上调用此方法
 @throws SQLFeatureNotSupportedException  如果 JDBC 驱动程序不支持此方法
 @since 1.4

<!-- END DATA -->
