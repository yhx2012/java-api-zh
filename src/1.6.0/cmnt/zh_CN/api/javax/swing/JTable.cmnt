<!-- BEGIN KEY -->
public class javax.swing.JTable extends javax.swing.JComponent implements javax.swing.event.TableModelListener, javax.swing.Scrollable, javax.swing.event.TableColumnModelListener, javax.swing.event.ListSelectionListener, javax.swing.event.CellEditorListener, javax.accessibility.Accessible, javax.swing.event.RowSorterListener
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>JTable</code> 用来显示和编辑常规二维单元表。有关面向任务的文档和使用 <code>JTable</code> 的示例，请参阅 <em>The Java Tutorial</em> 中的 <a href="http://java.sun.com/docs/books/tutorial/uiswing/components/table.html">How to Use Tables</a> 一节。

 <p>
<code>JTable</code> 有很多用来自定义其呈现和编辑的工具，同时提供了这些功能的默认设置，从而可以轻松地设置简单表。例如，要设置一个 10 行 10 列的表：
 <p>
 <pre>
      TableModel dataModel = new AbstractTableModel() {
          public int getColumnCount() { return 10; }
          public int getRowCount() { return 10;}
          public Object getValueAt(int row, int col) { return new Integer(row*col); }
      };
      JTable table = new JTable(dataModel);
      JScrollPane scrollpane = new JScrollPane(table);
 </pre>
 <p>
注意，如果要在单独的视图中（在 <code>JScrollPane</code> 外）使用 <code>JTable</code> 并显示表标题，则可以使用 {@link #getTableHeader} 获取并单独显示它。
 <p>
 要启用行的排序和过滤，请使用 {@code RowSorter}。可以通过以下两种方式之一设置一个行排序器。
 <ul>
   <li>直接设置 {@code RowSorter}。例如：{@code table.setRowSorter(new TableRowSorter(model))}。
   <li>将 {@code autoCreateRowSorter} 属性设置为 {@code true}，从而 {@code JTable} 可用于创建 {@code RowSorter}。例如：{@code setAutoCreateRowSorter(true)}。
 </ul>
 <p>
设计使用 <code>JTable</code> 的应用程序时，务必要注意用来表示表数据的数据结构。<code>DefaultTableModel</code> 是一个模型实现，它使用一个 <code>Vector</code> 来存储所有单元格的值，该 <code>Vector</code> 由包含多个 <code>Object</code> 的 <code>Vector</code> 组成。除了将数据从应用程序复制到 <code>DefaultTableModel</code> 中之外，还可以用 <code>TableModel</code> 接口的方法来包装数据，这样可将数据直接传递到 <code>JTable</code>，如上例所示。这通常可以提高应用程序的效率，因为模型可以自由选择最适合数据的内部表示形式。在决定使用 <code>AbstractTableModel</code> 还是使用 <code>DefaultTableModel</code> 方面有一个好的实践经验，即在创建子类时使用 <code>AbstractTableModel</code> 作为基类，在不需要创建子类时则使用 <code>DefaultTableModel</code>。
 <p>
源分布演示部分中的 &quot;TableExample&quot; 目录给出了许多 <code>JTable</code> 用法的完整示例，包括如何使用 <code>JTable</code> 来提供一个可编辑的数据视图（数据取自数据库），以及如何修改显示的列以使用指定的渲染器和编辑器。
 <p>
<code>JTable</code> 使用专有的整数来引用它所显示的模型的行和列。<code>JTable</code> 采用表格的单元格范围，并在绘制时使用 <code>getValueAt(int, int)</code> 从模型中获取值。务必记住各种 <code>JTable</code> 方法所返回的列和行索引是就 <code>JTable</code>（视图）而言的，不一定是模型所使用的那些索引。 
 <p>
默认情况下，在 <code>JTable</code> 中对列进行重新安排，这样在视图中列的出现顺序与模型中列的顺序不同。但这根本不影响模型的实现：当列重新排列时，<code>JTable</code> 在内部保持列的新顺序，并在查询模型前转换其列索引。
 <p>
因此编写 <code>TableModel</code> 时，不必侦听列的重排事件，因为不管视图怎样，模型都将在其自己的坐标系统被查询。在示例部分中有一个排序算法的演示，此演示正是使用了此技术在另一个坐标系统中进行排序，其中更改了行顺序，没有更改列顺序。
 <p>
类似地，使用 <code>RowSorter</code> 提供的排序和过滤功能时，底层 <code>TableModel</code> 不需要知道怎样进行排序，<code>RowSorter</code> 将处理它。对底层 <code>TableModel</code> 使用 <code>JTable</code> 的基于行的方法时，必须进行坐标转换。所有基于 <code>JTable</code> 行的方法都是就 <code>RowSorter</code> 而言的，不一定与底层 <code>TableModel</code> 的方法相同。例如，选择始终是就 <code>JTable</code> 而言的，因此使用 <code>RowSorter</code> 时，需要使用 <code>convertRowIndexToView</code> 或 <code>convertRowIndexToModel</code> 进行转换。以下代码显示了如何将 <code>JTable</code> 的坐标转换为底层模型的坐标： 
 <pre>
   int[] selection = table.getSelectedRows();
   for (int i = 0; i &lt; selection.length; i++) {
     selection[i] = table.convertRowIndexToModel(selection[i]);
   }
   // selection is now in terms of the underlying TableModel
 </pre>
 <p>
默认情况下，如果启用排序，那么排序时 <code>JTable</code> 将保留基于模型的选择和可变行高度。例如，如果当前选择行 0（就底层模型而言），那么排序之后将选择行 0（就底层模型而言）。选择有可能看起来被更改了，但就底层模型而言它仍然保持不变。模型索引不再可见或者被移除时除外。例如，如果行 0 被过滤掉了，那么选择在排序后将为空。
 <p>
J2SE 5 在 <code>JTable</code> 中添加了一些方法，为某些普通打印需求提供方便的访问。{@link #print()} 是一个简单的新方法，它允许快速简单地向应用程序添加打印支持。此外，新的 {@link #getPrintable} 方法可用于更高级的打印需求。
 <p>
对于所有的 <code>JComponent</code> 类，可以使用 {@link InputMap} 和 {@link ActionMap} 将 {@link Action} 对象与 {@link KeyStroke} 进行关联，并在指定的条件下执行动作。
 <p>
<strong>警告：</strong>Swing 不是线程安全的。有关更多信息，请参阅 <a
 href="package-summary.html#threading">Swing's Threading
 Policy</a>。
 <p>
<strong>警告：</strong>此类的序列化对象与以后的 Swing 版本不兼容。当前序列化支持适用于短期存储，或适用于在运行相同 Swing 版本的应用程序之间进行 RMI（Remote Method Invocation，远程方法调用）。从 1.4 版本开始，已在 <code>java.beans</code> 包中添加了支持所有 JavaBeans<sup><font size="-2">TM</font></sup> 长期存储的功能。请参见 {@link java.beans.XMLEncoder}。

@beaninfo attribute: isContainer false description: A component which displays data in a two dimensional grid.

@version 1.238 06/28/04
@author Philip Milne
@author Shannon Hickey (printing support)
@see javax.swing.table.DefaultTableModel
@see javax.swing.table.TableRowSorter

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int javax.swing.JTable.AUTO_RESIZE_OFF
<!-- END KEY -->
<!-- BEGIN DATA -->
不自动调整列的宽度；使用滚动条。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int javax.swing.JTable.AUTO_RESIZE_NEXT_COLUMN
<!-- END KEY -->
<!-- BEGIN DATA -->
在 UI 中调整了一个列时，对其下一列进行相反方向的调整。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int javax.swing.JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS
<!-- END KEY -->
<!-- BEGIN DATA -->
在 UI 调整中，更改后续列以保持总宽度不变；此为默认行为。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int javax.swing.JTable.AUTO_RESIZE_LAST_COLUMN
<!-- END KEY -->
<!-- BEGIN DATA -->
在所有的调整大小操作中，只对最后一列进行调整。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int javax.swing.JTable.AUTO_RESIZE_ALL_COLUMNS
<!-- END KEY -->
<!-- BEGIN DATA -->
在所有的调整大小操作中，按比例调整所有的列。
<!-- END DATA -->
<!-- BEGIN KEY -->
protected javax.swing.table.TableModel javax.swing.JTable.dataModel
<!-- END KEY -->
<!-- BEGIN DATA -->
表的 <code>TableModel</code>。
<!-- END DATA -->
<!-- BEGIN KEY -->
protected javax.swing.table.TableColumnModel javax.swing.JTable.columnModel
<!-- END KEY -->
<!-- BEGIN DATA -->
表的 <code>TableColumnModel</code>。
<!-- END DATA -->
<!-- BEGIN KEY -->
protected javax.swing.ListSelectionModel javax.swing.JTable.selectionModel
<!-- END KEY -->
<!-- BEGIN DATA -->
表的 <code>ListSelectionModel</code>，用来追踪行选择。
<!-- END DATA -->
<!-- BEGIN KEY -->
protected javax.swing.table.JTableHeader javax.swing.JTable.tableHeader
<!-- END KEY -->
<!-- BEGIN DATA -->
表所使用的 <code>TableHeader</code>。
<!-- END DATA -->
<!-- BEGIN KEY -->
protected int javax.swing.JTable.rowHeight
<!-- END KEY -->
<!-- BEGIN DATA -->
表中每一行的高度，以像素为单位。
<!-- END DATA -->
<!-- BEGIN KEY -->
protected int javax.swing.JTable.rowMargin
<!-- END KEY -->
<!-- BEGIN DATA -->
每行中单元格之间间距的高度，以像素为单位。
<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.awt.Color javax.swing.JTable.gridColor
<!-- END KEY -->
<!-- BEGIN DATA -->
网格的颜色。
<!-- END DATA -->
<!-- BEGIN KEY -->
protected boolean javax.swing.JTable.showHorizontalLines
<!-- END KEY -->
<!-- BEGIN DATA -->
如果 <code>showHorizontalLines</code> 为 true，则表在单元格之间绘制水平行。
<!-- END DATA -->
<!-- BEGIN KEY -->
protected boolean javax.swing.JTable.showVerticalLines
<!-- END KEY -->
<!-- BEGIN DATA -->
如果 <code>showVerticalLines</code> 为 true，则表在单元格之间绘制垂直行。
<!-- END DATA -->
<!-- BEGIN KEY -->
protected int javax.swing.JTable.autoResizeMode
<!-- END KEY -->
<!-- BEGIN DATA -->
确定表是否自动调整列的宽度以占用表的整个宽度，以及如何进行调整。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected boolean javax.swing.JTable.autoCreateColumnsFromModel
<!-- END KEY -->
<!-- BEGIN DATA -->
如果为 true，则表对 <code>TableModel</code> 进行查询以构建默认列集。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.awt.Dimension javax.swing.JTable.preferredViewportSize
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>Scrollable</code> 接口使用它来确定初始的可见区域。
<!-- END DATA -->
<!-- BEGIN KEY -->
protected boolean javax.swing.JTable.rowSelectionAllowed
<!-- END KEY -->
<!-- BEGIN DATA -->
如果行选择在此表中是允许的，则返回 true。
<!-- END DATA -->
<!-- BEGIN KEY -->
protected boolean javax.swing.JTable.cellSelectionEnabled
<!-- END KEY -->
<!-- BEGIN DATA -->
从 Java 2 平台 v1.3 开始已过时。请使用 <code>rowSelectionAllowed</code> 属性和 <code>columnModel</code> 的 <code>columnSelectionAllowed</code> 属性，或者使用方法 <code>getCellSelectionEnabled</code>。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected transient java.awt.Component javax.swing.JTable.editorComp
<!-- END KEY -->
<!-- BEGIN DATA -->
在编辑时处理编辑的 <code>Component</code>。
<!-- END DATA -->
<!-- BEGIN KEY -->
protected transient javax.swing.table.TableCellEditor javax.swing.JTable.cellEditor
<!-- END KEY -->
<!-- BEGIN DATA -->
活动单元格编辑器对象，它重写当前单元格占用的屏幕空间，并允许用户更改其内容。如果当前没有编辑该表，则为 {@code null}。 

<!-- END DATA -->
<!-- BEGIN KEY -->
protected transient int javax.swing.JTable.editingColumn
<!-- END KEY -->
<!-- BEGIN DATA -->
标识所编辑的单元格的列。
<!-- END DATA -->
<!-- BEGIN KEY -->
protected transient int javax.swing.JTable.editingRow
<!-- END KEY -->
<!-- BEGIN DATA -->
标识所编辑的单元格的行。
<!-- END DATA -->
<!-- BEGIN KEY -->
protected transient java.util.Hashtable javax.swing.JTable.defaultRenderersByColumnClass
<!-- END KEY -->
<!-- BEGIN DATA -->
一个由对象组成的表，它显示单元格的内容，通过在 <code>TableModel</code> 接口的 <code>getColumnClass</code> 中所声明的类建立索引。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected transient java.util.Hashtable javax.swing.JTable.defaultEditorsByColumnClass
<!-- END KEY -->
<!-- BEGIN DATA -->
一个由对象组成的表，它显示并编辑单元格的内容，通过在 <code>TableModel</code> 接口的 <code>getColumnClass</code> 中所声明的类建立索引。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.awt.Color javax.swing.JTable.selectionForeground
<!-- END KEY -->
<!-- BEGIN DATA -->
已选定单元格的前景色。
<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.awt.Color javax.swing.JTable.selectionBackground
<!-- END KEY -->
<!-- BEGIN DATA -->
已选定单元格的背景色。
<!-- END DATA -->
<!-- BEGIN KEY -->
private boolean javax.swing.JTable.columnSelectionAdjusting
<!-- END KEY -->
<!-- BEGIN DATA -->
来自列选择模型 columnSelectionChanged 通知的 getValueIsAdjusting 的最后一个值。用来测试是否需要重新绘制。

<!-- END DATA -->
<!-- BEGIN KEY -->
private boolean javax.swing.JTable.rowSelectionAdjusting
<!-- END KEY -->
<!-- BEGIN DATA -->
来自行选择模型 valueChanged 通知的 getValueIsAdjusting 的最后一个值。用来测试是否需要重新绘制。

<!-- END DATA -->
<!-- BEGIN KEY -->
private java.lang.Throwable javax.swing.JTable.printError
<!-- END KEY -->
<!-- BEGIN DATA -->
打印期间在线程之间传递错误。

<!-- END DATA -->
<!-- BEGIN KEY -->
private boolean javax.swing.JTable.isRowHeightSet
<!-- END KEY -->
<!-- BEGIN DATA -->
已调用 setRowHeight(int) 时为 true。

<!-- END DATA -->
<!-- BEGIN KEY -->
private boolean javax.swing.JTable.updateSelectionOnSort
<!-- END KEY -->
<!-- BEGIN DATA -->
 如果为 true，则在排序中将重置该选择。

<!-- END DATA -->
<!-- BEGIN KEY -->
private boolean javax.swing.JTable.ignoreSortChange
<!-- END KEY -->
<!-- BEGIN DATA -->
 如果为 true，则调用 sorterChanged 时忽略其值。

<!-- END DATA -->
<!-- BEGIN KEY -->
private boolean javax.swing.JTable.sorterChanged
<!-- END KEY -->
<!-- BEGIN DATA -->
 是否已调用了 sorterChanged。

<!-- END DATA -->
<!-- BEGIN KEY -->
private boolean javax.swing.JTable.autoCreateRowSorter
<!-- END KEY -->
<!-- BEGIN DATA -->
 如果为 true，则任何时间该模型更改时都将设置一个新 RowSorter。

<!-- END DATA -->
<!-- BEGIN KEY -->
private boolean javax.swing.JTable.fillsViewportHeight
<!-- END KEY -->
<!-- BEGIN DATA -->
 该表是否始终充满视口的高度。
 @see #setFillsViewportHeight
 @see #getScrollableTracksViewportHeight

<!-- END DATA -->
<!-- BEGIN KEY -->
private javax.swing.DropMode javax.swing.JTable.dropMode
<!-- END KEY -->
<!-- BEGIN DATA -->
 此组件的放置模式。

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.JTable()
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个默认的 <code>JTable</code>，使用默认的数据模型、默认的列模型和默认的选择模型对其进行初始化。

@see #createDefaultDataModel
@see #createDefaultColumnModel
@see #createDefaultSelectionModel

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.JTable(TableModel dm)
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个 <code>JTable</code>，使用数据模型 <code>dm</code>、默认的列模型和默认的选择模型对其进行初始化。

@param dm  表的数据模型
@see #createDefaultColumnModel
@see #createDefaultSelectionModel

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.JTable(TableModel dm, TableColumnModel cm)
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个 <code>JTable</code>，使用数据模型 <code>dm</code>、列模型 <code>cm</code> 和默认的选择模型对其进行初始化。

@param dm 表的数据模型
@param cm 表的列模型
@see #createDefaultSelectionModel

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.JTable(TableModel dm, TableColumnModel cm, ListSelectionModel sm)
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个 <code>JTable</code>，使用数据模型 <code>dm</code>、列模型 <code>cm</code> 和选择模型 <code>sm</code> 对其进行初始化。如果任何参数为 <code>null</code>，则此方法将使用相应的默认模型初始化表。如果 <code>cm</code> 为非 null，则 <code>autoCreateColumnsFromModel</code> 标志被设置为 false，否则设置为 true，并使用 <code>dm</code> 中各列的合适 <code>TableColumn</code> 来填充列模型。

@param dm 表的数据模型
@param cm 表的列模型
@param sm 表的行选择模型
@see #createDefaultDataModel
@see #createDefaultColumnModel
@see #createDefaultSelectionModel

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.JTable(int numRows, int numColumns)
<!-- END KEY -->
<!-- BEGIN DATA -->
使用 <code>DefaultTableModel</code> 构造具有 <code>numRows</code> 行和 <code>numColumns</code> 列个空单元格的 <code>JTable</code>。列名称采用 &quot;A&quot;、&quot;B&quot;、&quot;C&quot; 等形式。

@param numRows  表所拥有的行数
@param numColumns 表所拥有的列数
@see javax.swing.table.DefaultTableModel

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.JTable(java.util.Vector rowData, java.util.Vector columnNames)
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个 <code>JTable</code> 来显示 <code>Vector</code> 所组成的 <code>Vector</code> <code>rowData</code> 中的值，其列名称为 <code>columnNames</code>。<code>rowData</code> 中包含的 <code>Vector</code> 应该包含该行的值。换句话说，可以通过以下代码获取第 1 行，第 5 列单元格的值：
 <p>
 <pre>((Vector)rowData.elementAt(1)).elementAt(5);</pre>
 <p>
@param rowData 新表的数据
@param columnNames  每列的名称

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.JTable(java.lang.Object[][] rowData, java.lang.Object[] columnNames)
<!-- END KEY -->
<!-- BEGIN DATA -->
构造一个 <code>JTable</code> 来显示二维数组 <code>rowData</code> 中的值，其列名称为 <code>columnNames</code>。<code>rowData</code> 是一个行数组，因此可以通过以下代码获取第 1 行，第 5 列单元格的值：
 <p>
 <pre> rowData[1][5]; </pre>
 <p>
所有行的长度必须与 <code>columnNames</code> 的长度相同。
 <p>
@param rowData 新表的数据
@param columnNames  每列的名称

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.addNotify()
<!-- END KEY -->
<!-- BEGIN DATA -->
调用 <code>configureEnclosingScrollPane</code> 方法。

@see #configureEnclosingScrollPane

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void javax.swing.JTable.configureEnclosingScrollPane()
<!-- END KEY -->
<!-- BEGIN DATA -->
如果此 <code>JTable</code> 是一个封闭 <code>JScrollPane</code> 的 <code>viewportView</code>（通常情况如此），那么可通过安装表的 <code>tableHeader</code> 作为滚动窗格的 <code>columnHeaderView</code> 来配置此 <code>ScrollPane</code>。以正常方式向 <code>JScrollPane</code> 添加 <code>JTable</code> 时，请使用 <code>new JScrollPane(myTable)</code>，<code>addNotify</code> 是在 <code>JTable</code> 中调用的（表被添加到视口中时）。<code>JTable</code> 的 <code>addNotify</code> 方法将调用此方法，此方法是受保护的，以便子类可以重写此默认的安装过程。

@see #addNotify

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.removeNotify()
<!-- END KEY -->
<!-- BEGIN DATA -->
调用 <code>unconfigureEnclosingScrollPane</code> 方法。

@see #unconfigureEnclosingScrollPane

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void javax.swing.JTable.unconfigureEnclosingScrollPane()
<!-- END KEY -->
<!-- BEGIN DATA -->
通过将封闭滚动窗格的 <code>columnHeaderView</code> 替换为 <code>null</code>，可以起到 <code>configureEnclosingScrollPane</code> 的相反作用。<code>JTable</code> 的 <code>removeNotify</code> 方法调用此方法，此方法是受保护的，以便子类可以重写此默认的卸载过程。

@see #removeNotify
@see #configureEnclosingScrollPane
@since 1.3

<!-- END DATA -->
<!-- BEGIN KEY -->
public static javax.swing.JScrollPane javax.swing.JTable.createScrollPaneForTable(JTable aTable)
<!-- END KEY -->
<!-- BEGIN DATA -->
等效于 <code>new JScrollPane(aTable)</code>。

@deprecated 从 Swing version 1.0.2 开始，由 <code>new JScrollPane(aTable)</code> 取代。

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setTableHeader(JTableHeader tableHeader)
<!-- END KEY -->
<!-- BEGIN DATA -->
将此 <code>JTable</code> 所使用的 <code>tableHeader</code> 设置为 <code>newHeader</code>。<code>tableHeader</code> 为 <code>null</code> 是合法的。

@param tableHeader 新的 tableHeader
@see     #getTableHeader
@beaninfo bound:true description: The JTableHeader instance which renders the column headers.

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.table.JTableHeader javax.swing.JTable.getTableHeader()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>JTable</code> 所使用的 <code>tableHeader</code>。

@return  此表所使用的 <code>tableHeader</code>
@see     #setTableHeader

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setRowHeight(int rowHeight)
<!-- END KEY -->
<!-- BEGIN DATA -->
将所有单元格的高度设置为 <code>rowHeight</code>（以像素为单位），重新验证并重新绘制它。单元格的高度等于行高减去行间距。

@param   rowHeight  新的行高
@exception IllegalArgumentException  如果 <code>rowHeight</code> 小于 1
@see     #getRowHeight
@beaninfo bound:true description:The height of the specified row.

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.getRowHeight()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回表的行高，以像素为单位。默认的行高为 16.0。

@return  表的行高，以像素为单位
@see     #setRowHeight

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setRowHeight(int row, int rowHeight)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <code>row</code> 的高度设置为 <code>rowHeight</code>，重新验证并重新绘制它。此行中单元格的高度等于行高减去行间距。

@param   row  更改高度的行
@param   rowHeight 新的行高，以像素为单位
@exception IllegalArgumentException 如果 <code>rowHeight</code> 小于 1
@beaninfo bound: true description: The height in pixels of the cells in <code>row</code>
@since 1.3

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.getRowHeight(int row)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>row</code> 中单元格的高度，以像素为单位。
@param   row  要返回其高度的行
@return 行中单元格的高度，以像素为单位
@since 1.3

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setRowMargin(int rowMargin)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置相临行中单元格之间的间距。

@param  rowMargin  一行中单元格之间的像素数
@see     #getRowMargin
@beaninfo bound: true description: The amount of space between cells.

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.getRowMargin()
<!-- END KEY -->
<!-- BEGIN DATA -->
获取单元格之间的间距，以像素为单位。等效于：<code>getIntercellSpacing().height</code>。
@return 一行中单元格之间的像素数

@see     #setRowMargin

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setIntercellSpacing(Dimension intercellSpacing)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <code>rowMargin</code> 和 <code>columnMargin</code>（单元格之间间距的高度和宽度）设置为 <code>intercellSpacing</code>。

@param   intercellSpacing  指定单元格之间新高度和宽度的 <code>Dimension</code>
@see     #getIntercellSpacing
@beaninfo description: The spacing between the cells, drawn in the background color of the JTable.

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Dimension javax.swing.JTable.getIntercellSpacing()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回单元格之间的水平间距和垂直间距。默认的间距为 (1, 1)，它为绘制网格提供了空间。

@return  单元格之间的水平间距和垂直间距
@see     #setIntercellSpacing

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setGridColor(Color gridColor)
<!-- END KEY -->
<!-- BEGIN DATA -->
将用来绘制网格线的颜色设置为 <code>gridColor</code> 并重新显示它。默认的颜色取决于外观。

@param   gridColor  网格线的新颜色
@exception IllegalArgumentException 如果 <code>gridColor</code> 为 <code>null</code>
@see     #getGridColor
@beaninfo bound:true description:The grid color.

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Color javax.swing.JTable.getGridColor()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回用来绘制网格线的颜色。默认的颜色取决于外观。

@return 用来绘制网格线的颜色
@see     #setGridColor

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setShowGrid(boolean showGrid)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置表是否绘制单元格周围的网格线。如果 <code>showGrid</code> 为 true，则绘制网格线；如果为 false，则不绘制。没有 <code>getShowGrid</code> 方法，因为此状态保存在两个变量中，即 <code>showHorizontalLines</code> 和 <code>showVerticalLines</code>，可以对其中任何一个变量单独进行查询。

@param   showGrid 如果表视图应该绘制网格线，则为 true

@see     #setShowVerticalLines
@see     #setShowHorizontalLines
@beaninfo description: The color used to draw the grid lines.

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setShowHorizontalLines(boolean showHorizontalLines)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置表是否绘制单元格之间的水平线。如果 <code>showHorizontalLines</code> 为 true，则绘制水平线；如果为 false，则不绘制。

@param   showHorizontalLines 如果表视图应该绘制水平线，则为 true
@see     #getShowHorizontalLines
@see     #setShowGrid
@see     #setShowVerticalLines
@beaninfo bound:true description: Whether horizontal lines should be drawn in between the cells.

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setShowVerticalLines(boolean showVerticalLines)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置表是否绘制单元格之间的垂直线。如果 <code>showVerticalLines</code> 为 true，则绘制垂直线；如果为 false，则不绘制。

@param   showVerticalLines  如果表视图应该绘制垂直线，则为 true
@see     #getShowVerticalLines
@see     #setShowGrid
@see     #setShowHorizontalLines
@beaninfo bound:true description: Whether vertical lines should be drawn in between the cells.

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.getShowHorizontalLines()
<!-- END KEY -->
<!-- BEGIN DATA -->
如果表绘制单元格之间的水平线，则返回 true，否则返回 false。默认值为 true。

@return  如果表绘制单元格之间的水平线，则返回 true；否则返回 false
@see     #setShowHorizontalLines

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.getShowVerticalLines()
<!-- END KEY -->
<!-- BEGIN DATA -->
如果表绘制单元格之间的垂直线，则返回 true，否则返回 false。默认值为 true。

@return  如果表绘制单元格之间的垂直线，则返回 true；否则返回 false
@see     #setShowVerticalLines

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setAutoResizeMode(int mode)
<!-- END KEY -->
<!-- BEGIN DATA -->
当调整表的大小时，设置表的自动调整模式。

@param   mode 5 个合法值之一：AUTO_RESIZE_OFF、AUTO_RESIZE_NEXT_COLUMN、AUTO_RESIZE_SUBSEQUENT_COLUMNS、AUTO_RESIZE_LAST_COLUMN、AUTO_RESIZE_ALL_COLUMNS

@see     #getAutoResizeMode
@see     #doLayout
@beaninfo bound:true description: Whether the columns should adjust themselves automatically. enum: AUTO_RESIZE_OFF                JTable.AUTO_RESIZE_OFF AUTO_RESIZE_NEXT_COLUMN        JTable.AUTO_RESIZE_NEXT_COLUMN AUTO_RESIZE_SUBSEQUENT_COLUMNS JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS AUTO_RESIZE_LAST_COLUMN        JTable.AUTO_RESIZE_LAST_COLUMN AUTO_RESIZE_ALL_COLUMNS        JTable.AUTO_RESIZE_ALL_COLUMNS

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.getAutoResizeMode()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回表的自动调整模式。默认的模式为 AUTO_RESIZE_SUBSEQUENT_COLUMNS。

@return  表的 autoResizeMode

@see     #setAutoResizeMode
@see     #doLayout

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setAutoCreateColumnsFromModel(boolean autoCreateColumnsFromModel)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置此表的 <code>autoCreateColumnsFromModel</code> 标志。如果 <code>autoCreateColumnsFromModel</code> 由 false 更改为 true，则此方法调用 <code>createDefaultColumnsFromModel</code>。

@param   autoCreateColumnsFromModel   如果 <code>JTable</code> 应该自动创建列，则为 true
@see     #getAutoCreateColumnsFromModel
@see     #createDefaultColumnsFromModel
@beaninfo bound: true description: Automatically populates the columnModel when a new TableModel is submitted.

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.getAutoCreateColumnsFromModel()
<!-- END KEY -->
<!-- BEGIN DATA -->
确定表是否要根据模型创建默认的列。如果为 true，则 <code>setModel</code> 将清除所有现有列并根据新模型创建新的列。同样，如果 <code>tableChanged</code> 通知中的事件指定整个表已更改，则将重新构建各列。默认值为 true。

@return  表的 autoCreateColumnsFromModel
@see     #setAutoCreateColumnsFromModel
@see     #createDefaultColumnsFromModel

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.createDefaultColumnsFromModel()
<!-- END KEY -->
<!-- BEGIN DATA -->
使用 <code>TableModel</code> 接口中定义的 <code>getColumnCount</code> 方法根据数据模型创建默认的表列。
 <p>
在根据模型的信息创建新的列之前，清除所有现有列。

@see     #getAutoCreateColumnsFromModel

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setDefaultRenderer(java.lang.Class<?> columnClass, TableCellRenderer renderer)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果没有在 <code>TableColumn</code> 中设置渲染器，则设置要使用的默认单元格渲染器。如果 renderer 为 <code>null</code>，则移除此 columnClass 的默认渲染器。

@param  columnClass   设置此 columnClass 的默认单元格渲染器
@param  renderer  此 columnClass 要使用的默认单元格渲染器
@see     #getDefaultRenderer
@see     #setDefaultEditor

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.table.TableCellRenderer javax.swing.JTable.getDefaultRenderer(java.lang.Class<?> columnClass)
<!-- END KEY -->
<!-- BEGIN DATA -->
尚未在 <code>TableColumn</code> 中设置渲染器时，返回要使用的单元格渲染器。呈现单元格时，渲染器是根据列中各单元格的类从各个项的 <code>Hashtable</code> 中获取的。如果没有对应于此 <code>columnClass</code> 的项，则此方法返回最相关超类的项。<code>JTable</code> 安装了对应于 <code>Object</code>、<code>Number</code> 和 <code>Boolean</code> 的项，它们都可以修改和替换。

@param   columnClass   返回此 columnClass 的默认单元格渲染器
@return  此 columnClass 的渲染器
@see     #setDefaultRenderer
@see     #getColumnClass

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setDefaultEditor(java.lang.Class<?> columnClass, TableCellEditor editor)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果尚未在 <code>TableColumn</code> 中设置编辑器，则设置要使用的默认单元格编辑器。如果表不需要进行编辑，或者表中的特定列不需要编辑，则使用 <code>TableModel</code> 接口中的 <code>isCellEditable</code> 方法来确保此 <code>JTable</code> 在这些列中不启动编辑器。如果 editor 为 <code>null</code>，则移除此 columnClass 的默认编辑器。

@param  columnClass 设置此 columnClass 的默认单元格编辑器
@param  editor 此 columnClass 要使用的默认单元格编辑器
@see     TableModel#isCellEditable
@see     #getDefaultEditor
@see     #setDefaultRenderer

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.table.TableCellEditor javax.swing.JTable.getDefaultEditor(java.lang.Class<?> columnClass)
<!-- END KEY -->
<!-- BEGIN DATA -->
尚未在 <code>TableColumn</code> 中设置编辑器时，返回要使用的编辑器。编辑单元格时，编辑器是根据列中各单元格的类从各项的 <code>Hashtable</code> 中获取的。如果没有对应于此 <code>columnClass</code> 的项，则此方法返回最相关超类的项。<code>JTable</code> 安装了对应于 <code>Object</code>、<code>Number</code> 和 <code>Boolean</code> 的项，它们都可以修改和替换。

@param   columnClass  返回此 columnClass 的默认单元格编辑器
@return  此 columnClass 要使用的默认单元格编辑器
@see     #setDefaultEditor
@see     #getColumnClass

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setDragEnabled(boolean b)
<!-- END KEY -->
<!-- BEGIN DATA -->
打开或关闭自动拖动处理。要启用自动拖动处理，应该将此属性设置为 {@code true}，并且该表的 {@code TransferHandler} 需要为{@code 非 null}。{@code dragEnabled} 属性的默认值为 {@code false}。
 <p>
遵守此属性并识别用户拖动动作的作业取决于外观实现，尤其是表的 {@code TableUI}。当启用自动拖动处理时，只要用户在项（单个选择模式中）或选择（其他选择模式中）上按下鼠标按键，并将鼠标移动几个像素，多数外观（包括子类化 {@code BasicLookAndFeel} 的外观）就会开始拖放操作。因此，将此属性设置为 {@code true} 可以对选择行为产生微妙的影响。
 <p>
如果使用一个忽略此属性的外观，仍然可以通过在表的 {@code TransferHandler} 上调用 {@code exportAsDrag} 开始拖放操作。 

@param b 是否启用自动拖动处理
@exception HeadlessException 如果 <code>b</code> 为 <code>true</code>，并且 <code>GraphicsEnvironment.isHeadless()</code> 返回 <code>true</code>
@see java.awt.GraphicsEnvironment#isHeadless
@see #getDragEnabled
@see #setTransferHandler
@see TransferHandler
@since 1.4

@beaninfo description: determines whether automatic drag handling is enabled bound: false

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.getDragEnabled()
<!-- END KEY -->
<!-- BEGIN DATA -->
 返回是否启用自动拖动处理。

@return  {@code dragEnabled} 属性的值
@see #setDragEnabled
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void javax.swing.JTable.setDropMode(DropMode dropMode)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置此组件的放置模式。为了向后兼容性，此属性的默认值为 <code>DropMode.USE_SELECTION</code>。 但是，为了用户使用更加方便，建议使用其他某个模式。例如，<code>DropMode.ON</code> 提供与选择类似的显示项的行为，但执行此操作不会影响表中的实际选择。
 <p>
 <code>JTable</code> 支持以下放置模式：
 <ul>
    <li><code>DropMode.USE_SELECTION</code></li>
    <li><code>DropMode.ON</code></li>
    <li><code>DropMode.INSERT</code></li>
    <li><code>DropMode.INSERT_ROWS</code></li>
    <li><code>DropMode.INSERT_COLS</code></li>
    <li><code>DropMode.ON_OR_INSERT</code></li>
    <li><code>DropMode.ON_OR_INSERT_ROWS</code></li>
    <li><code>DropMode.ON_OR_INSERT_COLS</code></li>
 </ul>
 <p>
 只有此组件具有接受放置操作的 <code>TransferHandler</code> 时，放置模式才有意义。

 @param dropMode 要使用的放置模式
 @throws IllegalArgumentException 如果放置模式不受支持或为 <code>null</code>
 @see #getDropMode
 @see #getDropLocation
 @see #setTransferHandler
 @see TransferHandler
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final javax.swing.DropMode javax.swing.JTable.getDropMode()
<!-- END KEY -->
<!-- BEGIN DATA -->
 返回此组件的放置模式。

 @return 此组件的放置模式
 @see #setDropMode
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final javax.swing.JTable.DropLocation javax.swing.JTable.getDropLocation()
<!-- END KEY -->
<!-- BEGIN DATA -->
 返回对组件的 DnD 操作期间此组件应该可见地指示为放置位置的位置；如果当前没有显示任何位置，则返回 {@code null}。 
 <p>
此方法不用于从 {@code TransferHandler} 查询放置操作，因为放置操作只在 {@code TransferHandler} 的 <code>canImport</code> 已经返回并允许显示该位置之后才会被设置。
 <p>
当此属性更改时，组件将触发名为 "dropLocation" 的属性更改事件。

 @return 放置位置
 @see #setDropMode
 @see TransferHandler#canImport(TransferHandler.TransferSupport)
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setAutoCreateRowSorter(boolean autoCreateRowSorter)
<!-- END KEY -->
<!-- BEGIN DATA -->
 指定其模型更改时是否应该为表创建一个 {@code RowSorter}。 
 <p>
 当调用 {@code setAutoCreateRowSorter(true)} 时，立即创建一个 {@code TableRowSorter} 并安装在表上。{@code autoCreateRowSorter} 属性保持为 {@code true} 时，每次模型更改都会创建一个新的 {@code
 TableRowSorter} 并将其设置为表的行排序器。

 @param autoCreateRowSorter 是否应该自动创建 {@code RowSorter}
 @see javax.swing.table.TableRowSorter
 @beaninfo
        bound: true
    preferred: true
  description: Whether or not to turn on sorting by default.
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.getAutoCreateRowSorter()
<!-- END KEY -->
<!-- BEGIN DATA -->
 如果每当模型更改时，都应该创建一个新 {@code RowSorter} 并作为该表的排序器安装，则返回 {@code true}；否则，返回 {@code false}。

 @return 如果模型更改时应该创建一个 {@code RowSorter}，则返回 true 
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setUpdateSelectionOnSort(boolean update)
<!-- END KEY -->
<!-- BEGIN DATA -->
 指定排序后是否应该更新选择。如果为 true，排序时选择将被重置，从而仍然选择相同的行（就模型而言）。默认值为 true。

 @param update 在排序时是否应该更新选择
 @beaninfo
        bound: true
       expert: true
  description: Whether or not to update the selection on sorting
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.getUpdateSelectionOnSort()
<!-- END KEY -->
<!-- BEGIN DATA -->
 如果排序后应该更新选择，则返回 true。

 @return 是否应该更新排序的选择
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setRowSorter(javax.swing.RowSorter<? extends javax.swing.table.TableModel> sorter)
<!-- END KEY -->
<!-- BEGIN DATA -->
 设置 <code>RowSorter</code>。<code>RowSorter</code> 用于提供对 <code>JTable</code> 的排序和过滤。
 <p>
 此方法清除该选择并重置所有可变行高度。
 <p>
 如果 <code>RowSorter</code> 的底层模型不同于此 <code>JTable</code> 的底层模型，则将导致不确定的行为。

 @param sorter <code>RowSorter</code>；<code>null</code> 表示关闭排序
 @see javax.swing.table.TableRowSorter
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.RowSorter<? extends javax.swing.table.TableModel> javax.swing.JTable.getRowSorter()
<!-- END KEY -->
<!-- BEGIN DATA -->
 返回负责排序的对象。

 @return 负责排序的对象
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setSelectionMode(int selectionMode)
<!-- END KEY -->
<!-- BEGIN DATA -->
将表的选择模式设置为只允许单个选择、单个连续间隔选择或多间隔选择。
 <P>
<bold>注：</bold><code>JTable</code> 提供用于处理行选择和列选择的所有方法。设置状态时（例如 <code>setSelectionMode</code>），它不仅更新行选择模型的模式，而且还将设置 <code>columnModel</code> 选择模型中的类似值。如果希望在不同的模式中操作行选择模型和列选择模型，请直接设置这二者。
 <p>
<code>JTable</code> 的行选择模型和列选择模型都默认使用 <code>DefaultListSelectionModel</code>，以便 <code>JTable</code> 与 <code>JList</code> 的工作方式一致。有关各种模式的详细信息，请参阅 <code>JList</code> 中的 <code>setSelectionMode</code> 方法。

@see JList#setSelectionMode
@beaninfo description: The selection mode used by the row and column selection models. enum: SINGLE_SELECTION            ListSelectionModel.SINGLE_SELECTION SINGLE_INTERVAL_SELECTION   ListSelectionModel.SINGLE_INTERVAL_SELECTION MULTIPLE_INTERVAL_SELECTION ListSelectionModel.MULTIPLE_INTERVAL_SELECTION

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setRowSelectionAllowed(boolean rowSelectionAllowed)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置是否可以选择此模型中的行。

@param rowSelectionAllowed   如果此模型允许行选择，则为 true
@see #getRowSelectionAllowed
@beaninfo bound: true attribute: visualUpdate true description: If true, an entire row is selected for each selected cell.

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.getRowSelectionAllowed()
<!-- END KEY -->
<!-- BEGIN DATA -->
如果可以选择行，则返回 true。

@return 如果可以选择行，则返回 true；否则返回 false
@see #setRowSelectionAllowed

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setColumnSelectionAllowed(boolean columnSelectionAllowed)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置是否可以选择此模型中的列。

@param columnSelectionAllowed   如果此模型允许列选择，则为 true
@see #getColumnSelectionAllowed
@beaninfo bound: true attribute: visualUpdate true description: If true, an entire column is selected for each selected cell.

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.getColumnSelectionAllowed()
<!-- END KEY -->
<!-- BEGIN DATA -->
如果可以选择列，则返回 true。

@return 如果可以选择列，则返回 true；否则返回 false
@see #setColumnSelectionAllowed

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setCellSelectionEnabled(boolean cellSelectionEnabled)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置此表是否允许同时存在行选择和列选择。当允许时，表将行选择模型和列选择模型的相交部分作为选定的单元格。重写 <code>isCellSelected</code> 以更改此默认行为。此方法等效于将 <code>columnModel</code> 的 <code>rowSelectionAllowed</code> 属性和 <code>columnSelectionAllowed</code> 属性均设置为所提供的值。

@param  cellSelectionEnabled	如果允许同时存在行选择和列选择，则为 true
@see #getCellSelectionEnabled
@see #isCellSelected
@beaninfo bound: true attribute: visualUpdate true description: Select a rectangular region of cells rather than rows or columns.

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.getCellSelectionEnabled()
<!-- END KEY -->
<!-- BEGIN DATA -->
如果同时启用了行选择模型和列选择模型，则返回 true。等效于 <code>getRowSelectionAllowed() &amp;&amp; getColumnSelectionAllowed()</code>。

@return 如果同时启用了行选择模型和列选择模型，则返回 true

@see #setCellSelectionEnabled

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.selectAll()
<!-- END KEY -->
<!-- BEGIN DATA -->
选择表中的所有行、列和单元格。

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.clearSelection()
<!-- END KEY -->
<!-- BEGIN DATA -->
取消选中所有已选定的行和列。

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setRowSelectionInterval(int index0, int index1)
<!-- END KEY -->
<!-- BEGIN DATA -->
选择从 <code>index0</code> 到 <code>index1</code> 之间（包含两端）的行。

@exception IllegalArgumentException 如果 <code>index0</code> 或 <code>index1</code> 位于 [0,<code>getRowCount()</code>-1] 范围外
@param   index0 间隔的一端
@param   index1 间隔的另一端

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setColumnSelectionInterval(int index0, int index1)
<!-- END KEY -->
<!-- BEGIN DATA -->
选择从 <code>index0</code> 到 <code>index1</code> 之间（包含两端）的列。

@exception IllegalArgumentException  如果 <code>index0</code> 或 <code>index1</code> 位于 [0, <code>getColumnCount()</code>-1] 范围外
@param   index0 间隔的一端
@param   index1 间隔的另一端

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.addRowSelectionInterval(int index0, int index1)
<!-- END KEY -->
<!-- BEGIN DATA -->
将从 <code>index0</code> 到 <code>index1</code> 之间（包含两端）的行添加到当前选择中。

@exception IllegalArgumentException  如果 <code>index0</code> 或 <code>index1</code> 位于 [0, <code>getRowCount()</code>-1] 范围外
@param   index0 间隔的一端
@param   index1 间隔的另一端

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.addColumnSelectionInterval(int index0, int index1)
<!-- END KEY -->
<!-- BEGIN DATA -->
将从 <code>index0</code> 到 <code>index1</code> 之间（包含两端）的列添加到当前选择中。

@exception IllegalArgumentException  如果 <code>index0</code> 或 <code>index1</code> 位于 [0, <code>getColumnCount()</code>-1] 范围外
@param   index0 间隔的一端
@param   index1 间隔的另一端

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.removeRowSelectionInterval(int index0, int index1)
<!-- END KEY -->
<!-- BEGIN DATA -->
取消选中从 <code>index0</code> 到 <code>index1</code> 之间（包含两端）的行。

@exception IllegalArgumentException  如果 <code>index0</code> 或 <code>index1</code> 位于 [0, <code>getRowCount()</code>-1] 范围外
@param   index0 间隔的一端
@param   index1 间隔的另一端

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.removeColumnSelectionInterval(int index0, int index1)
<!-- END KEY -->
<!-- BEGIN DATA -->
取消选中从 <code>index0</code> 到 <code>index1</code> 之间（包含两端）的列。

@exception IllegalArgumentException  如果 <code>index0</code> 或 <code>index1</code> 位于 [0, <code>getColumnCount()</code>-1] 范围外
@param   index0 间隔的一端
@param   index1 间隔的另一端

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.getSelectedRow()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回第一个选定行的索引；如果没有选定的行，则返回 -1。
@return  第一个选定行的索引

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.getSelectedColumn()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回第一个选定列的索引；如果没有选定的列，则返回 -1。
@return  第一个选定列的索引。

<!-- END DATA -->
<!-- BEGIN KEY -->
public int[] javax.swing.JTable.getSelectedRows()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回所有选定行的索引。

@return 包含所有选定行索引的整数数组；如果没有选定的行，则返回一个空数组 
@see #getSelectedRow

<!-- END DATA -->
<!-- BEGIN KEY -->
public int[] javax.swing.JTable.getSelectedColumns()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回所有选定列的索引。

@return 包含所有选定列索引的整数数组；如果没有选定的列，则返回一个空数组
@see #getSelectedColumn

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.getSelectedRowCount()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回选定行数。

@return 选定行数；如果没有选定的行，则返回 0

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.getSelectedColumnCount()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回选定列数。

@return 选定列数；如果没有选定的列，则返回 0

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.isRowSelected(int row)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果指定的索引位于行的有效范围内，并且位于该索引的行被选定，则返回 true。

@return 如果 <code>row</code> 是有效的索引，并且位于该索引的行被选定（其中 0 表示第一行），则返回 true

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.isColumnSelected(int column)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果指定的索引位于列的有效范围内，并且位于该索引的列被选定，则返回 true。

@param   column   列模型中的列
@return 如果 <code>column</code> 是有效的索引，并且位于该索引的列被选定（其中 0 表示第一列），则返回 true

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.isCellSelected(int row, int column)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果指定的索引位于行和列的有效范围内，并且位于该指定位置的单元格被选定，则返回 true。
@param row   被查询的行
@param column  被查询的列

@return 如果 <code>row</code> 和 <code>column</code> 是有效的索引，并且位于索引 <code>(row, column)</code> 的单元格被选定（其中第一行和第一列位于索引 0），则返回 true

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.changeSelection(int rowIndex, int columnIndex, boolean toggle, boolean extend)
<!-- END KEY -->
<!-- BEGIN DATA -->
根据 <code>toggle</code> 和 <code>extend</code> 这两个标志的状态，更新表的选择模型。UI 所接收的键盘事件或鼠标事件所引起的大多数选择更改都是通过此方法来传递的，以便子类可以重写此行为。某些 UI 需要的功能可能多于此方法所提供的功能（例如在操作非连续选择的前端时），而且对某些选择更改可能不会调用到此方法中。
 <p>
此实现使用以下约定：
 <ul>
<li> <code>toggle</code>：<em>false</em>，<code>extend</code>：<em>false</em>。清除以前的选择并确保选定新的单元格。
<li> <code>toggle</code>：<em>false</em>，<code>extend</code>：<em>true</em>。将以前的选择从定位点扩展到指定的单元格，清除所有其他选择。
<li> <code>toggle</code>：<em>true</em>，<code>extend</code>：<em>false</em>。如果指定的单元格是选定的，则取消选定它。如果它不是选定的，则选定它。
<li> <code>toggle</code>：<em>true</em>，<code>extend</code>：<em>true</em>。将定位点的选择状态应用于它与指定单元间的所有单元。
 </ul>
@param  rowIndex   影响 <code>row</code> 的选择
@param  columnIndex  影响 <code>column</code> 的选择
@param  toggle  参见上面的描述
@param  extend  如果为 true，则扩展当前的选择

@since 1.3

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Color javax.swing.JTable.getSelectionForeground()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回选定单元格的前景色。

@return 前景属性的 <code>Color</code> 对象
@see #setSelectionForeground
@see #setSelectionBackground

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setSelectionForeground(Color selectionForeground)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置选定单元格的前景色。单元格渲染器可以使用此颜色来呈现选定单元格的文本和图形。
 <p>
此属性的默认值由外观实现定义。
 <p>
这是一个 <a href="http://java.sun.com/docs/books/tutorial/javabeans/whatis/beanDefinition.html">JavaBeans</a> 绑定 (bound) 属性。

@param selectionForeground  用于选定列表项前景中的 <code>Color</code>
@see #getSelectionForeground
@see #setSelectionBackground
@see #setForeground
@see #setBackground
@see #setFont
@beaninfo bound: true description: A default foreground color for selected cells.

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Color javax.swing.JTable.getSelectionBackground()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回选定单元格的背景色。

@return 用于选定列表项背景中的 <code>Color</code>
@see #setSelectionBackground
@see #setSelectionForeground

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setSelectionBackground(Color selectionBackground)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置选定单元格的背景色。单元格渲染器可以使用此颜色填充选定单元格。
 <p>
此属性的默认值由外观实现定义。
 <p>
这是一个 <a href="http://java.sun.com/docs/books/tutorial/javabeans/whatis/beanDefinition.html">JavaBeans</a> 绑定属性。

@param selectionBackground  用于选定单元格背景的 <code>Color</code>
@see #getSelectionBackground
@see #setSelectionForeground
@see #setForeground
@see #setBackground
@see #setFont
@beaninfo bound:true description: A default background color for selected cells.

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.table.TableColumn javax.swing.JTable.getColumn(Object identifier)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回表中列的 <code>TableColumn</code> 对象，当使用 <code>equals</code> 进行比较时，表的标识符等于 <code>identifier</code>。

@return  与标识符相匹配的 <code>TableColumn</code> 对象
@exception IllegalArgumentException  如果 <code>identifier</code> 为 <code>null</code> 或者没有 <code>TableColumn</code> 具有此标识符

@param   identifier  标识符对象

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.convertColumnIndexToModel(int viewColumnIndex)
<!-- END KEY -->
<!-- BEGIN DATA -->
将视图中位于 <code>viewColumnIndex</code> 的列索引映射到表模型中的列索引。返回模型中的对应列索引。如果 <code>viewColumnIndex</code> 小于 0，则返回 <code>viewColumnIndex</code>。

@param   viewColumnIndex     视图中的列索引
@return  模型中的对应列索引

@see #convertColumnIndexToView

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.convertColumnIndexToView(int modelColumnIndex)
<!-- END KEY -->
<!-- BEGIN DATA -->
将表模型中位于 <code>modelColumnIndex</code> 的列索引映射到视图中的列索引。返回视图中的对应列索引；如果此列不是被显示的列，则返回 -1。如果 <code>modelColumnIndex</code> 小于 0，则返回 <code>modelColumnIndex</code>。

@param   modelColumnIndex  模型中的列索引
@return   视图中的对应列索引

@see #convertColumnIndexToModel

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.convertRowIndexToView(int modelRowIndex)
<!-- END KEY -->
<!-- BEGIN DATA -->
 将基于 <code>TableModel</code> 的行索引映射到该视图。如果模型的内容没有进行排序，则模型和视图的索引相同。

 @param modelRowIndex 基于模型的行索引
 @return 视图中对应行的索引；如果该行不可见，则返回 -1
 @throws IndexOutOfBoundsException 如果启用排序并传递 <code>TableModel</code> 的行数范围之外的索引
 @see javax.swing.table.TableRowSorter
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.convertRowIndexToModel(int viewRowIndex)
<!-- END KEY -->
<!-- BEGIN DATA -->
 将基于视图的行索引映射到底层 <code>TableModel</code>。如果模型的内容没有进行排序，则模型和视图的索引相同。

 @param viewRowIndex 视图中行的索引
 @return 模型中对应行的索引
 @throws IndexOutOfBoundsException 如果启用排序并传递 <code>JTable</code> 范围（由 <code>getRowCount</code> 方法确定）之外的索引
 @see javax.swing.table.TableRowSorter
 @see #getRowCount
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.getRowCount()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>JTable</code> 中可以显示的行数（给定无限空间）。如果已指定一个带有过滤器的 <code>RowSorter</code>，则返回的行数可能与底层 <code>TableModel</code> 的行数不同。 

@return <code>JTable</code> 中显示的行数
@see #getColumnCount

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.getColumnCount()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回列模型中的列数。注意，这可能与表模型中的列数不同。

@return  表中的列数
@see #getRowCount
@see #removeColumn

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String javax.swing.JTable.getColumnName(int column)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回出现在视图中 <code>column</code> 列位置处的列名称。

@param  column    在视图中查询的列
@return 视图中 <code>column</code> 位置的列名称，其中第一列为列 0

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.Class<?> javax.swing.JTable.getColumnClass(int column)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回出现在视图中 <code>column</code> 列位置处的列类型。

@param   column   在视图中查询的列
@return 视图中 <code>column</code> 位置的列类型，其中第一列为列 0

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.Object javax.swing.JTable.getValueAt(int row, int column)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>row</code> 和 <code>column</code> 位置的单元格值。
 <p>
<b>注</b>：列是以表视图的显示顺序，而不是以 <code>TableModel</code> 的列顺序指定的。这是一项重要的区别，因为在用户重新安排表中的列时，视图中给定索引处的列将更改。同时用户的操作不会影响模型的列顺序。

@param   row  其值要被查询的行
@param   column   其值要被查询的列
@return  指定单元格处的 Object

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setValueAt(Object aValue, int row, int column)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置表模型中 <code>row</code> 和 <code>column</code> 位置的单元格值。
 <p>
<b>注：</b>列是以表视图的显示顺序，而不是以 <code>TableModel</code> 的列顺序指定的。这是一项重要的区别，因为在用户重新安排表中的列时，视图中给定索引处的列将更改。同时用户的操作不会影响模型的列顺序。

<code>aValue</code> 是一个新值。

@param   aValue   新值
@param   row  要更改的单元格所在的行
@param   column  要更改的单元格所在的列
@see #getValueAt

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.isCellEditable(int row, int column)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果 <code>row</code> 和 <code>column</code> 位置的单元格是可编辑的，则返回 true。否则，在单元格上调用 <code>setValueAt</code> 没有任何效果。
 <p>
<b>注：</b>列是以表视图的显示顺序，而不是以 <code>TableModel</code> 的列顺序指定的。这是一项重要的区别，因为在用户重新安排表中的列时，视图中给定索引处的列将更改。同时用户的操作不会影响模型的列顺序。

@param   row  其值要被查询的行
@param   column  其值要被查询的列
@return  如果单元格是可编辑的，则返回 true
@see #setValueAt

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.addColumn(TableColumn aColumn)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 <code>aColumn</code> 追加到此 <code>JTable</code> 的列模型所保持的列数组的尾部。如果 <code>aColumn</code> 的列名称为 <code>null</code>，则将 <code>aColumn</code> 的列名称设置为 <code>getModel().getColumnName()</code> 所返回的名称。
  <p>
要向此 <code>JTable</code> 添加一列，以用给定的 <code>width</code>、<code>cellRenderer</code> 和 <code>cellEditor</code> 来显示模型中第 <code>modelColumn</code> 列的数据，可以使用以下方法：
  <pre>

      addColumn(new TableColumn(modelColumn, width, cellRenderer, cellEditor));

  </pre>
[<code>TableColumn</code> 构造方法中的任何一个方法都可以用来替代此方法。]模型的列号存储在 <code>TableColumn</code> 中，在呈现和编辑过程中使用该列号来定位模型中合适的数据值。当列在视图中重新排序时，不更改模型的列号。

@param  aColumn   要添加的 <code>TableColumn</code> 
@see    #removeColumn

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.removeColumn(TableColumn aColumn)
<!-- END KEY -->
<!-- BEGIN DATA -->
从此 <code>JTable</code> 的列数组中移除 <code>aColumn</code>。注：此方法不从模型中移除数据列；它只移除负责显示它的 <code>TableColumn</code>。

@param  aColumn   要移除的 <code>TableColumn</code>
@see    #addColumn

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.moveColumn(int column, int targetColumn)
<!-- END KEY -->
<!-- BEGIN DATA -->
将视图中的 <code>column</code> 列移动到当前被 <code>targetColumn</code> 列所占用的位置。<code>targetColumn</code> 位置上的原有列向左或右移动以腾出空间。

@param   column    要移动的列的索引
@param   targetColumn   列的新索引

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.columnAtPoint(Point point)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>point</code> 所在的列索引；如果结果不在 [0, <code>getColumnCount()</code>-1] 范围内，则返回 -1。

@param   point   要查询的位置
@return  <code>point</code> 所在的列索引；如果结果不在 [0, <code>getColumnCount()</code>-1] 范围内，则返回 -1
@see     #rowAtPoint

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.rowAtPoint(Point point)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>point</code> 所在的行索引；如果结果不在 [0, <code>getRowCount()</code>-1] 范围内，则返回 -1。

@param   point   要查询的位置
@return  <code>point</code> 所在的行索引；如果结果不在 [0, <code>getRowCount()</code>-1] 范围内，则返回 -1
@see     #columnAtPoint

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Rectangle javax.swing.JTable.getCellRect(int row, int column, boolean includeSpacing)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回位于 <code>row</code> 和 <code>column</code> 相交位置的单元格矩形。如果 <code>includeSpacing</code> 为 true，则返回的值具有指定行和列的完整高度和宽度。如果为 false，则返回的矩形为单元格空间减去单元格间的间隙，以便在呈现期间设置该属性后，返回呈现和编辑的组件的真实边界。
 <p>
如果列索引有效但是行索引小于 0，则此方法返回一个矩形，此矩形的 <code>y</code> 和 <code>height</code> 设置为合适的值，其 <code>x</code> 和 <code>width</code> 值都设置为 0。通常，行索引或列索引指示适当区域外的单元格时，此方法都返回一个矩形，它描绘了表范围内最近单元格的最近边。当行索引和列索引都超出范围时，返回的矩形覆盖了最近单元格的最近点。
 <p>
在所有的情形中，使用此方法沿一个轴的计算结果不会因为沿另一个轴的计算出现异常而失败。当单元格无效时，忽略 <code>includeSpacing</code> 参数。

@param   row   所需单元格所在的行索引
@param   column　　所需单元格所在的列索引；不一定与表中数据模型的列索引相同；{@link #convertColumnIndexToView(int)} 方法可以用来将数据模型的列索引转换为显示的列索引
@param   includeSpacing  如果为 false，则返回实际的单元格边界，计算方法是从列模型和行模型的高度和宽度中减去单元格间距

@return  包含 <code>row</code>、<code>column</code> 处单元格的矩形
@see #getIntercellSpacing

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.doLayout()
<!-- END KEY -->
<!-- BEGIN DATA -->
使此表布局其行和列。重写的此方法可调整列的大小，以适应包含的父级的大小更改。调整表中一列或多列的大小，以便所有此 <code>JTable</code> 列的总宽度等于表的宽度。
 <p>
开始布局之前，此方法获取 <code>tableHeader</code> 的 <code>resizingColumn</code>。当由于要调整封闭窗口的大小而调用此方法时，<code>resizingColumn</code> 为 <code>null</code>。这意味着调整大小发生在 <code>JTable</code> 的&ldquo;外部&rdquo;，并且更改（或 &quot;delta&quot; ）应该分布到所有列，无论此 <code>JTable</code> 的自动调整大小模式如何。
 <p>
如果 <code>resizingColumn</code> 不为 <code>null</code>，则它是发生大小更改的表中的一列，而不是表本身。在这种情况下，自动调整大小模式控制额外（或不足）空间在可用列之间的分布方式。
 <p>
该模式有：
 <ul>
<li>  AUTO_RESIZE_OFF：不自动调整列的宽度。当列的总宽度超过 <code>Viewport</code> 的宽度时，使用水平滚动条来适应列的宽度。如果 <code>JTable</code> 没有封闭在 <code>JScrollPane</code> 中，则可能导致该表的一部分不可见。
<li>  AUTO_RESIZE_NEXT_COLUMN：使用被调整列的下一列。这导致相邻单元格之间的&ldquo;边界&rdquo;或分隔栏是可独立调整的。
<li>  AUTO_RESIZE_SUBSEQUENT_COLUMNS：使用被调整列后面的所有列来吸收所作的更改。这是默认行为。
<li>  AUTO_RESIZE_LAST_COLUMN：只自动调整最后一列的大小。如果最后一列的边界导致无法分配所需的大小，则将最后一列的宽度设置为适当的界限并且不再做进一步的调整。
<li>  AUTO_RESIZE_ALL_COLUMNS：将 delta 分散在 <code>JTable</code> 中的所有列之间，包括正在被调整的列。
 </ul>
 <p>
<bold>注：</bold>当 <code>JTable</code> 调整列宽时，它绝对遵守其最小值和最大值。但是即使在调用此方法后，列的总宽度仍然可能不等于表的宽度。发生这种情况时，<code>JTable</code> 不会进入 AUTO_RESIZE_OFF 模式来生成一个滚动条，或者中断其当前自动调整模式的其他提交，相反，它允许其边界设置为大于（或小于）最大总宽度（或最小总宽度），这意味着要么没有足够的空间来显示所有的列，要么就是列不能填满 <code>JTable</code> 的边界。这将分别导致在绘制期间，某些列将被剪切掉，或者某个区域将被绘制为 <code>JTable</code> 的背景色。
 <p>
用于在可用列之间分布 delta 的机制是由 <code>JTable</code> 类中的一个私有方法提供的：
 <pre>
   adjustSizes(long targetSize, final Resizable3 r, boolean inverse)
 </pre>
以下部分是对它的解释。<code>Resizable3</code> 是一个私有接口，它允许包含元素（具有大小、首选大小、最大大小和最小大小）集合的任何数据结构可以通过该算法来操作其元素。
 <p>
<H3> 分布 delta </H3>
 <p>
<H4> 概述 </H4>
 <P>
将 r 中各元素的目标大小与首选大小总和之间的差值称为 &quot;DELTA&quot;。单独的大小通过将原始首选大小加上 DELTA 的共享部分来计算，该共享部分基于每个首选大小到其限定边界的距离（最小值或最大值）。
 <p>
<H4>定义</H4>
 <P>
单独的约束称为 min[i]、max[i] 和 pref[i]。
 <p>
它们相应的和称为：MIN、MAX 和 PREF。
 <p>
用以下公式计算每个新大小：
 <p>
 <pre>
          size[i] = pref[i] + delta[i]
 </pre>
其中每个单独的 delta[i] 根据以下条件计算：
 <p>
如果 (DELTA &lt; 0)，则处于收缩模式，其中：
 <p>
 <PRE>
                        DELTA
          delta[i] = ------------ * (pref[i] - min[i])
                     (PREF - MIN)
 </PRE>
如果 (DELTA &gt; 0)，则处于扩展模式，其中：
 <p>
 <PRE>
                        DELTA
          delta[i] = ------------ * (max[i] - pref[i])
                      (MAX - PREF)
 </PRE>
 <P>
总体效果是总大小向总的最小值或最大值移动相同的百分比 k，此百分比确保适应所需的间距，即 DELTA。

<H4>详细信息</H4>
 <P>
估计此处给出的公式计算易受累积舍入误差的影响，该误差是由此操作的有限精度（使用 int）引起的。为了处理此问题，要经常重新计算上述乘数，这可将以前迭代中的舍入误差考虑在内。结果是一个生成一组整数的算法，这组整数值的和恰好等于提供的 <code>targetSize</code>，这是通过将舍入误差均匀分散到给定元素上来实现的。

<H4>何时选中 MAX 和 MIN 边界</H4>
 <P>
当 <code>targetSize</code> 处于 [MIN, MAX] 范围外时，算法将所有大小设置为其适合的限定值（最大值或最小值）。


<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.sizeColumnsToFit(boolean lastColumnOnly)
<!-- END KEY -->
<!-- BEGIN DATA -->
调整表列的大小以适合可用的空间。
@deprecated 从 Swing version 1.0.3 开始，由 <code>doLayout()</code> 取代。
@see #doLayout

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.sizeColumnsToFit(int resizingColumn)
<!-- END KEY -->
<!-- BEGIN DATA -->
从 Java 2 平台 v1.4 开始已过时。请使用 <code>doLayout()</code> 方法。
@param resizingColumn    由于大小的改变导致需要进行此调整的列；如果没有这样的列，则为 -1
@see  #doLayout

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String javax.swing.JTable.getToolTipText(MouseEvent event)
<!-- END KEY -->
<!-- BEGIN DATA -->
重写 <code>JComponent</code> 的 <code>getToolTipText</code> 方法，从而允许使用渲染器的提示（如果设置了文本）。
 <p>
<bold>注：</bold>要让 <code>JTable</code> 正确显示其渲染器的工具提示，<code>JTable</code> 必须是 <code>ToolTipManager</code> 中的注册组件。此操作可在 <code>initializeLocalVars</code> 中自动完成，但是如果之后在 <code>JTable</code> 上调用了 <code>setToolTipText(null)</code>，则这是一个注销的表组件，渲染器的提示将不再显示。

@see JComponent#getToolTipText

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setSurrendersFocusOnKeystroke(boolean surrendersFocusOnKeystroke)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置由于 JTable 为某个单元格转发键盘事件而导致编辑器被激活时，此 JTable 中的编辑器是否获得键盘焦点。默认情况下，此属性为 false，且 JTable 保留焦点，除非单击了单元格。

@param surrendersFocusOnKeystroke 如果在键击导致编辑器被激活时编辑器应该获得焦点，则为 true

@see #getSurrendersFocusOnKeystroke
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.getSurrendersFocusOnKeystroke()
<!-- END KEY -->
<!-- BEGIN DATA -->
如果在键击导致编辑器被激活时编辑器应该获得焦点，则返回 true

@return  如果在键击导致编辑器被激活时编辑器应该获得焦点，则返回 true

@see #setSurrendersFocusOnKeystroke
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.editCellAt(int row, int column)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果 <code>row</code> 和 <code>column</code> 位置的索引在有效范围内，并且这些索引处的单元格是可编辑的，则以编程方式启动该位置单元格的编辑。注意，这是 <code>editCellAt(int, int, null)</code> 的一种便捷方法。

@param   row   要编辑的行
@param   column   要编辑的列
@return 如果由于任何原因而无法编辑该单元格，或者索引无效，则返回 false

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.editCellAt(int row, int column, EventObject e)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果 <code>row</code> 和 <code>column</code> 位置的索引在有效范围内，并且这些索引处的单元格是可编辑的，则以编程方式启动该位置单元格的编辑。要防止 <code>JTable</code> 编辑特定的表、列或单元格的值，<code>TableModel</code> 接口中的 <code>isCellEditable</code> 方法应返回 false。

@param   row     要编辑的行
@param   column  要编辑的列
@param   e   要传递到 <code>shouldSelectCell</code> 中的事件；注意，从 Java 2 平台 v1.2 开始，不再调用 <code>shouldSelectCell</code>
@return  如果由于任何原因而无法编辑该单元格，或者索引无效，则返回 false

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.isEditing()
<!-- END KEY -->
<!-- BEGIN DATA -->
如果正在编辑单元格，则返回 true。

@return  如果表正在编辑一个单元格，则返回 true
@see     #editingColumn
@see     #editingRow

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Component javax.swing.JTable.getEditorComponent()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回处理编辑会话的组件。如果没有编辑任何内容，则返回 null。

@return  处理编辑会话的 Component

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.getEditingColumn()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回包含当前被编辑的单元格的列索引。如果没有编辑任何内容，则返回 -1。

@return  包含当前被编辑的单元格的列索引；如果没有编辑任何内容，则返回 -1
@see #editingRow

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.getEditingRow()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回包含当前被编辑的单元格的行索引。如果没有编辑任何内容，则返回 -1。

@return  包含当前被编辑的单元格的行索引；如果没有编辑任何内容，则返回 -1
@see #editingColumn

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.plaf.TableUI javax.swing.JTable.getUI()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回呈现此组件的 L&F 对象。

@return 呈现此组件的 <code>TableUI</code> 对象

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setUI(TableUI ui)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置呈现此组件并进行重新绘制的 L&F 对象。

@param ui  TableUI L&F 对象
@see UIDefaults#getUI
@beaninfo bound:　true hidden:　true attribute: visualUpdate true description: The UI object that implements the Component's LookAndFeel.

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.updateUI()
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>UIManager</code> 发出的表明 L&F 已经更改的通知。用 <code>UIManager</code> 的最新版本替换当前的 UI 对象。

@see JComponent#updateUI

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String javax.swing.JTable.getUIClassID()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回用于构造呈现此组件时所用 L&F 类名称的后缀。

@return  字符串 &quot;TableUI&quot;
@see JComponent#getUIClassID
@see UIDefaults#getUI

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setModel(TableModel dataModel)
<!-- END KEY -->
<!-- BEGIN DATA -->
将此表的数据模型设置为 <code>newModel</code>，并向其注册以获取来自新数据模型的侦听器通知。

@param   dataModel        此表的新数据源
@exception IllegalArgumentException      如果 <code>newModel</code> 为 <code>null</code>
@see     #getModel
@beaninfo bound:true description: The model that is the source of the data for this view.

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.table.TableModel javax.swing.JTable.getModel()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回提供此 <code>JTable</code> 所显示数据的 <code>TableModel</code>。

@return  提供此 <code>JTable</code> 所显示数据的 <code>TableModel</code>
@see     #setModel

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setColumnModel(TableColumnModel columnModel)
<!-- END KEY -->
<!-- BEGIN DATA -->
将此表的列模型设置为 <code>newModel</code>，并向其注册以获取来自新数据模型的侦听器通知。还要将 <code>JTableHeader</code> 的列模型设置为 <code>columnModel</code>。

@param   columnModel        此表的新数据源
@exception IllegalArgumentException      如果 <code>columnModel</code> 为 <code>null</code>
@see     #getColumnModel
@beaninfo bound:　true description: The object governing the way columns appear in the view.

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.table.TableColumnModel javax.swing.JTable.getColumnModel()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回包含此表所有列信息的 <code>TableColumnModel</code>。

@return  提供该表列状态的对象
@see     #setColumnModel

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setSelectionModel(ListSelectionModel newModel)
<!-- END KEY -->
<!-- BEGIN DATA -->
将此表的行选择模型设置为 <code>newModel</code>，并向其注册以获取来自新数据模型的侦听器通知。

@param   newModel        新的选择模型
@exception IllegalArgumentException      如果 <code>newModel</code> 为 <code>null</code>
@see     #getSelectionModel
@beaninfo bound:true description: The selection model for rows.

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.ListSelectionModel javax.swing.JTable.getSelectionModel()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回用来维持行选择状态的 <code>ListSelectionModel</code>。

@return  提供行选择状态的对象；如果不允许行选择，则返回 <code>null</code>
@see     #setSelectionModel

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.sorterChanged(RowSorterEvent e)
<!-- END KEY -->
<!-- BEGIN DATA -->
 <code>RowSorter</code> 以某种方式发生了更改的 <code>RowSorterListener</code> 通知。

 @param e 描述更改的 <code>RowSorterEvent</code> 
 @throws NullPointerException 如果 <code>e</code> 为 <code>null</code>
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.tableChanged(TableModelEvent e)
<!-- END KEY -->
<!-- BEGIN DATA -->
当此表的 <code>TableModel</code> 生成 <code>TableModelEvent</code> 时调用。应在该模型的坐标系统中构造 <code>TableModelEvent</code>；当此 <code>JTable</code> 接收事件时，它执行到视图坐标系统的适当映射。
 <p>
应用程序代码不显式地使用这些方法，它们由 <code>JTable</code> 在内部使用。
 <p>
注意，从 1.3 版本开始，此方法清除选择（如果有）。

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.columnAdded(TableColumnModelEvent e)
<!-- END KEY -->
<!-- BEGIN DATA -->
将列添加到表的列模型时调用。
 <p>
应用程序代码不显式地使用这些方法，它们由 JTable 在内部使用。

@see TableColumnModelListener

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.columnRemoved(TableColumnModelEvent e)
<!-- END KEY -->
<!-- BEGIN DATA -->
从表的列模型中移除列时调用。
 <p>
应用程序代码不显式地使用这些方法，它们由 JTable 在内部使用。

@see TableColumnModelListener

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.columnMoved(TableColumnModelEvent e)
<!-- END KEY -->
<!-- BEGIN DATA -->
重新定位列时调用。如果正在编辑某个单元格，则停止编辑并重新绘制该单元格。
 <p>
应用程序代码不显式地使用这些方法，它们由 JTable 在内部使用。

@param e   接收到的事件
@see TableColumnModelListener

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.columnMarginChanged(ChangeEvent e)
<!-- END KEY -->
<!-- BEGIN DATA -->
当列由于间距的更改而被移动时调用。如果正在编辑某个单元格，则停止编辑并重新绘制该单元格。
 <p>
应用程序代码不显式地使用这些方法，它们由 JTable 在内部使用。

@param  e    接收到的事件
@see TableColumnModelListener

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.columnSelectionChanged(ListSelectionEvent e)
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>TableColumnModel</code> 的选择模型更改时调用。
 <p>
应用程序代码不显式地使用这些方法，它们由 JTable 在内部使用。

@param  e  接收到的事件
@see TableColumnModelListener

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.valueChanged(ListSelectionEvent e)
<!-- END KEY -->
<!-- BEGIN DATA -->
行选择更改时调用，重新绘制来显示新的选择。
 <p>
应用程序代码不显式地使用这些方法，它们由 JTable 在内部使用。

@param e  接收到的事件
@see ListSelectionListener

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.editingStopped(ChangeEvent e)
<!-- END KEY -->
<!-- BEGIN DATA -->
编辑结束时调用。保存更改并丢弃编辑器。
 <p>
应用程序代码不显式地使用这些方法，它们由 JTable 在内部使用。

@param  e  接收到的事件
@see CellEditorListener

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.editingCanceled(ChangeEvent e)
<!-- END KEY -->
<!-- BEGIN DATA -->
编辑取消时调用。丢弃编辑器对象，并再次呈现单元格。
 <p>
应用程序代码不显式地使用这些方法，它们由 JTable 在内部使用。

@param  e  接收到的事件
@see CellEditorListener

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setPreferredScrollableViewportSize(Dimension size)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置此表视口的首选大小。

@param size  指定 <code>JViewport</code>（其视图为此表）的 <code>preferredSize</code> 的 <code>Dimension</code> 对象
@see Scrollable#getPreferredScrollableViewportSize
@beaninfo description: The preferred size of the viewport.

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Dimension javax.swing.JTable.getPreferredScrollableViewportSize()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此表视口的首选大小。

@return 包含 <code>JViewport</code>（它显示此表）的 <code>preferredSize</code> 的 <code>Dimension</code> 对象
@see Scrollable#getPreferredScrollableViewportSize

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回完全呈现出一个新行或新列（取决于方向）的滚动增量（以像素为单位）。
 <p>
用户每次请求一个单位的滚动时，就调用此方法。

@param visibleRect  视口中可见的视图区域
@param orientation <code>SwingConstants.VERTICAL</code> 或 <code>SwingConstants.HORIZONTAL</code>
@param direction 小于 0 向上/左滚动，大于 0 向下/右滚动
@return 在指定方向滚动的&ldquo;单位&rdquo;增量
@see Scrollable#getScrollableUnitIncrement

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTable.getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>visibleRect.height</code> 或 <code>visibleRect.width</code>，这取决于此表的方向。注意，从 Swing 1.1.1 (Java 2 v 1.2.2) 开始，返回的值将确保视口在行边界上完全对齐。

@return 每个方向上的 <code>visibleRect.height</code> 或 <code>visibleRect.width</code>
@see Scrollable#getScrollableBlockIncrement

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.getScrollableTracksViewportWidth()
<!-- END KEY -->
<!-- BEGIN DATA -->
如果 <code>autoResizeMode</code> 设置为 <code>AUTO_RESIZE_OFF</code>，则返回 false，这指示表的宽度不是由视口的宽度决定的。否则返回 true。

@return 如果 <code>autoResizeMode</code> 设置为 <code>AUTO_RESIZE_OFF</code>，则返回 false；否则返回 true
@see Scrollable#getScrollableTracksViewportWidth

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.getScrollableTracksViewportHeight()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 {@code false} 指示表的高度不是由视口的高度决定的，除非 {@code getFillsViewportHeight} 为 {@code true} 并且该表的首选高度小于视口的高度。 

 @return {@code false}，除非 {@code getFillsViewportHeight} 为 {@code true} 并且需要延伸该表以填充视口
 @see Scrollable#getScrollableTracksViewportHeight
 @see #setFillsViewportHeight
 @see #getFillsViewportHeight

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setFillsViewportHeight(boolean fillsViewportHeight)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置此表是否始终大到足以填充封闭视口的高度。如果该表的首选高度小于视口，则将会延伸该表以填充视口。换句话说，此方法确保该表永远不会小于该视口。此属性的默认值为 {@code false}。

 @param fillsViewportHeight 此表是否始终大到足以填充封闭视口的高度
 @see #getFillsViewportHeight
 @see #getScrollableTracksViewportHeight
 @since 1.6
 @beaninfo
      bound: true
      description: Whether or not this table is always made large enough
                   to fill the height of an enclosing viewport

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.getFillsViewportHeight()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此表是否始终大到足以填充封闭视口的高度。 

 @return 此表是否始终大到足以填充封闭视口的高度
 @see #setFillsViewportHeight
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void javax.swing.JTable.createDefaultRenderers()
<!-- END KEY -->
<!-- BEGIN DATA -->
为 object、number、double、date、boolean 和 icon 创建默认的单元格渲染器。
@see javax.swing.table.DefaultTableCellRenderer

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void javax.swing.JTable.createDefaultEditors()
<!-- END KEY -->
<!-- BEGIN DATA -->
为 object、number 和 boolean 值创建默认的单元格编辑器。
@see DefaultCellEditor

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void javax.swing.JTable.initializeLocalVars()
<!-- END KEY -->
<!-- BEGIN DATA -->
将表的属性初始化为其默认值。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected javax.swing.table.TableModel javax.swing.JTable.createDefaultDataModel()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回默认的表模型对象，它是一个 <code>DefaultTableModel</code>。子类可以重写此方法以返回不同的表模型对象。

@return 默认的表模型对象
@see javax.swing.table.DefaultTableModel

<!-- END DATA -->
<!-- BEGIN KEY -->
protected javax.swing.table.TableColumnModel javax.swing.JTable.createDefaultColumnModel()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回默认的列模型对象，它是一个 <code>DefaultTableColumnModel</code>。子类可以重写此方法以返回不同的列模型对象。

@return 默认的列模型对象
@see javax.swing.table.DefaultTableColumnModel

<!-- END DATA -->
<!-- BEGIN KEY -->
protected javax.swing.ListSelectionModel javax.swing.JTable.createDefaultSelectionModel()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回默认的选择模型对象，它是一个 <code>DefaultListSelectionModel</code>。子类可以重写此方法以返回不同的选择模型对象。

@return 默认的选择模型对象
@see javax.swing.DefaultListSelectionModel

<!-- END DATA -->
<!-- BEGIN KEY -->
protected javax.swing.table.JTableHeader javax.swing.JTable.createDefaultTableHeader()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回默认的表标题对象，它是一个 <code>JTableHeader</code>。子类可以重写此方法以返回不同的表标题对象。

@return 默认的表标题对象
@see javax.swing.table.JTableHeader

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void javax.swing.JTable.resizeAndRepaint()
<!-- END KEY -->
<!-- BEGIN DATA -->
等效于先调用 <code>revalidate</code> 再调用 <code>repaint</code>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.table.TableCellEditor javax.swing.JTable.getCellEditor()
<!-- END KEY -->
<!-- BEGIN DATA -->
 返回活动单元格编辑器；如果该表当前没有被编辑，则返回 {@code null}。 

 @return 执行编辑操作的 {@code TableCellEditor}；如果该表当前没有被编辑，则返回 {@code null}。  
 @see #cellEditor
 @see #getCellEditor(int, int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setCellEditor(TableCellEditor anEditor)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置活动单元格编辑器。

@param anEditor  活动单元格编辑器
@see #cellEditor
@beaninfo bound: true description: The table's active cell editor.

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setEditingColumn(int aColumn)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置 <code>editingColumn</code> 变量。
@param aColumn  要编辑的单元格所在的列

@see #editingColumn

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.setEditingRow(int aRow)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置 <code>editingRow</code> 变量。
@param aRow  要编辑的单元格所在的行

@see #editingRow

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.table.TableCellRenderer javax.swing.JTable.getCellRenderer(int row, int column)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回适于由此行和列所指定单元格的渲染器。如果此列的 <code>TableColumn</code> 有一个非 null 的渲染器，则返回它。如果没有，则查找此列中的数据类（使用 <code>getColumnClass</code>），并返回此数据类型的默认渲染器。
 <p>
<b>注：</b>在整个表的包中，内部实现始终使用此方法来提供渲染器，以便子类能够安全地重写此默认行为。

@param row       要呈现的单元格所在的行，其中第一行为 0 
@param column    要呈现的单元格所在的列，其中第一列为 0
@return 已分配的渲染器；如果为 <code>null</code>，则返回此类型对象的默认渲染器
@see javax.swing.table.DefaultTableCellRenderer
@see javax.swing.table.TableColumn#setCellRenderer
@see #setDefaultRenderer

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Component javax.swing.JTable.prepareRenderer(TableCellRenderer renderer, int row, int column)
<!-- END KEY -->
<!-- BEGIN DATA -->
通过查询 <code>row</code>、<code>column</code> 处单元格值的数据模型和单元格选择状态来准备渲染器。返回事件所在的组件（可能是 <code>Component</code> 或 <code>JComponent</code>）。
 <p>
打印操作期间，此方法将配置不指示选择和焦点的渲染器，以防止它们出现在打印输出中。要执行基于该表是否打印的其他定制，可以检查 {@link javax.swing.JComponent#isPaintingForPrint()} 的值（在此处或者在自定义渲染器中）。
 <p>
<b>注：</b>在整个表的包中，内部实现始终使用此方法来准备渲染器，以便子类能够安全地重写此默认行为。

@param renderer  要准备的 <code>TableCellRenderer</code>
@param row       要呈现的单元格所在的行，其中第一行为 0
@param column    要呈现的单元格所在的列，其中第一列为 0
@return    事件所在的 <code>Component</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.table.TableCellEditor javax.swing.JTable.getCellEditor(int row, int column)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回适用于由 <code>row</code> 和 <code>column</code> 所指定单元格的编辑器。如果此列的 <code>TableColumn</code> 有一个非 null 的编辑器，则返回它。如果没有，则查找此列中的数据类（使用 <code>getColumnClass</code>），并返回此类型数据的默认编辑器。
 <p>
<b>注：</b>在整个表的包中，内部实现始终使用此方法来提供编辑器，以便子类能够安全地重写此默认行为。

@param row       要编辑的单元格所在的行，其中第一行为 0
@param column    要编辑的单元格所在的列，其中第一列为 0
@return  此单元格的编辑器；如果为 <code>null</code>，则返回此类型单元格的默认编辑器
@see DefaultCellEditor

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Component javax.swing.JTable.prepareEditor(TableCellEditor editor, int row, int column)
<!-- END KEY -->
<!-- BEGIN DATA -->
通过查询 <code>row</code>、<code>column</code> 处单元格值的数据模型和单元格选择状态来准备编辑器。
 <p>
<b>注：</b>在整个表的包中，内部实现始终使用此方法来准备编辑器，以便子类能够安全地重写此默认行为。

@param editor  要设置的 <code>TableCellEditor</code> 
@param row     要编辑的单元格所在的行，其中第一行为 0
@param column  要编辑的单元格所在的列，其中第一列为 0
@return 被编辑的 <code>Component</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTable.removeEditor()
<!-- END KEY -->
<!-- BEGIN DATA -->
丢弃编辑器对象并释放它用于单元格呈现的资源。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.lang.String javax.swing.JTable.paramString()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此表的字符串表示形式。此方法仅在进行调试的时候使用，对于各个实现，所返回字符串的内容和格式可能有所不同。返回的字符串可以为空，但不可以为 <code>null</code>。

@return  此表的字符串表示形式

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.print() throws java.awt.print.PrinterException
<!-- END KEY -->
<!-- BEGIN DATA -->
一个便捷的方法，它显示一个打印对话框，然后以 <code>PrintMode.FIT_WIDTH</code> 模式打印此 <code>JTable</code>，不打印标题或脚注文本。打印期间将显示一个有模式的进度对话框（带有中止选项）。
 <p>
注：在 headless 模式中，不显示对话框并且打印在默认打印机上进行。

@return 除非用户取消了打印，否则返回 true
@throws SecurityException 如果不允许此线程启动打印作业请求
@throws PrinterException 如果打印系统的错误导致打印作业中止
@see #print(JTable.PrintMode, MessageFormat, MessageFormat, boolean, PrintRequestAttributeSet, boolean, PrintService)
@see #getPrintable

@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.print(JTable.PrintMode printMode) throws java.awt.print.PrinterException
<!-- END KEY -->
<!-- BEGIN DATA -->
一个便捷的方法，它显示一个打印对话框，然后以给定的打印模式打印此 <code>JTable</code>，不打印标题或脚注文本。打印期间将显示一个有模式的进度对话框（带有中止选项）。
 <p>
注：在 headless 模式中，不显示对话框并且打印在默认打印机上进行。

@param  printMode   printable 应使用的打印模式
@return 除非用户取消了打印，否则返回 true
@throws SecurityException 如果不允许此线程启动打印作业请求
@throws PrinterException 如果打印系统的错误导致打印作业中止
@see #print(JTable.PrintMode, MessageFormat, MessageFormat, boolean, PrintRequestAttributeSet, boolean, PrintService)
@see #getPrintable

@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.print(JTable.PrintMode printMode, MessageFormat headerFormat, MessageFormat footerFormat) throws java.awt.print.PrinterException
<!-- END KEY -->
<!-- BEGIN DATA -->
一个便捷的方法，它显示一个打印对话框，然后以给定的打印模式打印此 <code>JTable</code>，打印指定的标题和脚注文本。打印期间将显示一个有模式的进度对话框（带有中止选项）。
 <p>
注：在 headless 模式中，不显示对话框并且打印在默认打印机上进行。

@param  printMode   printable 应使用的打印模式 
@param  headerFormat     指定在打印标题中所用文本的 <code>MessageFormat</code>，如果没有则为 null
@param  footerFormat      指定在打印脚注中所用文本的 <code>MessageFormat</code>，如果没有则为 null
@return 除非用户取消了打印，否则返回 true
@throws SecurityException 如果不允许此线程启动打印作业请求
@throws PrinterException 如果打印系统的错误导致打印作业中止
@see #print(JTable.PrintMode, MessageFormat, MessageFormat, boolean, PrintRequestAttributeSet, boolean, PrintService)
@see #getPrintable

@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.print(JTable.PrintMode printMode, MessageFormat headerFormat, MessageFormat footerFormat, boolean showPrintDialog, PrintRequestAttributeSet attr, boolean interactive) throws java.awt.print.PrinterException, java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
 根据完全功能 {@link #print(JTable.PrintMode, MessageFormat, MessageFormat,
 boolean, PrintRequestAttributeSet, boolean, PrintService) print} 方法的指定打印此表，将默认打印机指定为打印服务。

 @param  printMode        printable 应该使用的打印模式
 @param  headerFormat     指定在打印标题中所用文本的 <code>MessageFormat</code>，如果没有则为 <code>null</code> 
 @param  footerFormat     指定在打印脚注中所用文本的 <code>MessageFormat</code>，如果没有则为 <code>null</code>    
 @param  showPrintDialog  是否显示打印对话框
 @param  attr             指定所有打印属性的 <code>PrintRequestAttributeSet</code>，如果没有则为 <code>null</code>
 @param  interactive      是否以交互模式打印
 @return true，除非用户取消了打印
 @throws HeadlessException 如果要求方法显示打印对话框或交互运行，并且 <code>GraphicsEnvironment.isHeadless</code> 返回 <code>true</code>
 @throws SecurityException 如果不允许此线程启动打印作业请求
 @throws PrinterException 如果打印系统的错误导致打印作业中止
 @see #print(JTable.PrintMode, MessageFormat, MessageFormat,
             boolean, PrintRequestAttributeSet, boolean, PrintService)
 @see #getPrintable

 @since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTable.print(JTable.PrintMode printMode, MessageFormat headerFormat, MessageFormat footerFormat, boolean showPrintDialog, PrintRequestAttributeSet attr, boolean interactive, PrintService service) throws java.awt.print.PrinterException, java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
打印此 <code>JTable</code>。按照大多数开发人员所采取的步骤来打印 <code>JTable</code>。简单地说，它准备表，调用 <code>getPrintable</code> 来获取合适的 <code>Printable</code>，然后将其发送到打印机。
 <p>
<code>boolean</code> 参数允许指定是否向用户显示打印对话框。显示打印对话框时，用户可以使用该对话框更改目标打印机或打印属性，甚至可以取消打印。另外两个参数允许指定 <code>PrintService</code> 和打印属性。这些参数可以用来提供打印对话框的初始值，或者在未显示对话框时指定值。
 <p>
第二个 <code>boolean</code> 参数允许指定是否以交互模式执行打印。如果为 <code>true</code>，则在打印期间将显示一个有模式的进度对话框（带有中止选项）。此对话框还可防止任何可能影响表的用户动作。但是，它不能防止代码对表的修改（例如，另一个线程使用 <code>SwingUtilities.invokeLater</code> 发送更新）。因此，开发人员要负责确保在打印期间没有任何其他代码会以任何方式修改表（无效的修改包括在大小、渲染器或底层数据方面的修改）。如果在打印期间更改了表，则会产生不确定的打印行为。
 <p>
如果将此参数指定为 <code>false</code>，则不显示对话框，打印将立即在事件指派进程上开始。在打印完成前，这将阻塞任何其他事件的处理（包括重新绘制）。尽管这有效地防止了对表的更改，但用户使用起来不是很方便。出于这个原因，建议只在从一个没有可视 GUI 的应用程序打印时才指定 <code>false</code>。
 <p>
注：在 headless 模式下，试图显示打印对话框或交互运行将导致 <code>HeadlessException</code>。
 <p>
获取 printable 前，此方法将会正常地终止编辑（如有必要），以防止编辑器在打印结果中显示。此外，<code>JTable</code> 在未指示选择和焦点的打印期间将准备好其渲染器。至于定制打印输出中表的外观的更多信息，开发人员可以提供自定义渲染器或者条件化 {@link javax.swing.JComponent#isPaintingForPrint()} 值的绘制模式。
 <p>
有关如何打印表的更多描述，请参见 {@link #getPrintable}。

@param  printMode        printable 应使用的打印模式 
@param  headerFormat     指定在打印标题中所用文本的 <code>MessageFormat</code>，如果没有则为 <code>null</code>
@param  footerFormat     指定在打印脚注中所用文本的 <code>MessageFormat</code>，如果没有则为 <code>null</code>
@param  showPrintDialog  是否显示打印对话框
@param  attr  指定任何打印属性的 <code>PrintRequestAttributeSet</code>，如果没有则为 <code>null</code>
@param  interactive  是否以交互模式打印
@param  service          目标 <code>PrintService</code>，或者为 <code>null</code>，表示使用默认打印机 
@return 除非用户取消了打印，否则返回 true
@throws HeadlessException 如果要求方法显示打印对话框或交互运行，并且 <code>GraphicsEnvironment.isHeadless</code> 返回 <code>true</code>
@throws  SecurityException 如果安全管理器存在并且其 {@link java.lang.SecurityManager#checkPrintJobAccess} 方法不允许此线程创建打印作业请求
@throws PrinterException 如果打印系统的错误导致打印作业中止 
@see #getPrintable
@see java.awt.GraphicsEnvironment#isHeadless

@since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.print.Printable javax.swing.JTable.getPrintable(JTable.PrintMode printMode, MessageFormat headerFormat, MessageFormat footerFormat)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回打印此 JTable 中所使用的 <code>Printable</code>。
 <p>
此方法用于希望定制 <code>JTable</code> 的 <code>print</code> 方法所使用的默认 <code>Printable</code> 实现的开发人员。只想打印该表的开发人员应该直接使用其中一个打印方法。 
 <p>
可以在两种打印模式的任意一个内请求 <code>Printable</code>。在这两种模式中，它按顺序自然地将表的各行分散到多个页中，每页放入尽可能多的行。<code>PrintMode.NORMAL</code> 指定表以当前大小打印。在此模式中，可能需要以类似于行的方式将列分散到多页中。需要这样分散时，列以与表的 <code>ComponentOrientation</code> 一致的顺序进行分布。<code>PrintMode.FIT_WIDTH</code> 指定按比例缩小输出（如有必要），以在每页上放入表的整个宽度（凭此放入所有列）。宽度和高度等比例进行缩放，以保持输出的高宽比。
 <p>
<code>Printable</code> 将该表 <code>JTableHeader</code>（如果有）的合适部分作为每页上表部分的标题。
 <p>
可以通过提供 <code>MessageFormat</code> 参数将标题和脚注文本添加到输出中。打印代码根据格式请求 String，提供可以包括在已格式化字符串中的单个项：表示当前页码的 <code>Integer</code>。
 <p>
当某些字符（例如单引号）是特殊字符并需要转义处理时，鼓励阅读 <code>MessageFormat</code> 的文档。
 <p>
以下示例创建一个可用来打印 &quot;Duke's Table Page - &quot; 和当前页码的 <code>MessageFormat</code>：
 <p>
 <pre>
     // notice the escaping of the single quote
     // notice how the page number is included with &quot;{0}&quot;
     MessageFormat format = new MessageFormat(&quot;Duke''s Table: Page - {0}&quot;);
 </pre>
 <p>
<code>Printable</code> 限制向它打印的每一页的可打印区域所绘制的内容。在某些情况下，可能看到该区域不可能放入所有页的内容。在这种情况下，可以截取输出，但实现将采取一些合理的行为。以下是几种已知会发生的情况，以及如何通过此特定实现来处理它们：
 <ul>
<li>在任何模式中，当标题或脚注文本太宽而无法完全放入可打印区域时，从表的起始处（由 <code>ComponentOrientation</code> 确定）开始打印尽可能多的文本。
<li>在任何模式中，当行太高而无法放入可打印区域时，打印行的最上面部分并且不绘制表的下边框。
<li>在 <code>PrintMode.NORMAL</code> 中，当列太宽而无法放入可打印区域时，打印该列的中央部分，不打印表的左右边框。
 </ul>
 <p>
将此 <code>Printable</code> 包装到另一个 Printable 中是完全有效的，这可以用来创建复杂的报告和文档。甚至可以请求将不同的页呈现到不同大小的可打印区域中。必须准备好让实现处理此问题（可能通过其布局计算动态完成）。但是，当必须跨页分散列时，为每页提供不同的高度可能无法与 <code>PrintMode.NORMAL</code> 正常工作。
 <p>
至于定制打印结果中表的外观的信息，<code>JTable</code> 自身将在打印期间负责隐藏选择和焦点。对于其他定制，用户的渲染器或绘制模式可以定制基于 {@link javax.swing.JComponent#isPaintingForPrint()} 值的外观。
 <p>
此外，调用此方法<i>之前</i>，可以<i>首先</i> 修改该表的状态，例如取消单元编辑或者让用户恰当地调整表的大小。但是，在获取此 <code>Printable</code> <i>之后</i>，不得再修改该表的状态（无效的修改包括在大小或底层数据方面的修改）。如果更改了该表，返回 <code>Printable</code> 的行为将是不确定的。

@param  printMode     printable 应使用的打印模式
@param  headerFormat  指定在打印标题中所用文本的 <code>MessageFormat</code>，如果没有则为 null
@param  footerFormat  指定在打印脚注中所用文本的 <code>MessageFormat</code>，如果没有则为 null
@return 用于打印此 JTable 的 <code>Printable</code>
@see #print(JTable.PrintMode, MessageFormat, MessageFormat,
             boolean, PrintRequestAttributeSet, boolean)
@see Printable
@see PrinterJob

@since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.accessibility.AccessibleContext javax.swing.JTable.getAccessibleContext()
<!-- END KEY -->
<!-- BEGIN DATA -->
获取与此 JTable 关联的 AccessibleContext。对于表，AccessibleContext 采用 AccessibleJTable 的形式。必要时创建新的 AccessibleJTable 实例。

@return 一个 AccessibleJTable，它充当此 JTable 的 AccessibleContext

<!-- END DATA -->
<!-- BEGIN KEY -->
private void javax.swing.JTable.writeObject(ObjectOutputStream s) throws java.io.IOException
<!-- END KEY -->
<!-- BEGIN DATA -->
有关 Swing 中序列化的更多信息，请参阅 JComponent 中的 readObject() 和 writeObject()。

<!-- END DATA -->
