<!-- BEGIN KEY -->
public class javax.swing.JTree extends javax.swing.JComponent implements javax.swing.Scrollable, javax.accessibility.Accessible
<!-- END KEY -->
<!-- BEGIN DATA -->
<a name="jtree_description">将分层数据集显示为轮廓的控件。有关面向任务的文档和使用树的示例，请参阅 <em>The Java Tutorial</em> 中的 <a href="http://java.sun.com/docs/books/tutorial/uiswing/components/tree.html">How to Use Trees</a> 一节。
 <p>
树中特定的节点可以由 <code>TreePath</code>（封装节点及其所有祖先的对象）标识，或由其显示行（其中显示区域中的每一行都显示一个节点）标识。<i>展开</i> 节点是一个非叶节点（由返回 false 的 <code>TreeModel.isLeaf(node)</code> 标识），当<i>展开</i> 其所有祖先时，该节点将显示其子节点。<i>折叠</i> 节点是隐藏它们的节点。<i>隐藏</i> 节点是位于折叠祖先下面的节点。所有<i>可查看</i> 节点的父节点都是可以展开的，但是可以显示它们，也可以不显示它们。<i>显示</i> 节点是可查看的并且位于可以看到它的显示区域。
 <p>
以下 <code>JTree</code> 方法使用 &quot;visible&quot; 来表示 &quot;displayed&quot;：
 <ul>
 <li><code>isRootVisible()</code>
 <li><code>setRootVisible()</code>
 <li><code>scrollPathToVisible()</code>
 <li><code>scrollRowToVisible()</code>
 <li><code>getVisibleRowCount()</code>
 <li><code>setVisibleRowCount()</code>
 </ul>
 <p>
下一组 <code>JTree</code> 方法使用 &quot;visible&quot; 表示 &quot;viewable&quot;（在展开的父节点下面）：
 <ul>
 <li><code>isVisible()</code>
 <li><code>makeVisible()</code>
 </ul>
 <p>
如果您有兴趣了解选择何时更改，请实现 <code>TreeSelectionListener</code> 接口，并使用方法 <code>addTreeSelectionListener</code> 添加实例。当选择更改时，将调用 <code>valueChanged</code>，即如果用户在同一节点上单击两次，则仅调用 <code>valueChanged</code> 一次。
 <p>
如果有兴趣检测双击事件或用户何时单击节点（不管是否选中它），建议您执行以下操作：
 <pre>
 final JTree tree = ...;

 MouseListener ml = new MouseAdapter() {
     public void <b>mousePressed</b>(MouseEvent e) {
         int selRow = tree.getRowForLocation(e.getX(), e.getY());
         TreePath selPath = tree.getPathForLocation(e.getX(), e.getY());
         if(selRow != -1) {
             if(e.getClickCount() == 1) {
                 mySingleClick(selRow, selPath);
             }
             else if(e.getClickCount() == 2) {
                 myDoubleClick(selRow, selPath);
             }
         }
     }
 };
 tree.addMouseListener(ml);
 </pre>
注：上述示例同时获取路径和行，但是您只需要获取感兴趣的内容。
 <p>
要使用 <code>JTree</code> 显示复合节点（例如，同时包含图形图标和文本的节点），请为 {@link TreeCellRenderer} 创建子类，并使用 {@link #setCellRenderer} 通知树使用它。要编辑此类节点，请为 {@link TreeCellEditor} 创建子类，并使用 {@link #setCellEditor}。
 <p>
与所有 <code>JComponent</code> 类一样，可以使用 {@link InputMap} 和 {@link ActionMap} 将 {@link Action} 对象与 {@link KeyStroke} 关联，并在指定条件下执行操作。
 <p>
<strong>警告：</strong>Swing 不是线程安全的。有关更多信息，请参阅　<a
 href="package-summary.html#threading">Swing's Threading Policy</a>。
 <p>
<strong>警告：</strong>此类的序列化对象与以后的 Swing 版本不兼容。当前序列化支持适用于短期存储，或适用于在运行相同 Swing 版本的应用程序之间进行 RMI（Remote Method Invocation，远程方法调用）。从 1.4 版本开始，已在 <code>java.beans</code> 包中添加了支持所有 JavaBeans<sup><font size="-2">TM</font></sup> 长期存储的功能。请参见 {@link java.beans.XMLEncoder}。

@beaninfo
   attribute: isContainer false
 description: A component that displays a set of hierarchical data as an outline.

@version 1.176, 07/13/04
@author Rob Davis
@author Ray Ryan
@author Scott Violet

<!-- END DATA -->
<!-- BEGIN KEY -->
protected transient javax.swing.tree.TreeModel javax.swing.JTree.treeModel
<!-- END KEY -->
<!-- BEGIN DATA -->
定义此对象显示的树的模型。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected transient javax.swing.tree.TreeSelectionModel javax.swing.JTree.selectionModel
<!-- END KEY -->
<!-- BEGIN DATA -->
对此树中选择的节点集建模。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected boolean javax.swing.JTree.rootVisible
<!-- END KEY -->
<!-- BEGIN DATA -->
如果显示根节点，则为 true；如果其子节点为最高可见节点，则为 false。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected transient javax.swing.tree.TreeCellRenderer javax.swing.JTree.cellRenderer
<!-- END KEY -->
<!-- BEGIN DATA -->
用于绘制节点的单元格。如果为 <code>null</code>，则 UI 使用默认 <code>cellRenderer</code>。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected int javax.swing.JTree.rowHeight
<!-- END KEY -->
<!-- BEGIN DATA -->
用于每个显示行的高度。如果此高度 &lt;= 0，则渲染器为每个行确定高度。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected boolean javax.swing.JTree.showsRootHandles
<!-- END KEY -->
<!-- BEGIN DATA -->
如果在树的最高层显示句柄，则为 True。
 <p>
句柄是一个小图标，它显示在节点旁边，用户可以单击一次此图标来展开或折叠该节点。公共接口为可以展开的节点显示加号 (+)，为可以折叠的节点显示减号 (-)。节点的句柄始终显示在最高层下面。
 <p>
如果 <code>rootVisible</code> 设置指定将显示根节点，那么该根节点是位于最高层的惟一节点。如果不显示根节点，那么其所有的子节点都位于树的最高层。始终显示节点的句柄，但最高层节点除外。
 <p> 
如果根节点不可见，那么通常最好的方法是将此值设为 true。否则，树看起来很像一个列表，用户可能不知道&ldquo;列表条目&rdquo;实际上就是树节点。

@see #rootVisible

<!-- END DATA -->
<!-- BEGIN KEY -->
protected transient javax.swing.JTree.TreeSelectionRedirector javax.swing.JTree.selectionRedirector
<!-- END KEY -->
<!-- BEGIN DATA -->
创建一个新事件，并将它传递给 <code>selectionListeners</code>。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected transient javax.swing.tree.TreeCellEditor javax.swing.JTree.cellEditor
<!-- END KEY -->
<!-- BEGIN DATA -->
条目编辑器。默认值为 <code>null</code>（树不可编辑）。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected boolean javax.swing.JTree.editable
<!-- END KEY -->
<!-- BEGIN DATA -->
树是否可以编辑？默认值为 false。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected boolean javax.swing.JTree.largeModel
<!-- END KEY -->
<!-- BEGIN DATA -->
此树是否为大模型？这是一种代码优化设置。当单元格高度对于所有节点都相同时，可以使用大模型。然后，UI 将缓存非常少的信息，并改为继续向模型发送消息。在没有大模型的情况下，UI 缓存大部分信息，从而使该模型的方法调用更少。
 <p>
此值仅为 UI 的一个建议值。并不是所有的 UI 都将利用它。默认值为 false。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected int javax.swing.JTree.visibleRowCount
<!-- END KEY -->
<!-- BEGIN DATA -->
一次可见的行数。此值用于 <code>Scrollable</code> 接口。它可以确定显示区域的首选大小。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected boolean javax.swing.JTree.invokesStopCellEditing
<!-- END KEY -->
<!-- BEGIN DATA -->
如果为 true，则在通过更改选择、更改树中的数据或通过其他方法停止编辑时，会调用 <code>stopCellEditing</code>，并保存更改。如果为 false，则调用 <code>cancelCellEditing</code>，并丢弃更改。默认值为 false。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected boolean javax.swing.JTree.scrollsOnExpand
<!-- END KEY -->
<!-- BEGIN DATA -->
如果为 true，则当展开节点时，将滚动尽可能多的子节点，以便看到它们。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected int javax.swing.JTree.toggleClickCount
<!-- END KEY -->
<!-- BEGIN DATA -->
展开节点之前的鼠标单击数。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected transient javax.swing.event.TreeModelListener javax.swing.JTree.treeModelListener
<!-- END KEY -->
<!-- BEGIN DATA -->
更新 <code>expandedState</code>。

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String javax.swing.JTree.CELL_RENDERER_PROPERTY
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>cellRenderer</code> 的绑定属性名称。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String javax.swing.JTree.TREE_MODEL_PROPERTY
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>treeModel</code> 的绑定属性名称。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String javax.swing.JTree.ROOT_VISIBLE_PROPERTY
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>rootVisible</code> 的绑定属性名称。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String javax.swing.JTree.SHOWS_ROOT_HANDLES_PROPERTY
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>showsRootHandles</code> 的绑定属性名称。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String javax.swing.JTree.ROW_HEIGHT_PROPERTY
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>rowHeight</code> 的绑定属性名称。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String javax.swing.JTree.CELL_EDITOR_PROPERTY
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>cellEditor</code> 的绑定属性名称。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String javax.swing.JTree.EDITABLE_PROPERTY
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>editable</code> 的绑定属性名称。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String javax.swing.JTree.LARGE_MODEL_PROPERTY
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>largeModel</code> 的绑定属性名称。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String javax.swing.JTree.SELECTION_MODEL_PROPERTY
<!-- END KEY -->
<!-- BEGIN DATA -->
selectionModel 的绑定属性名称。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String javax.swing.JTree.VISIBLE_ROW_COUNT_PROPERTY
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>visibleRowCount</code> 的绑定属性名称。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String javax.swing.JTree.INVOKES_STOP_CELL_EDITING_PROPERTY
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>messagesStopCellEditing</code> 的绑定属性名称。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String javax.swing.JTree.SCROLLS_ON_EXPAND_PROPERTY
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>scrollsOnExpand</code> 的绑定属性名称。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String javax.swing.JTree.TOGGLE_CLICK_COUNT_PROPERTY
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>toggleClickCount</code> 的绑定属性名称。
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String javax.swing.JTree.LEAD_SELECTION_PATH_PROPERTY
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>leadSelectionPath</code> 的绑定属性名称。
@since 1.3
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String javax.swing.JTree.ANCHOR_SELECTION_PATH_PROPERTY
<!-- END KEY -->
<!-- BEGIN DATA -->
定位选择路径的绑定属性名称。
@since 1.3
<!-- END DATA -->
<!-- BEGIN KEY -->
public static final java.lang.String javax.swing.JTree.EXPANDS_SELECTED_PATHS_PROPERTY
<!-- END KEY -->
<!-- BEGIN DATA -->
展开选择路径属性的绑定属性名称
@since 1.3
<!-- END DATA -->
<!-- BEGIN KEY -->
private javax.swing.tree.TreePath javax.swing.JTree.leadPath
<!-- END KEY -->
<!-- BEGIN DATA -->
前导选择路径，不能为 <code>null</code>。

<!-- END DATA -->
<!-- BEGIN KEY -->
private javax.swing.tree.TreePath javax.swing.JTree.anchorPath
<!-- END KEY -->
<!-- BEGIN DATA -->
定位路径。

<!-- END DATA -->
<!-- BEGIN KEY -->
private boolean javax.swing.JTree.expandsSelectedPaths
<!-- END KEY -->
<!-- BEGIN DATA -->
如果展开选择中的路径，则为 True。

<!-- END DATA -->
<!-- BEGIN KEY -->
private boolean javax.swing.JTree.settingUI
<!-- END KEY -->
<!-- BEGIN DATA -->
对于 <code>setUI</code> 调用的寿命，可以将它设置为 true。

<!-- END DATA -->
<!-- BEGIN KEY -->
private boolean javax.swing.JTree.dragEnabled
<!-- END KEY -->
<!-- BEGIN DATA -->
如果为 true，在选择上按下鼠标，启动拖动操作。
<!-- END DATA -->
<!-- BEGIN KEY -->
private javax.swing.DropMode javax.swing.JTree.dropMode
<!-- END KEY -->
<!-- BEGIN DATA -->
 此组件的放置模式。

<!-- END DATA -->
<!-- BEGIN KEY -->
private int javax.swing.JTree.expandRow
<!-- END KEY -->
<!-- BEGIN DATA -->
 DnD 期间要扩展的行。

<!-- END DATA -->
<!-- BEGIN KEY -->
private javax.swing.JTree.TreeTimer javax.swing.JTree.dropTimer
<!-- END KEY -->
<!-- BEGIN DATA -->
 放置期间要扩展节点的计时器。

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.JTree()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回带有示例模型的 <code>JTree</code>。树使用的默认模型可以将叶节点定义为不带子节点的任何节点。

@see DefaultTreeModel#asksAllowsChildren

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.JTree(java.lang.Object[] value)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>JTree</code>，指定数组的每个元素作为不被显示的新根节点的子节点。默认情况下，树可以将叶节点定义为不带子节点的任何节点。

@param value <code>Object</code> 的数组
@see DefaultTreeModel#asksAllowsChildren

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.JTree(java.util.Vector<?> value)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>JTree</code>，指定 <code>Vector</code> 的每个元素作为不被显示的新根节点的子节点。默认情况下，树可以将叶节点定义为不带子节点的任何节点。

@param value 一个 <code>Vector</code>
@see DefaultTreeModel#asksAllowsChildren

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.JTree(java.util.Hashtable<?, ?> value)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回从 <code>Hashtable</code> 创建的 <code>JTree</code>，它不显示根。<code>HashTable</code> 中每个键/值对的半值都成为新根节点的子节点。默认情况下，树可以将叶节点定义为不带子节点的任何节点。

@param value 一个 <code>Hashtable</code>
@see DefaultTreeModel#asksAllowsChildren

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.JTree(TreeNode root)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>JTree</code>，指定的 <code>TreeNode</code> 作为其根，它显示根节点。默认情况下，树可以将叶节点定义为不带子节点的任何节点。

@param root 一个 <code>TreeNode</code> 对象
@see DefaultTreeModel#asksAllowsChildren

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.JTree(TreeNode root, boolean asksAllowsChildren)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>JTree</code>，指定的 <code>TreeNode</code> 作为其根，它用指定的方式显示根节点，并确定节点是否为叶节点。

@param root 一个 <code>TreeNode</code> 对象
@param asksAllowsChildren  如果为 false，则不带子节点的任何节点都是叶节点；如果为 true，则只有不允许带子节点的节点是叶节点
@see DefaultTreeModel#asksAllowsChildren

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.JTree(TreeModel newModel)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>JTree</code> 的一个实例，它显示根节点 - 使用指定的数据模型创建树。

@param newModel 用作数据模型的 <code>TreeModel</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
protected static javax.swing.tree.TreeModel javax.swing.JTree.getDefaultTreeModel()
<!-- END KEY -->
<!-- BEGIN DATA -->
创建并返回一个示例 <code>TreeModel</code>。主要用于 bean 生成器，来显示一些有趣的东西。

@return 默认 <code>TreeModel</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
protected static javax.swing.tree.TreeModel javax.swing.JTree.createTreeModel(Object value)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回一个 <code>TreeModel</code>，它包装指定的对象。如果该对象为：<ul>
<li>一个 <code>Object</code> 数组
<li>一个 <code>Hashtable</code> 或
<li>一个 <code>Vector</code>
</ul>则创建新的根节点，将传入的每个对象作为子节点。否则，创建新的根，将指定的对象作为其值。

@param value  用作 <code>TreeModel</code> 的基础的 <code>Object</code>
@return 包装指定对象的 <code>TreeModel</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.plaf.TreeUI javax.swing.JTree.getUI()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回呈现此组件的 L&F 对象。

@return 呈现此组件的 <code>TreeUI</code> 对象

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setUI(TreeUI ui)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置呈现此组件的 L&F 对象。

@param ui  <code>TreeUI</code> L&F 对象
@see UIDefaults#getUI
@beaninfo
        bound: true
       hidden: true
    attribute: visualUpdate true
  description: The UI object that implements the Component's LookAndFeel. 

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.updateUI()
<!-- END KEY -->
<!-- BEGIN DATA -->
<code>UIManager</code> 发出的关于 L&F 已经更改的通知。用 <code>UIManager</code> 的最新版本替换当前的 UI 对象。

@see JComponent#updateUI

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String javax.swing.JTree.getUIClassID()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回呈现此组件的 L&F 类的名称。

@return 字符串&ldquo;TreeUI&rdquo;
@see JComponent#getUIClassID
@see UIDefaults#getUI

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.tree.TreeCellRenderer javax.swing.JTree.getCellRenderer()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回正在呈现每个单元格的当前 <code>TreeCellRenderer</code>。

@return 正在呈现每个单元格的 <code>TreeCellRenderer</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setCellRenderer(TreeCellRenderer x)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置将用于绘制每个单元格的 <code>TreeCellRenderer</code>。

@param x  将呈现每个单元格的 <code>TreeCellRenderer</code>
@beaninfo
        bound: true
  description: The TreeCellRenderer that will be used to draw
               each cell.

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setEditable(boolean flag)
<!-- END KEY -->
<!-- BEGIN DATA -->
确定树是否可编辑。如果新设置与现有设置不同，则激发属性更改事件。

@param flag boolean 值，如果树可编辑，则为 true
@beaninfo
        bound: true
  description: Whether the tree is editable.

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.isEditable()
<!-- END KEY -->
<!-- BEGIN DATA -->
如果树可编辑，则返回 true。

@return 如果树可编辑，则返回 true

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setCellEditor(TreeCellEditor cellEditor)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置单元格编辑器。<code>null</code> 值表示树无法编辑。如果这表示 <code>cellEditor</code> 中的一个更改，则在所有侦听器上调用 <code>propertyChange</code> 方法。

@param cellEditor 要使用的 <code>TreeCellEditor</code>
@beaninfo bound: true description: The cell editor.null 值暗示树不能编辑。

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.tree.TreeCellEditor javax.swing.JTree.getCellEditor()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回用于编辑树中条目的编辑器。

@return 使用中的 <code>TreeCellEditor</code>，如果树无法编辑，则返回 <code>null</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.tree.TreeModel javax.swing.JTree.getModel()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回正在提供数据的 <code>TreeModel</code>。

@return 正在提供数据的 <code>TreeModel</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setModel(TreeModel newModel)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置将提供数据的 <code>TreeModel</code>。

@param newModel 将提供数据的 <code>TreeModel</code>
@beaninfo bound: true description: The TreeModel that will provide the data.

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.isRootVisible()
<!-- END KEY -->
<!-- BEGIN DATA -->
如果显示树的根节点，则返回 true。

@return 如果显示树的根节点，则返回 true
@see #rootVisible

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setRootVisible(boolean rootVisible)
<!-- END KEY -->
<!-- BEGIN DATA -->
确定 <code>TreeModel</code> 的根节点是否可见。

@param rootVisible 如果将显示树的根节点，则为 true
@see #rootVisible
@beaninfo
       bound: true
 description: Whether or not the root node from the TreeModel is visible.

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setShowsRootHandles(boolean newValue)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置 <code>showsRootHandles</code> 属性的值，它指定是否应显示节点句柄。此属性的默认值取决于用于创建 <code>JTree</code> 的构造方法。某些外观可能不支持句柄；它们将忽略此属性。

@param newValue 如果显示根句柄，则为 <code>true</code>；否则为 <code>false</code>
@see #showsRootHandles
@see #getShowsRootHandles
@beaninfo bound: true description: Whether the node handles are to be displayed.

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.getShowsRootHandles()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>showsRootHandles</code> 属性的值。
 
@return <code>showsRootHandles</code> 属性的值
@see #showsRootHandles

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setRowHeight(int rowHeight)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置每个单元格的高度（以像素为单位）。如果指定的值小于或等于 0，则会查询当前单元格渲染器以获取每个行的高度。

@param rowHeight 每个单元格的高度（以像素为单位）
@beaninfo
       bound: true
 description: The height of each cell.

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTree.getRowHeight()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回每个行的高度。如果返回的值小于或等于 0，则每个行的高度由渲染器确定。


<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.isFixedRowHeight()
<!-- END KEY -->
<!-- BEGIN DATA -->
如果每个显示行的高度为固定大小，则返回 true。

@return 如果每行的高度为固定大小，则返回 true

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setLargeModel(boolean newValue)
<!-- END KEY -->
<!-- BEGIN DATA -->
指定 UI 是否使用大模型。（并不是所有的 UI 都可以实现这一点。）激发 LARGE_MODEL_PROPERTY 的属性更改。
 
@param newValue 如果 UI 使用大模型，则为 true
@see #largeModel
@beaninfo
      bound: true
description: Whether the UI should use a large model.

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.isLargeModel()
<!-- END KEY -->
<!-- BEGIN DATA -->
如果将树配置为大模型，则返回 true。
 
@return 如果建议使用大模型，则返回 true
@see #largeModel

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setInvokesStopCellEditing(boolean newValue)
<!-- END KEY -->
<!-- BEGIN DATA -->
通过选择树中的另一个节点、树的数据中的更改或通过其他方法来确定编辑被中断时发生了什么情况。将此属性设置为 <code>true</code> 可导致在编辑被中断时自动保存更改。
 <p>
激发 INVOKES_STOP_CELL_EDITING_PROPERTY 的属性更改。

@param newValue true 意味着当编辑中断时，调用 <code>stopCellEditing</code>，并保存数据；false 意味着调用 <code>cancelCellEditing</code>，并丢失更改
@beaninfo
      bound: true
description: 通过选择树中的另一个节点、树的数据的更改或者通过一些其他方法确定编辑中断时发生了什么情况。

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.getInvokesStopCellEditing()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回告知编辑中断时发生了什么情况的指示符。

@return 告知编辑中断时发生了什么情况的指示符
@see #setInvokesStopCellEditing

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setScrollsOnExpand(boolean newValue)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置 <code>scrollsOnExpand</code> 属性，它确定树是否可以滚动显示以前隐藏的子节点。如果此属性为 <code>true</code>（默认值），则当节点展开时，树可以使用滚动来显示该节点的尽可能多的子节点。某些外观中，树在展开时可能不需要滚动；这些外观会忽略此属性。

@param newValue <code>false</code> 表示展开时禁用滚动；<code>true</code> 表示启用滚动
@see #getScrollsOnExpand

@beaninfo
       bound: true
 description: Indicates if a node descendant should be scrolled when expanded.

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.getScrollsOnExpand()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>scrollsOnExpand</code> 属性的值。

@return <code>scrollsOnExpand</code> 属性的值

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setToggleClickCount(int clickCount)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置节点展开或关闭之前鼠标的单击数。默认值为两次。 

@since 1.3
@beaninfo bound: true
    description: Number of clicks before a node will expand/collapse.

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTree.getToggleClickCount()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回展开或关闭节点所需的鼠标单击数。

@return 节点展开之前的鼠标单击数
@since 1.3

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setExpandsSelectedPaths(boolean newValue)
<!-- END KEY -->
<!-- BEGIN DATA -->
配置 <code>expandsSelectedPaths</code> 属性。如果为 true，则在任何时候通过 <code>TreeSelectionModel</code> 或 <code>JTree</code> 提供的覆盖方法更改选择时，将展开 <code>TreePath</code> 的父路径，使它们可见（可见是指父路径不一定在 <code>JTree</code> 的可见矩形内展开）。如果为 false，当选择更改时，节点的父节点不可见（展开的所有父节点）。如果希望使您的选择模型维持并不总是可见的路径（展开的所有父路径），那么这一点非常有用。

@param newValue <code>expandsSelectedPaths</code> 的新值

@since 1.3
@beaninfo bound: true
    description: Indicates whether changes to the selection should make the parent of the path visible.

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.getExpandsSelectedPaths()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>expandsSelectedPaths</code> 属性。
@return 如果选择更改导致父路径展开，则返回 true
@since 1.3
@see #setExpandsSelectedPaths

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setDragEnabled(boolean b)
<!-- END KEY -->
<!-- BEGIN DATA -->
打开或关闭自动拖动处理。要启用自动拖动处理，应将此属性设置为 {@code true}，并且树的 {@code TransferHandler} 必须为非 {@code null}。{@code dragEnabled} 属性的默认值为 {@code false}。
 <p>
遵守此属性以及识别用户拖动动作的工作取决于外观实现，尤其是树的 {@code TreeUI}。启用自动拖动处理时，只要用户在项上按下鼠标按钮，并将鼠标移动几个像素，大多数外观（包括为 {@code BasicLookAndFeel} 创建子类的外观）就会开始拖放操作。因此，将此属性设置为 {@code true} 可以对选择行为产生微妙的影响。
 <p>
如果使用忽略此属性的外观，仍然可以通过在树的 {@code TransferHandler} 上调用 {@code exportAsDrag} 来开始拖放操作。

@param b 是否启用自动拖动处理
@exception HeadlessException 如果 <code>b</code> 为 <code>true</code>，并且 <code>GraphicsEnvironment.isHeadless()</code> 返回 <code>true</code>
@see java.awt.GraphicsEnvironment#isHeadless
@see #getDragEnabled
@see #setTransferHandler
@see TransferHandler
@since 1.4

@beaninfo
 description: determines whether automatic drag handling is enabled
       bound: false

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.getDragEnabled()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回是否启用自动拖动处理。

@return {@code dragEnabled} 属性的值
@see #setDragEnabled
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void javax.swing.JTree.setDropMode(DropMode dropMode)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置此组件的放置模式。为了向后兼容性，此属性的默认值为 <code>DropMode.USE_SELECTION</code>。但是，为了用户使用更方便，建议使用其他模式中的某个模式。例如，<code>DropMode.ON</code> 提供与选择类似的显示项的行为，但执行此操作不会影响树中的实际选择。
 <p>
 <code>JTree</code> 支持以下放置模式：
 <ul>
    <li><code>DropMode.USE_SELECTION</code></li>
    <li><code>DropMode.ON</code></li>
    <li><code>DropMode.INSERT</code></li>
    <li><code>DropMode.ON_OR_INSERT</code></li>
 </ul>
 <p>
只有此组件具有接受放置操作的 <code>TransferHandler</code> 时，该放置模式才是有意义的。

 @param dropMode 要使用的放置模式
 @throws IllegalArgumentException 如果放置模式不受支持或为 <code>null</code>
 @see #getDropMode
 @see #getDropLocation
 @see #setTransferHandler
 @see TransferHandler
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final javax.swing.DropMode javax.swing.JTree.getDropMode()
<!-- END KEY -->
<!-- BEGIN DATA -->
 返回此组件的放置模式。

 @return 此组件的放置模式
 @see #setDropMode
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final javax.swing.JTree.DropLocation javax.swing.JTree.getDropLocation()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回该组件上 DnD 操作期间此组件应该视觉上指示为放置操作的位置；如果当前未显示任何位置，则返回 {@code null}。 
 <p>
此方法不用于从 {@code TransferHandler} 查询放置操作，因为放置操作只有在 {@code TransferHandler} 的 <code>canImport</code> 已返回并允许显示该位置之后才被设置。
 <p>
当此属性更改时，该组件将触发名为 "dropLocation" 的属性更改事件。

 @return 放置位置
 @see #setDropMode
 @see TransferHandler#canImport(TransferHandler.TransferSupport)
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.isPathEditable(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>isEditable</code>。在编辑开始确保给定的路径可以编辑之前，这可以从 UI 调用。这作为子类的入口点提供，以添加经过过滤的编辑，而无需借助于创建新编辑器。

@return 如果每个父节点和节点本身可编辑，则返回 true
@see #isEditable

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String javax.swing.JTree.getToolTipText(MouseEvent event)
<!-- END KEY -->
<!-- BEGIN DATA -->
重写 <code>JComponent</code> 的 <code>getToolTipText</code> 方法，以允许使用渲染器的提示（如果渲染器设置了文本）。
 <p>
注：对于要正确显示其渲染器工具提示的 <code>JTree</code>，<code>JTree</code> 必须是向 <code>ToolTipManager</code> 注册的组件。这可以通过调用 <code>ToolTipManager.sharedInstance().registerComponent(tree)</code> 来完成。它不能自动完成！

@param event 启动 <code>ToolTip</code> 显示的 <code>MouseEvent</code>
@return 包含工具提示的字符串，如果 <code>event</code> 为 null，则返回 <code>null</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String javax.swing.JTree.convertValueToText(Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus)
<!-- END KEY -->
<!-- BEGIN DATA -->
通过渲染器调用以将指定值转换为文本。此实现返回 <code>value.toString</code>，忽略所有其他参数。要控制该转换，则为此方法创建子类，并使用需要的任何参数。
 
@param value 要转换成文本的 <code>Object</code>
@param selected 如果选中节点，则为 true
@param expanded 如果展开节点，则为 true
@param leaf  如果节点是叶节点，则为 true
@param row  指定节点的显示行的整数，其中 0 表示显示的第一行
@param hasFocus 如果节点有焦点，则为 true
@return 节点值的 <code>String</code> 表示形式

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTree.getRowCount()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回当前正在显示的行数。

@return 正在显示的行数

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setSelectionPath(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->

选择指定路径标识的节点。如果隐藏该路径的任何组件（在折叠节点之下），并且 <code>getExpandsSelectedPaths</code> 为 true，则公开它（可查看）。

@param path 指定要选择的节点的 <code>TreePath</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setSelectionPaths(javax.swing.tree.TreePath[] paths)
<!-- END KEY -->
<!-- BEGIN DATA -->

选择由指定的路径数组标识的节点。如果隐藏任何路径中的任何组件（在折叠节点之下），并且 <code>getExpandsSelectedPaths</code> 为 true，则公开它（可查看）。

@param paths 指定要选择的节点的 <code>TreePath</code> 对象数组

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setLeadSelectionPath(TreePath newPath)
<!-- END KEY -->
<!-- BEGIN DATA -->
将标识的路径设置为前导路径。不能选择前导路径。<code>JTree</code> 不维持前导路径，UI 将更新它。

@param newPath  新的前导路径
@since 1.3
@beaninfo bound: true description: Lead selection path

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setAnchorSelectionPath(TreePath newPath)
<!-- END KEY -->
<!-- BEGIN DATA -->
将标识的路径设置为定位路径。<code>JTree</code> 不维持定位路径，UI 将更新它。

@param newPath  新的定位路径
@since 1.3
@beaninfo bound: true description: Anchor selection path

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setSelectionRow(int row)
<!-- END KEY -->
<!-- BEGIN DATA -->
选择显示的指定行的节点。

@param row  要选择的行，其中 0 是显示的第一行

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setSelectionRows(int[] rows)
<!-- END KEY -->
<!-- BEGIN DATA -->
选择与显示的每个指定行对应的节点。如果 <code>rows</code> 的特定元素 &lt; 0 或 &gt;= <code>getRowCount</code>，则它会被忽略。如果 <code>rows</code> 中的元素都不是有效的行，则会清除该选择。这就好像调用 <code>clearSelection</code> 一样。
 
@param rows  指定要选择的行的 int 数组，其中 0 指示显示的第一行

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.addSelectionPath(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
将由指定的 <code>TreePath</code> 标识的节点添加到当前选择。如果路径的所有组件都不可查看，并且 <code>getExpandsSelectedPaths</code> 为 true，则使得其可以查看。
 <p>
注意，<code>JTree</code> 不允许完全相同的节点作为子节点存在于同一父节点之下 - 每个兄弟节点必须是惟一的对象。

@param path 要添加的 <code>TreePath</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.addSelectionPaths(javax.swing.tree.TreePath[] paths)
<!-- END KEY -->
<!-- BEGIN DATA -->
将路径数组中的每个路径添加到当前选择。如果任何路径的所有组件都不可查看，并且 <code>getExpandsSelectedPaths</code> 为 true，则其可以查看。
 <p>
注意，<code>JTree</code> 不允许完全相同的节点作为子节点存在于同一父节点之下 - 每个兄弟节点必须是惟一的对象。

@param paths 指定要添加的节点的 <code>TreePath</code> 对象数组

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.addSelectionRow(int row)
<!-- END KEY -->
<!-- BEGIN DATA -->
将指定行处的路径添加到当前选择。

@param row  指定要添加的节点行的整数，其中 0 表示显示的第一行

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.addSelectionRows(int[] rows)
<!-- END KEY -->
<!-- BEGIN DATA -->
将每个指定行处的路径添加到当前选择。
 
@param rows  指定要添加的行的 int 数组，其中 0 指示显示的第一行

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.Object javax.swing.JTree.getLastSelectedPathComponent()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回当前选择的第一个节点中的最后一个路径组件。

@return 首选节点的 <code>TreePath</code> 中的最后一个 <code>Object</code>，若未选择任何内容，则返回 <code>null</code>
@see TreePath#getLastPathComponent

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.tree.TreePath javax.swing.JTree.getLeadSelectionPath()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回标识为前导的路径。
@return 标识为前导的路径

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.tree.TreePath javax.swing.JTree.getAnchorSelectionPath()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回标识为定位的路径。
@return 标识为定位的路径
@since 1.3

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.tree.TreePath javax.swing.JTree.getSelectionPath()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回首选节点的路径。

@return 首选节点的 <code>TreePath</code>，如果当前未选择任何内容，则返回 <code>null</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.tree.TreePath[] javax.swing.JTree.getSelectionPaths()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回所有选择值的路径。

@return 指示所选节点的 <code>TreePath</code> 对象的数组，如果当前未选择任何内容，则返回 <code>null</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public int[] javax.swing.JTree.getSelectionRows()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回所有当前选择的行。此方法仅转发到 <code>TreeSelectionModel</code>。若未选择任何内容，则返回 <code>null</code> 或一个空数组，具体取决于 <code>TreeSelectionModel</code> 的实现。

@return 标识所有当前选择的行的整数数组，其中 0 表示显示的第一行

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTree.getSelectionCount()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回选择的节点数。

@return 选择的节点数

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTree.getMinSelectionRow()
<!-- END KEY -->
<!-- BEGIN DATA -->
获取选择的第一行。

@return 指定选择的第一行的整数，其中 0 表示显示的第一行

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTree.getMaxSelectionRow()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回选择的最后一行。

@return 指定选择的最后一行的整数，其中 0 表示显示的第一行

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTree.getLeadSelectionRow()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回与前导路径对应的行索引。

@return 提供前导路径的行索引的整数，其中 0 表示显示的第一行；如果 <code>leadPath</code> 为 <code>null</code>，则返回 -1

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.isPathSelected(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果当前选择了路径标识的条目，则返回 true。

@param path 标识节点的 <code>TreePath</code>
@return 如果选择该节点，则返回 true

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.isRowSelected(int row)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果选择了行标识的节点，则返回 true。

@param row  指定一个显示行的整数，其中 0 表示显示的第一行
@return 如果选择该节点，则返回 true

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Enumeration<javax.swing.tree.TreePath> javax.swing.JTree.getExpandedDescendants(TreePath parent)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回当前展开的 <code>parent</code> 路径的子路径的 <code>Enumeration</code>。如果当前没有展开 <code>parent</code>，将返回 <code>null</code>。如果在返回的 <code>Enumeration</code> 上迭代时展开/折叠节点，则不能返回所有展开的路径，或者可能返回不再展开的路径。

@param parent  要检查的路径
@return <code>parent</code> 的子路径的 <code>Enumeration</code>，如果当前没有展开 <code>parent</code>，则返回 <code>null</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.hasBeenExpanded(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果已经展开路径标识的节点，则返回 true。
@return 如果已经展开 <code>path</code>，则返回 true

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.isExpanded(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果当前展开了路径标识的节点，则返回 true。
 
@param path  指定要检查的节点的 <code>TreePath</code>
@return 如果折叠了节点的路径中的任何节点，则返回 false，如果展开了路径中的所有节点，则返回 true

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.isExpanded(int row)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果当前展开了指定显示行处的节点，则返回 true。
 
@param row  要检查的行，其中 0 表示显示的第一行
@return 如果当前展开了节点，则返回 true，否则返回 false

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.isCollapsed(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果当前折叠了路径标识的值，则返回 true，如果当前未显示路径中的任何值，则返回 false。
 
@param path  要检查的 <code>TreePath</code>
@return 如果折叠了节点路径中的任何节点，则返回 true，如果展开了路径中的所有节点，则返回 false

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.isCollapsed(int row)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果折叠了指定显示行处的节点，则返回 true。
 
@param row  要检查的行，其中 0 表示显示的第一行
@return 如果当前折叠节点，则返回 true，否则返回 false

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.makeVisible(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
确保路径标识的节点当前可查看。

@param path  使之可查看的 <code>TreePath</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.isVisible(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
如果当前可查看路径标识的值，则返回 true，这意味着该路径或者是根路径，或者它的所有父路径均被展开。否则，此方法返回 false。 

@return 如果该节点可查看，则返回 true，否则返回 false

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Rectangle javax.swing.JTree.getPathBounds(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回将指定节点绘入的 <code>Rectangle</code>。如果隐藏了路径中的任何组件（在折叠的父路径下），则返回 <code>null</code>。
 <p>
注：<br>此方法返回一个有效的矩形，即使当前不显示指定的节点。

@param path 标识节点的 <code>TreePath</code>
@return 将节点绘入的 <code>Rectangle</code>，或者返回 <code>null</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Rectangle javax.swing.JTree.getRowBounds(int row)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回将指定行处的节点绘入的 <code>Rectangle</code>。

@param row  要绘制的行，其中 0 表示显示的第一行
@return 将节点绘入的 <code>Rectangle</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.scrollPathToVisible(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
确保路径中所有的路径组件均展开（最后一个路径组件除外）并滚动，以便显示该路径标识的节点。仅当此 <code>JTree</code> 包含在 <code>JScrollPane</code> 中时才工作。
 
@param path  标识引入视图的节点的 <code>TreePath</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.scrollRowToVisible(int row)
<!-- END KEY -->
<!-- BEGIN DATA -->
滚动行标识的条目，直到显示出来。执行将行引入视图必需的最小滚动数量。仅当此 <code>JTree</code> 包含在 <code>JScrollPane</code> 中时才工作。

@param row  指定要滚动的行的整数，其中 0 表示显示的第一行

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.tree.TreePath javax.swing.JTree.getPathForRow(int row)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定行的路径。如果 <code>row</code> 不可见，则返回 <code>null</code>。

@param row  指定行的整数
@return 指定节点的 <code>TreePath</code>，如果 <code>row &lt; 0</code> 或 <code>row &gt; getRowCount()</code>，则返回 <code>null</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTree.getRowForPath(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回显示由指定路径标识的节点的行。 
 
@param path  标识节点的 <code>TreePath</code>
@return 指定显示行的整数，其中 0 表示显示的第一行，如果路径中任何元素隐藏在折叠的父路径之下，则返回 -1。

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.expandPath(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
确保指定路径标识的节点展开，并且可查看。如果路径中的最后一项是叶节点，则此方法无效。
 
@param path  标识节点的 <code>TreePath</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.expandRow(int row)
<!-- END KEY -->
<!-- BEGIN DATA -->
确保指定行中的节点展开，并且可查看。
 <p>
如果 <code>row</code> &lt; 0 或 &gt;= <code>getRowCount</code>，则此方法无效。

@param row  指定一个显示行的整数，其中 0 表示显示的第一行

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.collapsePath(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
确保指定路径标识的节点是折叠的，并且可查看。
 
@param path  标识节点的 <code>TreePath</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.collapseRow(int row)
<!-- END KEY -->
<!-- BEGIN DATA -->
确保指定行中的节点是折叠的。
 <p>
如果 <code>row</code> &lt; 0 或 &gt;= <code>getRowCount</code>，则此方法无效。

@param row  指定一个显示行的整数，其中 0 表示显示的第一行

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.tree.TreePath javax.swing.JTree.getPathForLocation(int x, int y)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定位置处的节点路径。

@param x 提供水平像素数的整数，从显示区域左边开始减去左边距
@param y 提供垂直像素数的整数，从显示区域顶部开始减去顶边距
@return  该位置处节点的 <code>TreePath</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTree.getRowForLocation(int x, int y)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回指定位置的行。 

@param x 提供水平像素数的整数，从显示区域左边开始减去左边距
@param y 提供垂直像素数的整数，从显示区域顶部开始减去顶边距
@return 与该位置对应的行，如果该位置不在显示的单元格的边界内，则返回 -1
@see #getClosestRowForLocation

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.tree.TreePath javax.swing.JTree.getClosestPathForLocation(int x, int y)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回离 x,y 最近的节点的路径。如果当前查看不到任何节点，或不存在模型，则返回 <code>null</code>，否则始终返回有效路径。要测试该节点是否正好位于 x, y，请获取该节点的边界，并根据该边界测试 x, y。

@param x 提供水平像素数的整数，从显示区域左边开始减去左边距
@param y 提供垂直像素数的整数，从显示区域顶部开始减去顶边距
@return  最靠近该位置的节点的 <code>TreePath</code>，如果没有可查看内容，或不存在模型，则返回 <code>null</code>

@see #getPathForLocation
@see #getPathBounds

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTree.getClosestRowForLocation(int x, int y)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回离 x,y 最近的节点的行。如果查看不到任何节点，或者不存在模型，则返回 -1。否则始终返回有效的行。要测试返回的对象是否正好位于 x, y，请获取返回行处的节点的边界，并根据该边界测试 x,y。

@param x 提供水平像素数的整数，从显示区域左边开始减去左边距
@param y 提供垂直像素数的整数，从显示区域顶部开始减去顶边距
@return 最靠近该位置的行，如果没有可查看内容或不存在模型，则返回 -1

@see #getRowForLocation
@see #getRowBounds

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.isEditing()
<!-- END KEY -->
<!-- BEGIN DATA -->
如果正在编辑树，则返回 true。使用 <code>getSelectionPath</code> 可以获取正在编辑的项。

@return 如果用户当前正在编辑节点，则返回 true
@see #getSelectionPath

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.stopEditing()
<!-- END KEY -->
<!-- BEGIN DATA -->
结束当前编辑会话。（<code>DefaultTreeCellEditor</code> 对象可以保存当前在单元格上进行的任何编辑。其他实现可以进行不同方式的操作。）如果不编辑树，则没有任何影响。
 <blockquote>
<b>注：</b><br>当用户在树中更改它们的位置时，要使编辑-保存自动化，请使用 {@link #setInvokesStopCellEditing}。
 </blockquote>

@return 如果编辑正在进行中，并且目前已停止，则返回 true，如果编辑不在进行中，则返回 false

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.cancelEditing()
<!-- END KEY -->
<!-- BEGIN DATA -->
取消当前编辑会话。如果不编辑树，则没有任何影响。

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.startEditingAtPath(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
选择指定路径标识的节点，并开始编辑。如果 <code>CellEditor</code> 不允许编辑指定的项，则编辑尝试失败。
 
@param path  标识节点的 <code>TreePath</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.tree.TreePath javax.swing.JTree.getEditingPath()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回当前正在编辑的元素的路径。

@return  正在编辑的节点的 <code>TreePath</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setSelectionModel(TreeSelectionModel selectionModel)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置树的选择模型。若指定 <code>null</code> 值，则使用空 <code>selectionModel</code>，不允许选择。

@param selectionModel 要使用的 <code>TreeSelectionModel</code>，<code>null</code> 表示禁用选择
@see TreeSelectionModel
@beaninfo
       bound: true
 description: The tree's selection model.

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.tree.TreeSelectionModel javax.swing.JTree.getSelectionModel()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回选择的模型。应该始终返回非 <code>null</code> 值。如果您不希望允许选择任何内容，则将选择模型设置为 <code>null</code>，它会强制使用空选择模型。

@see #setSelectionModel

<!-- END DATA -->
<!-- BEGIN KEY -->
protected javax.swing.tree.TreePath[] javax.swing.JTree.getPathBetweenRows(int index0, int index1)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>JTreePath</code> 实例，它表示 index0 和 index1（包括 index1）之间的路径。如果不存在树，则返回 <code>null</code>。

@param index0  指定一个显示行的整数，其中 0 表示显示的第一行
@param index1  指定第二个显示行的整数
@return <code>TreePath</code> 对象的数组（index0 和 index1 之间的每个节点包含一个该对象）；如果不存在树，则返回 <code>null</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setSelectionInterval(int index0, int index1)
<!-- END KEY -->
<!-- BEGIN DATA -->
选择 index0 和 index1（包含）之间的节点。

@param index0  指定一个显示行的整数，其中 0 是显示的第一行
@param index1  指定第二个显示行的整数

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.addSelectionInterval(int index0, int index1)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 index0 和 index1（包含）之间的路径添加到该选择。

@param index0  指定一个显示行的整数，其中 0 是显示的第一行
@param index1  指定第二个显示行的整数

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.removeSelectionInterval(int index0, int index1)
<!-- END KEY -->
<!-- BEGIN DATA -->
从该选择中移除 index0 和 index1（包含）之间的节点。

@param index0  指定一个显示行的整数，其中 0 是显示的第一行
@param index1  指定第二个显示行的整数

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.removeSelectionPath(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
从当前选择中移除指定路径标识的节点。
 
@param path  标识节点的 <code>TreePath</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.removeSelectionPaths(javax.swing.tree.TreePath[] paths)
<!-- END KEY -->
<!-- BEGIN DATA -->
从当前选择移除指定路径标识的节点。

@param paths 指定要移除的节点的 <code>TreePath</code> 对象数组

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.removeSelectionRow(int row)
<!-- END KEY -->
<!-- BEGIN DATA -->
从当前选择移除索引 <code>row</code> 处的行。
 
@param row  要移除的行

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.removeSelectionRows(int[] rows)
<!-- END KEY -->
<!-- BEGIN DATA -->
移除在每个指定行处选择的行。

@param rows  指定显示行的 int 数组，其中 0 表示显示的第一行

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.clearSelection()
<!-- END KEY -->
<!-- BEGIN DATA -->
清除该选择。

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.isSelectionEmpty()
<!-- END KEY -->
<!-- BEGIN DATA -->
如果该选择当前为空，则返回 true。

@return 如果该选择当前为空，则返回 true

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.addTreeExpansionListener(TreeExpansionListener tel)
<!-- END KEY -->
<!-- BEGIN DATA -->
为 <code>TreeExpansion</code> 事件添加侦听器。

@param tel 当展开或折叠（&ldquo;负展开&rdquo;）树节点时，将要通知的 TreeExpansionListener

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.removeTreeExpansionListener(TreeExpansionListener tel)
<!-- END KEY -->
<!-- BEGIN DATA -->
移除 <code>TreeExpansion</code> 事件的侦听器。

@param tel 要移除的 <code>TreeExpansionListener</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.event.TreeExpansionListener[] javax.swing.JTree.getTreeExpansionListeners()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回使用 addTreeExpansionListener() 添加到此 JTree 的所有 <code>TreeExpansionListener</code> 的数组。

@return 添加的所有 <code>TreeExpansionListener</code>，若未添加任何侦听器，则返回空数组
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.addTreeWillExpandListener(TreeWillExpandListener tel)
<!-- END KEY -->
<!-- BEGIN DATA -->
为 <code>TreeWillExpand</code> 事件添加侦听器。

@param tel 当展开或折叠（&ldquo;负展开&rdquo;）树节点时，将要通知的 <code>TreeWillExpandListener</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.removeTreeWillExpandListener(TreeWillExpandListener tel)
<!-- END KEY -->
<!-- BEGIN DATA -->
移除 <code>TreeWillExpand</code> 事件的侦听器。

@param tel 要移除的 <code>TreeWillExpandListener</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.event.TreeWillExpandListener[] javax.swing.JTree.getTreeWillExpandListeners()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回使用 addTreeWillExpandListener() 添加到此 JTree 的所有 <code>TreeWillExpandListener</code> 的数组。

@return 添加的所有 <code>TreeWillExpandListener</code>，若未添加任何侦听器，则返回空数组
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.fireTreeExpanded(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
通知已注册对获得此事件类型通知感兴趣的所有侦听器。使用 <code>path</code> 参数以延迟方式创建事件实例。

@param path 指示展开的节点的 <code>TreePath</code>
@see EventListenerList

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.fireTreeCollapsed(TreePath path)
<!-- END KEY -->
<!-- BEGIN DATA -->
 通知已注册对获得此事件类型通知感兴趣的所有侦听器。使用 <code>path</code> 参数以延迟方式创建事件实例。

@param path 指示折叠的节点的 <code>TreePath</code>
@see EventListenerList

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.fireTreeWillExpand(TreePath path) throws javax.swing.tree.ExpandVetoException
<!-- END KEY -->
<!-- BEGIN DATA -->
通知已注册对获得此事件类型通知感兴趣的所有侦听器。使用 <code>path</code> 参数以延迟方式创建事件实例。

@param path 指示展开的节点的 <code>TreePath</code>
@see EventListenerList

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.fireTreeWillCollapse(TreePath path) throws javax.swing.tree.ExpandVetoException
<!-- END KEY -->
<!-- BEGIN DATA -->
通知已注册对获得此事件类型通知感兴趣的所有侦听器。使用 <code>path</code> 参数以延迟方式创建事件实例。

@param path 指示展开的节点的 <code>TreePath</code>
@see EventListenerList

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.addTreeSelectionListener(TreeSelectionListener tsl)
<!-- END KEY -->
<!-- BEGIN DATA -->
为 <code>TreeSelection</code> 事件添加侦听器。

@param tsl 当选中或取消选中（&ldquo;负选择&rdquo;）节点时，将要通知的 <code>TreeSelectionListener</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.removeTreeSelectionListener(TreeSelectionListener tsl)
<!-- END KEY -->
<!-- BEGIN DATA -->
移除 <code>TreeSelection</code> 侦听器。

@param tsl 要移除的 <code>TreeSelectionListener</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.event.TreeSelectionListener[] javax.swing.JTree.getTreeSelectionListeners()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回使用 addTreeSelectionListener() 添加到此 JTree 的所有 <code>TreeSelectionListener</code> 的数组。

@return 添加的所有 <code>TreeSelectionListener</code>，若未添加任何侦听器，则返回空数组
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void javax.swing.JTree.fireValueChanged(TreeSelectionEvent e)
<!-- END KEY -->
<!-- BEGIN DATA -->
通知已注册对获得此事件类型通知感兴趣的所有侦听器。  

@param e 要激发的 <code>TreeSelectionEvent</code>；当选中或取消选中节点时，由 <code>TreeSelectionModel</code> 生成
@see EventListenerList

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.treeDidChange()
<!-- END KEY -->
<!-- BEGIN DATA -->
当树被更改得足以需要调整边界大小，但还不足以需要移除展开的节点集（例如，展开或折叠节点，或者将节点插入到树）时发送。您从不需要调用它，当需要时，UI 会调用它。

<!-- END DATA -->
<!-- BEGIN KEY -->
public void javax.swing.JTree.setVisibleRowCount(int newCount)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置要显示的行数。仅当树包含在 <code>JScrollPane</code> 中时才工作，并将调整首选大小和该滚动窗格的大小。

@param newCount 要显示的行数
@beaninfo
       bound: true
 description: The number of rows that are to be displayed.

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTree.getVisibleRowCount()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回显示区域中显示的行数。

@return 显示的行数

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.swing.tree.TreePath javax.swing.JTree.getNextMatch(String prefix, int startingRow, Position.Bias bias)
<!-- END KEY -->
<!-- BEGIN DATA -->
将 TreePath 返回到以一个前缀开头的下一个树元素。要处理 <code>TreePath</code> 到字符串的转换，将用到 <code>convertValueToText</code>。

@param prefix 要测试是否匹配的字符串
@param startingRow 用于启动搜索的行
@param bias 搜索方向，Position.Bias.Forward 或 Position.Bias.Backward。
@return 以该前缀开始的下一个树元素的 TreePath；否则返回 null
@exception IllegalArgumentException 如果前缀为 null，或 startingRow 在边界之外
@since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Dimension javax.swing.JTree.getPreferredScrollableViewportSize()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 <code>JTree</code> 的首选显示大小。高度根据 <code>getVisibleRowCount</code> 确定，宽度是当前的首选宽度。

@return 包含首选大小的 <code>Dimension</code> 对象

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTree.getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回滚动时增加的数量。该数量是第一个显示行（不完全在视图中）的高度，如果该行完全显示，那么该数量是滚动方向中下一个行的高度。
 
@param visibleRect 视口中可见的视图区域
@param orientation <code>SwingConstants.VERTICAL</code> 或 <code>SwingConstants.HORIZONTAL</code>
@param direction 小于 0 向上/左滚动，大于 0 向下/右滚动
@return 按指定方向滚动的&ldquo;单位&rdquo;增量
@see JScrollBar#setUnitIncrement(int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public int javax.swing.JTree.getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回块增量的数量，它是基于 <code>orientation</code> 的 <code>visibleRect</code> 高度或宽度。
 
@param visibleRect 视口中可见的视图区域
@param orientation <code>SwingConstants.VERTICAL</code> 或 <code>SwingConstants.HORIZONTAL</code>
@param direction 小于 0 向上/左滚动，大于 0 向下/右滚动。
@return 按指定方向滚动的&ldquo;块&rdquo;增量
@see JScrollBar#setBlockIncrement(int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.getScrollableTracksViewportWidth()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 false 指示视口的宽度不能确定表的宽度，除非树的首选宽度小于视口宽度。换句话说：确保树从不小于其视口。
 
@return false
@see Scrollable#getScrollableTracksViewportWidth

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean javax.swing.JTree.getScrollableTracksViewportHeight()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回 false 指示视口的高度不能确定表的高度，除非树的首选高度小于视口高度。换句话说：确保树从不小于其视口。
 
@return false
@see Scrollable#getScrollableTracksViewportHeight

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void javax.swing.JTree.setExpandedState(TreePath path, boolean state)
<!-- END KEY -->
<!-- BEGIN DATA -->
设置此 <code>JTree</code> 的展开状态。如果 <code>state</code> 为 true，则 <code>path</code> 的所有父路径和路径都被标记为展开。如果 <code>state</code> 为 false，则 <code>path</code> 的所有父路径被标记为展开，但是 <code>path</code> 本身被标记为折叠。<p>
如果 <code>TreeWillExpandListener</code> 禁止它，则会失败。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.util.Enumeration<javax.swing.tree.TreePath> javax.swing.JTree.getDescendantToggledPaths(TreePath parent)
<!-- END KEY -->
<!-- BEGIN DATA -->
返回已展开且为 <code>parent</code> 的子路径的 <code>TreePath</code> 的 <code>Enumeration</code>。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void javax.swing.JTree.removeDescendantToggledPaths(java.util.Enumeration<javax.swing.tree.TreePath> toRemove)
<!-- END KEY -->
<!-- BEGIN DATA -->
移除已展开的 <code>toRemove</code> 中 <code>TreePath</code> 的所有子路径。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void javax.swing.JTree.clearToggledPaths()
<!-- END KEY -->
<!-- BEGIN DATA -->
清除切换的树路径的缓存。这不会发送任何 <code>TreeExpansionListener</code> 事件。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected javax.swing.event.TreeModelListener javax.swing.JTree.createTreeModelListener()
<!-- END KEY -->
<!-- BEGIN DATA -->
创建并返回 <code>TreeModelHandler</code> 的一个实例。返回的对象负责 <code>TreeModel</code> 更改时更新展开的状态。
 <p>
有关展开状态的含义的更多信息，请参阅上述 <a href=#jtree_description>JTree 描述</a>。

<!-- END DATA -->
<!-- BEGIN KEY -->
protected boolean javax.swing.JTree.removeDescendantSelectedPaths(TreePath path, boolean includePath)
<!-- END KEY -->
<!-- BEGIN DATA -->
移除选择中的任何路径（<code>path</code> 的子路径）。如果 <code>includePath</code> 为 true，并且选中 <code>path</code>，则从该选择中移除它。

@return 如果选择子路径，则返回 true
@since 1.3

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.lang.String javax.swing.JTree.paramString()
<!-- END KEY -->
<!-- BEGIN DATA -->
返回此 <code>JTree</code> 的字符串表示形式。此方法仅在进行调试的时候使用，对于各个实现，所返回字符串的内容和格式可能有所不同。返回的字符串可能为空，但不可能为 <code>null</code>。
 
@return  此 <code>JTree</code> 的字符串表示形式。

<!-- END DATA -->
<!-- BEGIN KEY -->
public javax.accessibility.AccessibleContext javax.swing.JTree.getAccessibleContext()
<!-- END KEY -->
<!-- BEGIN DATA -->
获取与此 JTree 关联的 AccessibleContext。对于 JTrees，AccessibleContext 采用 AccessibleJTree 的形式。必要时创建一个新的 AccessibleJTree 实例。

@return 一个 AccessibleJTree，它充当此 JTree 的 AccessibleContext

<!-- END DATA -->
