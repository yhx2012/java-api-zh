<!-- BEGIN KEY -->
javax.print.attribute
<!-- END KEY -->
<!-- BEGIN DATA -->

提供了描述 Java<sup><font size="-2">TM</font></sup> Print Service 属性的类型以及如何分类这些属性的类和接口。
<P>
<H3>什么是属性？</H3>
设置打印作业时，客户端会指定两件事情：<B>打印数据</B>和<B>处理指令</B>。打印数据是要打印的实际内容。处理指令告知打印机如何打印该打印数据，如：使用什么介质，打印多少副本，在纸上是单面打印还是双面打印。客户端使用 Java Print Service API 的属性定义来指定这些处理指令。
<P>
打印数据和处理指令都是独立的实体。这意味着：您可以在不同时间使用不同的处理指令打印同一打印数据。
<ul>
<li> <br> 例如，您可以在美国信函大小的白纸上双面、装订打印 20 张幻灯片演示文稿副本作为演讲的讲义；还可以在美国信函大小的透明介质上单面打印一份相同的幻灯片演示文稿作为演讲的实际幻灯片。
<li>您可以在不同时间使用相同的处理指令打印不同的数据。例如，您可以将默认处理指令设置为：美国信函大小的纸张、双面、装订。每当打印一项作业时，会使用这些设置进行打印，除非显式重写它们。
</ul>
<P>

处理指令不指定打印作业处理该请求的方式；每条处理指令仅是对打印作业结果的描述。打印作业确定实现处理指令所指定结果的方式。将处理指令表示为描述项可为实现打印作业提供更大的灵活性。
<P>
<h4>属性类别和值</h4>
每个打印机都有一组功能，如在不同大小的纸张上打印或打印多个副本。每个功能都有一个范围值。例如，打印机的方向功能可能有以下范围值：[landscape, portrait]。对于每个打印请求，可以将该功能设置为这些值之一。Java Print Service API 使用术语<b>属性类别</b>指打印机功能，使用术语<b>属性值</b>指该功能的值。
<p>
在 Java Print Service API 中，通过实现 <a href="Attribute.html">Attribute</a> 接口的 Java 类来表示属性类别。属性值是这样的类或其某个子类的实例。例如，要指定副本数，应用程序会构造一个具有所需副本数的 <a href="standard/Copies.html">Copies</a> 类的实例，并将 <code>Copies</code> 实例用作打印请求的一部分。在这种情况下，<code>Copies</code> 类表示属性类别，<code>Copies</code> 实例表示属性值。

<h4><a name="role"></a>属性职责</h4>

将打印作业提交给打印机时，客户端将提供描述打印数据特征的属性（如，文档名称），以及应如何打印打印数据（如，双面、五份）。如果打印作业由多部分打印数据组成，则不同部分可能具有不同的处理指令，如将 8 &times; 11 英寸的介质用于第一个文档，11 &times; 17 英寸的介质用于另一个文档。
<p>
打印机开始处理打印作业之后，关于该作业的其他信息将可供使用，可能包括：作业状态（如<i>完成</i> 或<i>排队</i>）和到目前为止已打印的页数。这些信息片段也是属性。属性还可描述打印机本身，如：打印机名称、打印机位置和已排队的作业数。  
<p>

Java Print Service API 使用 <code>Attribute</code> 的五个子接口定义这些不同类型的属性： 
<ul>
<li><A HREF="DocAttribute.html">DocAttribute</A> 指定每个文档的特征和应用到每个文档的打印作业设置。
<li><A HREF="PrintRequestAttribute.html">PrintRequestAttribute</A> 指定应用到整个打印作业和打印作业中所有文档的设置。 
<li><A HREF="PrintJobAttribute.html">PrintJobAttribute</A> 报告打印作业的状态。
<li><A HREF="PrintServiceAttribute.html">PrintServiceAttribute</A> 报告打印服务的状态。
<li><A HREF="SupportedValuesAttribute.html">SupportedValuesAttribute</A> 为另一个属性提供支持的值。
</ul>
每个属性类实现一个或多个这些标记子接口，以指示在 API 中可以使用该属性的位置。如果属性类实现多个标记子接口，则可以在多个上下文中使用该属性。例如，介质属性可以作为 <code>DocAttribute</code> 应用到打印作业中的一个文档，或作为 <code>PrintRequestAttribute</code> 应用到整个打印作业。某些低级别属性从不用于其自身，但是，总是可以将它们汇集到高级别属性中。这此低级别属性类仅实现接口 <A HREF="Attribute.html">Attribute</A>，不能实现任何标记子接口。
<P>
Java Print Service API 定义了一组标准属性类，它可以按照 Internet Printing Protocol (IPP) 版本 1.1 对属性进行建模。标准属性类位于子包 javax.print.attribute.standard 中，目的是保持实际属性类在概念上与包 javax.print.attribute 中定义的一般设备分开。

<H3>属性集</H3>
在提交打印作业时，客户端通常需要提供多个处理指令。例如，客户端可能需要指定大小为 A4 的介质和横向方向。要发送多个处理指令，客户端将属性收集到 Java Print Service API 通过 <a href="AttributeSet.html">AttributeSet</a> 接口所表示的属性集中。
<p>
<code>AttributeSet</code> 接口类似于 <a href="../../../java/util/Map.html">Map</a> 接口：它提供键到值的映射，其中每个键都是唯一的，并且只能包含一个值。但是，<code>AttributeSet</code> 接口设计用于专门支持 Java Print Service API 的需求。<code>AttributeSet</code> 要求：
<OL TYPE=1>
<LI><code>AttributeSet</code> 中的每个键对应于一个类别，键的值只能是属性值之一，它属于该键表示的类别。因此，与 <code>Map</code> 不同，<code>AttributeSet</code> 限制了键的可能值：不能将属性类别设置为不属于该类别的属性值。
<LI>在同一集合中，不能存在同一类别的两个属性。例如，属性集合决不能同时包含&ldquo;单面&rdquo;属性和&ldquo;双面&rdquo;属性，因为这两个属性会导致打印机指令冲突。
<LI>只可以将实现 <code>Attribute</code> 接口的属性添加到该集合。
</OL>

<P>
javax.print.attribute 包中包括了作为属性集接口具体实现的 <A HREF="HashAttributeSet.html">HashAttributeSet</A>。<code>HashAttributeSet</code> 提供基于哈希映射的属性集。您可以使用此实现，或提供自已的接口 <code>AttributeSet</code> 实现。
<p>
Java Print Service API 提供属性集的四个规范，它们限于仅包含四种属性之一，如<a href="#role">属性职责</a>一节所讨论的：
<ul>
<li><A HREF="DocAttributeSet.html">DocAttributeSet</A>
<li><A HREF="PrintRequestAttributeSet.html">PrintRequestAttributeSet</A>
<li><A HREF="PrintJobAttributeSet.html">PrintJobAttributeSet</A>
<li><A HREF="PrintServiceAttributeSet.html">PrintServiceAttributeSet</A>
</ul>
注意，这里仅列出了四种属性集，但是有五种属性。接口 <A HREF="SupportedValuesAttribute.html">SupportedValuesAttribute</A> 表示为另一个属性提供支持值的属性。永远不可能将支持值属性汇集到属性集中，因此不存在为它们定义的属性集子接口。

<P>
在某些上下文中，属性集是只读的，这意味着只允许客户端检查属性集的内容，但不能更改它们。在其他上下文中，属性集是可读写的，这意味着允许客户端检查和更改属性集的内容。对于只读属性集，调用更改操作会抛出 <code>UnmodifiableSetException</code>。 
<P>
包 javax.print.attribute 包括每个属性集子接口的一个具体实现：
<ul>
<li><A HREF="HashDocAttributeSet.html">HashDocAttributeSet</A>
<li><A HREF="HashPrintRequestAttributeSet.html">HashPrintRequestAttributeSet</A>,
<li><A HREF="HashPrintJobAttributeSet.html">HashPrintJobAttributeSet</A>,
<li><A HREF="HashPrintServiceAttributeSet.html">HashPrintServiceAttributeSet</A>.
</ul>
所有这些类都扩展 <A HREF="HashAttributeSet.html">HashAttributeSet</A>，并强制要求只允许属性集包含相应类型属性的限制。
<P>
<H3>属性类设计</H3>
属性值是一个小的原子数据项，如整数或枚举值。Java Print Service API 不使用基本数据类型（如 int）来表示属性值，原因如下：
<ul>
<li>基本数据类型不是类型安全的。例如，编译器不应允许将&ldquo;copies&rdquo;属性值用于&ldquo;sides&rdquo;属性。 
<li>一些属性必须表示为几个值的记录。打印机分辨率就是一个例子，它需要两个数（如，表示 600 &times; 300 dpi 的 600 和 300）。
</ul>
对于类型安全性和要统一表示所有属性，Java Print Service API 将每个属性类别定义为类，如类 <code>Copies</code>、类 <a href="standard/Sides.html">Sides</a> 和 类 <a href="standard/PrinterResolution.html">PrinterResolution</a>。每个属性类可以包装一个或多个包含属性值的基本数据项。属性集操作在添加属性、在同一类别中查找现有属性和查找给定其类别的属性时经常执行属性类别对象之间的比较。因为属性类别由类表示，所以使用 <code>Class.equals</code> 方法可以执行快速的属性值比较。
<p>
尽管 Java Print Service API 包括大量不同的属性类别，但是仅存在很少的不同类型的属性值。大多数属性可由少量数据类型表示，如：整数值、整数范围、文本或整数值的枚举。类别接受的属性值类型称为属性的抽象语法。为了提供一致性并减少代码重复，Java Print Service API 定义了抽象语法类，以表示每个抽象语法，并且只要可能，可以将这些类用作标准属性的父级。抽象语法类是：
<ul>
<li><a href="EnumSyntax.html">EnumSyntax</a> 提供类型安全的枚举，其中枚举值表示为单个对象。每个枚举都是包装隐藏 int 值的枚举类实例。
<li><a href="IntegerSyntax.html">IntegerSyntax</a> 是用于整数值属性的抽象语法。
<li><a href="TextSyntax.html">TextSyntax</a> 是用于文本值属性的抽象语法，并且包括立提供文本字符串的自然语言的语言环境。
<li><a href="SetOfIntegerSyntax.html">SetOfIntegerSyntax</a> 是表示整数范围或整数集的属性的抽象语法。
<li><a href="ResolutionSyntax.html">ResolutionSyntax</a> 是表示分辨率值（如 600&times;300 dpi）的属性的抽象语法。
<li><a href="Size2DSyntax.html">Size2DSyntax</a> 是表示二维大小（如，纸张大小为 8.5 &times; 11 英寸）的属性的抽象语法。
<li><a href="DateTimeSyntax.html">DateTimeSyntax</a> 是其值为日期和时间的属性的抽象语法。
<li><a href="URISyntax.html">URISyntax</a> 是其值为统一资源定位符的属性的抽象语法。
</ul>
抽象语法类独立于使用它们的属性。事实上，与打印无关的应用程序可以使用抽象语法类。虽然多数标准属性类会扩展某个抽象语法类，但不需要任何属性类扩展上述类之一。抽象语法类仅提供许多属性类可以共享的便捷实现。
<p>
每个属性类可以直接或间接实现 <code>Attribute</code> 接口，以便将其标记为打印属性。在某些上下文的限制属性集中出现的属性类也实现 <code>Attribute</code> 的一个或多个子接口。多数属性类也扩展适当的抽象语法类，以获取该实现。考虑 <code>Sides</code> 属性类：
<pre>
<blockquote>
public class Sides
  extends EnumSyntax
  implements DocAttribute, PrintRequestAttribute, PrintJobAttribute
  {
  public final Object getCategory()
    {
    return Sides.class;
    }
  ...
  }
</blockquote>  
</pre>
<p>
由于每个属性类会实现 <code>Attribute</code>，所以每个属性类必须提供返回属性类别的 {@link javax.print.attribute.Attribute#getCategory() getCategory} 方法的实现。对于属性 <code>Sides</code>，<code>getCategory</code> 方法返回 <code>Sides.class</code>。<code>getCategory</code> 方法最终确保了标准属性类的所有供应商定义的子类都显示在同一类别中。每个属性对象在构造之后都是不可变的，这样可以随意地传递属性对象引用。要获取不同的属性值，请构造不同的属性对象。  

<h3>属性供应商</h3>

Java Print Service API 被设计成可让供应商：
<ul>
<li>为 <a href="standard/package-summary.html">javax.print.attribute.standard</a> 中定义的所有标准属性定义新的特定于供应商的值。
<li>定义表示供应商打印机专用功能（标准属性已不支持）的新属性类别。
</ul>
要为属性定义一个新值，客户端可以使用任意值在运行时构造此属性的实例。但是，使用 <code>EnumSyntax</code> 的抽象语法类的枚举属性在编译时将所有的可能属性值指定为属性类的单个实例。这意味着在运行时无法构造新的枚举值。要为标准枚举属性定义新的特定于供应商的值，供应商必须定义一个指定单个新实例的新属性类。要确保新的属性值与标准属性值在相同的类别中，新的属性类必须是标准属性类的子类。
<p>
要定义新的属性类别，供应商需要定义新的属性类。此属性类（与标准属性类类似）实现 <code>Attribute</code> 或其子接口之一，并扩展抽象语法类。供应商可以使用现有的抽象语法类，或者定义新的抽象语法类。无论在哪里（如在 <code>AttributeSet</code> 中）使用 <code>Attribute</code>，都可以使用供应商定义的新属性。

<h3>使用属性</h3>

典型的打印应用程序使用 <code>PrintRequestAttributeSet</code>，因为打印请求属性是客户端通常指定的属性类型。下面的示例介绍如何创建打印请求属性的属性集，并查找可以按照指定的属性打印文档的打印机：
<p>
<pre>
<blockquote>

FileInputStream psStream;
try {
   psstream = new FileInputStream(&quot;file.ps&quot;);
} catch (FileNotFoundException ffne) {
}
if (psstream == null) {
return;
}
//Set the document type.  See the DocFlavor documentation for
//more information.
DocFlavor psInFormat = DocFlavor.INPUT_STREAM.POSTSCRIPT;
Doc myDoc = new SimpleDoc(pstream, psInFormat, null);  
PrintRequestAttributeSet aset = new HashPrintRequestAttributeSet();
aset.add(new Copies(5));
aset.add(MediaSize.A4);
aset.add(Sides.DUPLEX);

PrintService[] services = 
		PrintServiceLookup.lookupPrintServices(psInFormat, aset);
if (services.length &gt; 0) {
   DocPrintJob job = services[0].createPrintJob();
   try {
	job.print(myDoc, aset);
   } catch (PrintException pe) {}
}
</blockquote>
</pre>
<P>
请注意：在 javax.print API 中，只有方法中显式地记录 null 引用具有有意义的解释时，方法的 null 引用参数才是正确的。与之相反的用法是不正确的编码，可能立即或在稍后某一时间导致运行时异常。IllegalArgumentException 和 NullPointerException 是针对这种情况的典型的、可接受的运行时异常的示例。
<P>
@since 1.4

<!-- END DATA -->
