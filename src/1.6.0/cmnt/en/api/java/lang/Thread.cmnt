<!-- BEGIN KEY -->
public class java.lang.Thread extends java.lang.Object implements java.lang.Runnable
<!-- END KEY -->
<!-- BEGIN DATA -->
 A <i>thread</i> is a thread of execution in a program. The Java 
 Virtual Machine allows an application to have multiple threads of 
 execution running concurrently. 
 <p>
 Every thread has a priority. Threads with higher priority are 
 executed in preference to threads with lower priority. Each thread 
 may or may not also be marked as a daemon. When code running in 
 some thread creates a new <code>Thread</code> object, the new 
 thread has its priority initially set equal to the priority of the 
 creating thread, and is a daemon thread if and only if the 
 creating thread is a daemon. 
 <p>
 When a Java Virtual Machine starts up, there is usually a single 
 non-daemon thread (which typically calls the method named 
 <code>main</code> of some designated class). The Java Virtual 
 Machine continues to execute threads until either of the following 
 occurs: 
 <ul>
 <li>The <code>exit</code> method of class <code>Runtime</code> has been 
     called and the security manager has permitted the exit operation 
     to take place. 
 <li>All threads that are not daemon threads have died, either by 
     returning from the call to the <code>run</code> method or by 
     throwing an exception that propagates beyond the <code>run</code>
     method.
 </ul>
 <p>
 There are two ways to create a new thread of execution. One is to 
 declare a class to be a subclass of <code>Thread</code>. This 
 subclass should override the <code>run</code> method of class 
 <code>Thread</code>. An instance of the subclass can then be 
 allocated and started. For example, a thread that computes primes 
 larger than a stated value could be written as follows: 
 <p><hr><blockquote><pre>
     class PrimeThread extends Thread {
         long minPrime;
         PrimeThread(long minPrime) {
             this.minPrime = minPrime;
         }
 
         public void run() {
             // compute primes larger than minPrime
             &nbsp;.&nbsp;.&nbsp;.
         }
     }
 </pre></blockquote><hr>
 <p>
 The following code would then create a thread and start it running: 
 <p><blockquote><pre>
     PrimeThread p = new PrimeThread(143);
     p.start();
 </pre></blockquote>
 <p>
 The other way to create a thread is to declare a class that 
 implements the <code>Runnable</code> interface. That class then 
 implements the <code>run</code> method. An instance of the class can 
 then be allocated, passed as an argument when creating 
 <code>Thread</code>, and started. The same example in this other 
 style looks like the following: 
 <p><hr><blockquote><pre>
     class PrimeRun implements Runnable {
         long minPrime;
         PrimeRun(long minPrime) {
             this.minPrime = minPrime;
         }
 
         public void run() {
             // compute primes larger than minPrime
             &nbsp;.&nbsp;.&nbsp;.
         }
     }
 </pre></blockquote><hr>
 <p>
 The following code would then create a thread and start it running: 
 <p><blockquote><pre>
     PrimeRun p = new PrimeRun(143);
     new Thread(p).start();
 </pre></blockquote>
 <p>
 Every thread has a name for identification purposes. More than 
 one thread may have the same name. If a name is not specified when 
 a thread is created, a new name is generated for it. 

 @author  unascribed
 @version 1.173, 07/13/06
 @see     Runnable
 @see     Runtime#exit(int)
 @see     #run()
 @see     #stop()
 @since   JDK1.0

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.lang.Thread.MIN_PRIORITY
<!-- END KEY -->
<!-- BEGIN DATA -->
 The minimum priority that a thread can have. 

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.lang.Thread.NORM_PRIORITY
<!-- END KEY -->
<!-- BEGIN DATA -->
 The default priority that is assigned to a thread. 

<!-- END DATA -->
<!-- BEGIN KEY -->
public static final int java.lang.Thread.MAX_PRIORITY
<!-- END KEY -->
<!-- BEGIN DATA -->
 The maximum priority that a thread can have. 

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.Thread()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Allocates a new <code>Thread</code> object. This constructor has 
 the same effect as <code>Thread(null, null,</code>
 <i>gname</i><code>)</code>, where <b><i>gname</i></b> is 
 a newly generated name. Automatically generated names are of the 
 form <code>"Thread-"+</code><i>n</i>, where <i>n</i> is an integer. 

 @see     #Thread(ThreadGroup, Runnable, String)

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.Thread(Runnable target)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Allocates a new <code>Thread</code> object. This constructor has 
 the same effect as <code>Thread(null, target,</code>
 <i>gname</i><code>)</code>, where <i>gname</i> is 
 a newly generated name. Automatically generated names are of the 
 form <code>"Thread-"+</code><i>n</i>, where <i>n</i> is an integer. 

 @param   target   the object whose <code>run</code> method is called.
 @see     #Thread(ThreadGroup, Runnable, String)

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.Thread(ThreadGroup group, Runnable target)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Allocates a new <code>Thread</code> object. This constructor has 
 the same effect as <code>Thread(group, target,</code>
 <i>gname</i><code>)</code>, where <i>gname</i> is 
 a newly generated name. Automatically generated names are of the 
 form <code>"Thread-"+</code><i>n</i>, where <i>n</i> is an integer. 

 @param      group    the thread group.
 @param      target   the object whose <code>run</code> method is called.
 @exception  SecurityException  if the current thread cannot create a
             thread in the specified thread group.
 @see        #Thread(ThreadGroup, Runnable, String)

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.Thread(String name)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Allocates a new <code>Thread</code> object. This constructor has 
 the same effect as <code>Thread(null, null, name)</code>. 

 @param   name   the name of the new thread.
 @see     #Thread(ThreadGroup, Runnable, String)

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.Thread(ThreadGroup group, String name)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Allocates a new <code>Thread</code> object. This constructor has 
 the same effect as <code>Thread(group, null, name)</code> 

 @param      group   the thread group.
 @param      name    the name of the new thread.
 @exception  SecurityException  if the current thread cannot create a
               thread in the specified thread group.
 @see        #Thread(ThreadGroup, Runnable, String)

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.Thread(Runnable target, String name)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Allocates a new <code>Thread</code> object. This constructor has 
 the same effect as <code>Thread(null, target, name)</code>. 

 @param   target   the object whose <code>run</code> method is called.
 @param   name     the name of the new thread.
 @see     #Thread(ThreadGroup, Runnable, String)

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.Thread(ThreadGroup group, Runnable target, String name)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Allocates a new <code>Thread</code> object so that it has 
 <code>target</code> as its run object, has the specified 
 <code>name</code> as its name, and belongs to the thread group 
 referred to by <code>group</code>.
 <p>
 If <code>group</code> is <code>null</code> and there is a 
 security manager, the group is determined by the security manager's 
 <code>getThreadGroup</code> method. If <code>group</code> is 
 <code>null</code> and there is not a security manager, or the
 security manager's <code>getThreadGroup</code> method returns 
 <code>null</code>, the group is set to be the same ThreadGroup 
 as the thread that is creating the new thread.
 
 <p>If there is a security manager, its <code>checkAccess</code> 
 method is called with the ThreadGroup as its argument.
 <p>In addition, its <code>checkPermission</code>
 method is called with the
 <code>RuntimePermission("enableContextClassLoaderOverride")</code>
 permission when invoked directly or indirectly by the constructor
 of a subclass which overrides the <code>getContextClassLoader</code>
 or <code>setContextClassLoader</code> methods.
 This may result in a SecurityException.

 <p>
 If the <code>target</code> argument is not <code>null</code>, the 
 <code>run</code> method of the <code>target</code> is called when 
 this thread is started. If the target argument is 
 <code>null</code>, this thread's <code>run</code> method is called 
 when this thread is started. 
 <p>
 The priority of the newly created thread is set equal to the 
 priority of the thread creating it, that is, the currently running 
 thread. The method <code>setPriority</code> may be used to 
 change the priority to a new value. 
 <p>
 The newly created thread is initially marked as being a daemon 
 thread if and only if the thread creating it is currently marked 
 as a daemon thread. The method <code>setDaemon </code> may be used 
 to change whether or not a thread is a daemon. 

 @param      group     the thread group.
 @param      target   the object whose <code>run</code> method is called.
 @param      name     the name of the new thread.
 @exception  SecurityException  if the current thread cannot create a
               thread in the specified thread group or cannot
               override the context class loader methods.
 @see        Runnable#run()
 @see        #run()
 @see        #setDaemon(boolean)
 @see        #setPriority(int)
 @see        ThreadGroup#checkAccess()
 @see        SecurityManager#checkAccess

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.Thread(ThreadGroup group, Runnable target, String name, long stackSize)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Allocates a new <code>Thread</code> object so that it has
 <code>target</code> as its run object, has the specified
 <code>name</code> as its name, belongs to the thread group referred to
 by <code>group</code>, and has the specified <i>stack size</i>.

 <p>This constructor is identical to {@link
 #Thread(ThreadGroup,Runnable,String)} with the exception of the fact
 that it allows the thread stack size to be specified.  The stack size
 is the approximate number of bytes of address space that the virtual
 machine is to allocate for this thread's stack.  <b>The effect of the
 <tt>stackSize</tt> parameter, if any, is highly platform dependent.</b>

 <p>On some platforms, specifying a higher value for the
 <tt>stackSize</tt> parameter may allow a thread to achieve greater
 recursion depth before throwing a {@link StackOverflowError}.
 Similarly, specifying a lower value may allow a greater number of
 threads to exist concurrently without throwing an {@link
 OutOfMemoryError} (or other internal error).  The details of
 the relationship between the value of the <tt>stackSize</tt> parameter
 and the maximum recursion depth and concurrency level are
 platform-dependent.  <b>On some platforms, the value of the
 <tt>stackSize</tt> parameter may have no effect whatsoever.</b>
 
 <p>The virtual machine is free to treat the <tt>stackSize</tt>
 parameter as a suggestion.  If the specified value is unreasonably low
 for the platform, the virtual machine may instead use some
 platform-specific minimum value; if the specified value is unreasonably
 high, the virtual machine may instead use some platform-specific
 maximum.  Likewise, the virtual machine is free to round the specified
 value up or down as it sees fit (or to ignore it completely).

 <p>Specifying a value of zero for the <tt>stackSize</tt> parameter will
 cause this constructor to behave exactly like the
 <tt>Thread(ThreadGroup, Runnable, String)</tt> constructor.

 <p><i>Due to the platform-dependent nature of the behavior of this
 constructor, extreme care should be exercised in its use.
 The thread stack size necessary to perform a given computation will
 likely vary from one JRE implementation to another.  In light of this
 variation, careful tuning of the stack size parameter may be required,
 and the tuning may need to be repeated for each JRE implementation on
 which an application is to run.</i>

 <p>Implementation note: Java platform implementers are encouraged to
 document their implementation's behavior with respect to the
 <tt>stackSize parameter</tt>.

 @param      group    the thread group.
 @param      target   the object whose <code>run</code> method is called.
 @param      name     the name of the new thread.
 @param      stackSize the desired stack size for the new thread, or
             zero to indicate that this parameter is to be ignored.
 @exception  SecurityException  if the current thread cannot create a
               thread in the specified thread group.
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public static native java.lang.Thread java.lang.Thread.currentThread()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns a reference to the currently executing thread object.

 @return  the currently executing thread.

<!-- END DATA -->
<!-- BEGIN KEY -->
public static native void java.lang.Thread.yield()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Causes the currently executing thread object to temporarily pause 
 and allow other threads to execute. 

<!-- END DATA -->
<!-- BEGIN KEY -->
public static native void java.lang.Thread.sleep(long millis) throws java.lang.InterruptedException
<!-- END KEY -->
<!-- BEGIN DATA -->

 Causes the currently executing thread to sleep (temporarily cease 
 execution) for the specified number of milliseconds, subject to 
 the precision and accuracy of system timers and schedulers. The thread 
 does not lose ownership of any monitors.

 @param      millis   the length of time to sleep in milliseconds.
 @exception  InterruptedException if any thread has interrupted
             the current thread.  The <i>interrupted status</i> of the
             current thread is cleared when this exception is thrown.
 @see        Object#notify()

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.lang.Thread.sleep(long millis, int nanos) throws java.lang.InterruptedException
<!-- END KEY -->
<!-- BEGIN DATA -->
 Causes the currently executing thread to sleep (cease execution) 
 for the specified number of milliseconds plus the specified number 
 of nanoseconds, subject to the precision and accuracy of system 
 timers and schedulers. The thread does not lose ownership of any 
 monitors.

 @param      millis   the length of time to sleep in milliseconds.
 @param      nanos    0-999999 additional nanoseconds to sleep.
 @exception  IllegalArgumentException  if the value of millis is 
             negative or the value of nanos is not in the range 
             0-999999.
 @exception  InterruptedException if any thread has interrupted
             the current thread.  The <i>interrupted status</i> of the
             current thread is cleared when this exception is thrown.
 @see        Object#notify()

<!-- END DATA -->
<!-- BEGIN KEY -->
public synchronized void java.lang.Thread.start()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Causes this thread to begin execution; the Java Virtual Machine 
 calls the <code>run</code> method of this thread. 
 <p>
 The result is that two threads are running concurrently: the 
 current thread (which returns from the call to the 
 <code>start</code> method) and the other thread (which executes its 
 <code>run</code> method). 
 <p>
 It is never legal to start a thread more than once.
 In particular, a thread may not be restarted once it has completed
 execution.

 @exception  IllegalThreadStateException  if the thread was already
               started.
 @see        #run()
 @see        #stop()

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.lang.Thread.run()
<!-- END KEY -->
<!-- BEGIN DATA -->
 If this thread was constructed using a separate 
 <code>Runnable</code> run object, then that 
 <code>Runnable</code> object's <code>run</code> method is called; 
 otherwise, this method does nothing and returns. 
 <p>
 Subclasses of <code>Thread</code> should override this method. 

 @see     #start()
 @see     #stop()
 @see     #Thread(ThreadGroup, Runnable, String)

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.lang.Thread.stop()
<!-- END KEY -->
<!-- BEGIN DATA -->

 Forces the thread to stop executing.
 <p>
 If there is a security manager installed, its <code>checkAccess</code>
 method is called with <code>this</code> 
 as its argument. This may result in a 
 <code>SecurityException</code> being raised (in the current thread). 
 <p>
 If this thread is different from the current thread (that is, the current
 thread is trying to stop a thread other than itself), the
 security manager's <code>checkPermission</code> method (with a
 <code>RuntimePermission("stopThread")</code> argument) is called in
 addition.
 Again, this may result in throwing a 
 <code>SecurityException</code> (in the current thread). 
 <p>
 The thread represented by this thread is forced to stop whatever 
 it is doing abnormally and to throw a newly created 
 <code>ThreadDeath</code> object as an exception. 
 <p>
 It is permitted to stop a thread that has not yet been started. 
 If the thread is eventually started, it immediately terminates. 
 <p>
 An application should not normally try to catch 
 <code>ThreadDeath</code> unless it must do some extraordinary 
 cleanup operation (note that the throwing of 
 <code>ThreadDeath</code> causes <code>finally</code> clauses of 
 <code>try</code> statements to be executed before the thread 
 officially dies).  If a <code>catch</code> clause catches a 
 <code>ThreadDeath</code> object, it is important to rethrow the 
 object so that the thread actually dies. 
 <p>
 The top-level error handler that reacts to otherwise uncaught 
 exceptions does not print out a message or otherwise notify the 
 application if the uncaught exception is an instance of 
 <code>ThreadDeath</code>. 

 @exception  SecurityException  if the current thread cannot 
               modify this thread.
 @see        #interrupt()
 @see        #checkAccess()
 @see        #run()
 @see        #start()
 @see        ThreadDeath
 @see        ThreadGroup#uncaughtException(Thread,Throwable)
 @see        SecurityManager#checkAccess(Thread)
 @see        SecurityManager#checkPermission
 @deprecated This method is inherently unsafe.  Stopping a thread with
	     Thread.stop causes it to unlock all of the monitors that it
	     has locked (as a natural consequence of the unchecked
	     <code>ThreadDeath</code> exception propagating up the stack).  If
       any of the objects previously protected by these monitors were in
       an inconsistent state, the damaged objects become visible to
       other threads, potentially resulting in arbitrary behavior.  Many
       uses of <code>stop</code> should be replaced by code that simply
       modifies some variable to indicate that the target thread should
       stop running.  The target thread should check this variable  
       regularly, and return from its run method in an orderly fashion
       if the variable indicates that it is to stop running.  If the
       target thread waits for long periods (on a condition variable,
       for example), the <code>interrupt</code> method should be used to
       interrupt the wait. 
       For more information, see 
       <a href="{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why 
       are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.

<!-- END DATA -->
<!-- BEGIN KEY -->
public final synchronized void java.lang.Thread.stop(Throwable obj)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Forces the thread to stop executing.
 <p>
 If there is a security manager installed, the <code>checkAccess</code>
 method of this thread is called, which may result in a 
 <code>SecurityException</code> being raised (in the current thread). 
 <p>
 If this thread is different from the current thread (that is, the current
 thread is trying to stop a thread other than itself) or
 <code>obj</code> is not an instance of <code>ThreadDeath</code>, the
 security manager's <code>checkPermission</code> method (with the
 <code>RuntimePermission("stopThread")</code> argument) is called in
 addition.
 Again, this may result in throwing a 
 <code>SecurityException</code> (in the current thread). 
 <p>
 If the argument <code>obj</code> is null, a 
 <code>NullPointerException</code> is thrown (in the current thread). 
 <p>
 The thread represented by this thread is forced to stop 
 whatever it is doing abnormally and to throw the 
 <code>Throwable</code> object <code>obj</code> as an exception. This 
 is an unusual action to take; normally, the <code>stop</code> method 
 that takes no arguments should be used. 
 <p>
 It is permitted to stop a thread that has not yet been started. 
 If the thread is eventually started, it immediately terminates. 

 @param      obj   the Throwable object to be thrown.
 @exception  SecurityException  if the current thread cannot modify
               this thread.
 @throws     NullPointerException if obj is <tt>null</tt>.
 @see        #interrupt()
 @see        #checkAccess()
 @see        #run()
 @see        #start()
 @see        #stop()
 @see        SecurityManager#checkAccess(Thread)
 @see        SecurityManager#checkPermission
 @deprecated This method is inherently unsafe.  See {@link #stop()}
        for details.  An additional danger of this
        method is that it may be used to generate exceptions that the
        target thread is unprepared to handle (including checked
        exceptions that the thread could not possibly throw, were it
        not for this method).
        For more information, see 
        <a href="{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why 
        are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.lang.Thread.interrupt()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Interrupts this thread.
 
 <p> Unless the current thread is interrupting itself, which is
 always permitted, the {@link #checkAccess() checkAccess} method
 of this thread is invoked, which may cause a {@link
 SecurityException} to be thrown.

 <p> If this thread is blocked in an invocation of the {@link
 Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link
 Object#wait(long, int) wait(long, int)} methods of the {@link Object}
 class, or of the {@link #join()}, {@link #join(long)}, {@link
 #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)},
 methods of this class, then its interrupt status will be cleared and it
 will receive an {@link InterruptedException}.

 <p> If this thread is blocked in an I/O operation upon an {@link
 java.nio.channels.InterruptibleChannel </code>interruptible
 channel<code>} then the channel will be closed, the thread's interrupt
 status will be set, and the thread will receive a {@link
 java.nio.channels.ClosedByInterruptException}.

 <p> If this thread is blocked in a {@link java.nio.channels.Selector}
 then the thread's interrupt status will be set and it will return
 immediately from the selection operation, possibly with a non-zero
 value, just as if the selector's {@link
 java.nio.channels.Selector#wakeup wakeup} method were invoked.

 <p> If none of the previous conditions hold then this thread's interrupt
 status will be set. </p>

 <p> Interrupting a thread that is not alive need not have any effect.
 
 @throws  SecurityException
          if the current thread cannot modify this thread

 @revised 6.0
 @spec JSR-51

<!-- END DATA -->
<!-- BEGIN KEY -->
public static boolean java.lang.Thread.interrupted()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Tests whether the current thread has been interrupted.  The
 <i>interrupted status</i> of the thread is cleared by this method.  In
 other words, if this method were to be called twice in succession, the
 second call would return false (unless the current thread were
 interrupted again, after the first call had cleared its interrupted
 status and before the second call had examined it).

 <p>A thread interruption ignored because a thread was not alive 
 at the time of the interrupt will be reflected by this method 
 returning false.

 @return  <code>true</code> if the current thread has been interrupted;
          <code>false</code> otherwise.
 @see #isInterrupted()
 @revised 6.0

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.lang.Thread.isInterrupted()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Tests whether this thread has been interrupted.  The <i>interrupted
 status</i> of the thread is unaffected by this method.

 <p>A thread interruption ignored because a thread was not alive 
 at the time of the interrupt will be reflected by this method 
 returning false.

 @return  <code>true</code> if this thread has been interrupted;
          <code>false</code> otherwise.
 @see     #interrupted()
 @revised 6.0

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.lang.Thread.destroy()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Throws {@link NoSuchMethodError}.

 @deprecated This method was originally designed to destroy this
     thread without any cleanup. Any monitors it held would have
     remained locked. However, the method was never implemented.
     If if were to be implemented, it would be deadlock-prone in
     much the manner of {@link #suspend}. If the target thread held
     a lock protecting a critical system resource when it was
     destroyed, no thread could ever access this resource again.
     If another thread ever attempted to lock this resource, deadlock
     would result. Such deadlocks typically manifest themselves as
     "frozen" processes. For more information, see
     <a href="{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">
     Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.
 @throws NoSuchMethodError always

<!-- END DATA -->
<!-- BEGIN KEY -->
public final native boolean java.lang.Thread.isAlive()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Tests if this thread is alive. A thread is alive if it has 
 been started and has not yet died. 

 @return  <code>true</code> if this thread is alive;
          <code>false</code> otherwise.

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.lang.Thread.suspend()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Suspends this thread.
 <p>
 First, the <code>checkAccess</code> method of this thread is called 
 with no arguments. This may result in throwing a 
 <code>SecurityException </code>(in the current thread). 
 <p>
 If the thread is alive, it is suspended and makes no further 
 progress unless and until it is resumed. 

 @exception  SecurityException  if the current thread cannot modify
               this thread.
 @see #checkAccess
 @deprecated   This method has been deprecated, as it is
   inherently deadlock-prone.  If the target thread holds a lock on the
   monitor protecting a critical system resource when it is suspended, no
   thread can access this resource until the target thread is resumed. If
   the thread that would resume the target thread attempts to lock this
   monitor prior to calling <code>resume</code>, deadlock results.  Such
   deadlocks typically manifest themselves as "frozen" processes.
   For more information, see 
   <a href="{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why 
   are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.lang.Thread.resume()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Resumes a suspended thread.
 <p>
 First, the <code>checkAccess</code> method of this thread is called 
 with no arguments. This may result in throwing a 
 <code>SecurityException</code> (in the current thread). 
 <p>
 If the thread is alive but suspended, it is resumed and is 
 permitted to make progress in its execution. 

 @exception  SecurityException  if the current thread cannot modify this
               thread.
 @see        #checkAccess
 @see        #suspend()
 @deprecated This method exists solely for use with {@link #suspend},
     which has been deprecated because it is deadlock-prone.
     For more information, see 
     <a href="{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why 
     are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.lang.Thread.setPriority(int newPriority)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Changes the priority of this thread. 
 <p>
 First the <code>checkAccess</code> method of this thread is called 
 with no arguments. This may result in throwing a 
 <code>SecurityException</code>. 
 <p>
 Otherwise, the priority of this thread is set to the smaller of 
 the specified <code>newPriority</code> and the maximum permitted 
 priority of the thread's thread group. 

 @param newPriority priority to set this thread to
 @exception  IllegalArgumentException  If the priority is not in the
               range <code>MIN_PRIORITY</code> to
               <code>MAX_PRIORITY</code>.
 @exception  SecurityException  if the current thread cannot modify
               this thread.
 @see        #getPriority
 @see        #checkAccess()
 @see        #getThreadGroup()
 @see        #MAX_PRIORITY
 @see        #MIN_PRIORITY
 @see        ThreadGroup#getMaxPriority()

<!-- END DATA -->
<!-- BEGIN KEY -->
public final int java.lang.Thread.getPriority()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns this thread's priority.

 @return  this thread's priority.
 @see     #setPriority

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.lang.Thread.setName(String name)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Changes the name of this thread to be equal to the argument 
 <code>name</code>. 
 <p>
 First the <code>checkAccess</code> method of this thread is called 
 with no arguments. This may result in throwing a 
 <code>SecurityException</code>. 

 @param      name   the new name for this thread.
 @exception  SecurityException  if the current thread cannot modify this
               thread.
 @see        #getName
 @see        #checkAccess()

<!-- END DATA -->
<!-- BEGIN KEY -->
public final java.lang.String java.lang.Thread.getName()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns this thread's name.

 @return  this thread's name.
 @see     #setName(String)

<!-- END DATA -->
<!-- BEGIN KEY -->
public final java.lang.ThreadGroup java.lang.Thread.getThreadGroup()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns the thread group to which this thread belongs. 
 This method returns null if this thread has died
 (been stopped).

 @return  this thread's thread group.

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.lang.Thread.activeCount()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns the number of active threads in the current thread's thread
 group.

 @return  the number of active threads in the current thread's thread
          group.

<!-- END DATA -->
<!-- BEGIN KEY -->
public static int java.lang.Thread.enumerate(java.lang.Thread[] tarray)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Copies into the specified array every active thread in 
 the current thread's thread group and its subgroups. This method simply 
 calls the <code>enumerate</code> method of the current thread's thread 
 group with the array argument. 
 <p>
 First, if there is a security manager, that <code>enumerate</code>
 method calls the security
 manager's <code>checkAccess</code> method 
 with the thread group as its argument. This may result 
 in throwing a <code>SecurityException</code>. 

 @param tarray an array of Thread objects to copy to
 @return  the number of threads put into the array
 @exception  SecurityException  if a security manager exists and its  
             <code>checkAccess</code> method doesn't allow the operation.
 @see     ThreadGroup#enumerate(Thread[])
 @see     SecurityManager#checkAccess(ThreadGroup)

<!-- END DATA -->
<!-- BEGIN KEY -->
public native int java.lang.Thread.countStackFrames()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Counts the number of stack frames in this thread. The thread must 
 be suspended. 

 @return     the number of stack frames in this thread.
 @exception  IllegalThreadStateException  if this thread is not
             suspended.
 @deprecated The definition of this call depends on {@link #suspend},
		   which is deprecated.  Further, the results of this call
		   were never well-defined.

<!-- END DATA -->
<!-- BEGIN KEY -->
public final synchronized void java.lang.Thread.join(long millis) throws java.lang.InterruptedException
<!-- END KEY -->
<!-- BEGIN DATA -->
 Waits at most <code>millis</code> milliseconds for this thread to 
 die. A timeout of <code>0</code> means to wait forever. 

 @param      millis   the time to wait in milliseconds.
 @exception  InterruptedException if any thread has interrupted
             the current thread.  The <i>interrupted status</i> of the
             current thread is cleared when this exception is thrown.

<!-- END DATA -->
<!-- BEGIN KEY -->
public final synchronized void java.lang.Thread.join(long millis, int nanos) throws java.lang.InterruptedException
<!-- END KEY -->
<!-- BEGIN DATA -->
 Waits at most <code>millis</code> milliseconds plus 
 <code>nanos</code> nanoseconds for this thread to die. 

 @param      millis   the time to wait in milliseconds.
 @param      nanos    0-999999 additional nanoseconds to wait.
 @exception  IllegalArgumentException  if the value of millis is negative
               the value of nanos is not in the range 0-999999.
 @exception  InterruptedException if any thread has interrupted
             the current thread.  The <i>interrupted status</i> of the
             current thread is cleared when this exception is thrown.

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.lang.Thread.join() throws java.lang.InterruptedException
<!-- END KEY -->
<!-- BEGIN DATA -->
 Waits for this thread to die. 

 @exception  InterruptedException if any thread has interrupted
             the current thread.  The <i>interrupted status</i> of the
             current thread is cleared when this exception is thrown.

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.lang.Thread.dumpStack()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Prints a stack trace of the current thread to the standard error stream.
 This method is used only for debugging. 

 @see     Throwable#printStackTrace()

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.lang.Thread.setDaemon(boolean on)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Marks this thread as either a daemon thread or a user thread. The 
 Java Virtual Machine exits when the only threads running are all 
 daemon threads. 
 <p>
 This method must be called before the thread is started. 
 <p>
 This method first calls the <code>checkAccess</code> method 
 of this thread 
 with no arguments. This may result in throwing a 
 <code>SecurityException </code>(in the current thread). 

 @param      on   if <code>true</code>, marks this thread as a
                  daemon thread.
 @exception  IllegalThreadStateException  if this thread is active.
 @exception  SecurityException  if the current thread cannot modify
               this thread.
 @see        #isDaemon()
 @see        #checkAccess

<!-- END DATA -->
<!-- BEGIN KEY -->
public final boolean java.lang.Thread.isDaemon()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Tests if this thread is a daemon thread.

 @return  <code>true</code> if this thread is a daemon thread;
          <code>false</code> otherwise.
 @see     #setDaemon(boolean)

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.lang.Thread.checkAccess()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Determines if the currently running thread has permission to 
 modify this thread. 
 <p>
 If there is a security manager, its <code>checkAccess</code> method 
 is called with this thread as its argument. This may result in 
 throwing a <code>SecurityException</code>. 

 @exception  SecurityException  if the current thread is not allowed to
               access this thread.
 @see        SecurityManager#checkAccess(Thread)

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.lang.Thread.toString()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns a string representation of this thread, including the 
 thread's name, priority, and thread group.

 @return  a string representation of this thread.

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.ClassLoader java.lang.Thread.getContextClassLoader()
<!-- END KEY -->
<!-- BEGIN DATA -->

 Returns the context ClassLoader for this Thread. The context
 ClassLoader is provided by the creator of the thread for use
 by code running in this thread when loading classes and resources.
 If not set, the default is the ClassLoader context of the parent
 Thread. The context ClassLoader of the primordial thread is
 typically set to the class loader used to load the application.

 <p>First, if there is a security manager, and the caller's class
 loader is not null and the caller's class loader is not the same as or
 an ancestor of the context class loader for the thread whose
 context class loader is being requested, then the security manager's
 <code>checkPermission</code> 
 method is called with a 
 <code>RuntimePermission("getClassLoader")</code> permission
  to see if it's ok to get the context ClassLoader.. 

 @return the context ClassLoader for this Thread

 @throws SecurityException
        if a security manager exists and its 
        <code>checkPermission</code> method doesn't allow 
        getting the context ClassLoader.
 @see #setContextClassLoader
 @see SecurityManager#checkPermission
 @see RuntimePermission
 
 @since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.lang.Thread.setContextClassLoader(ClassLoader cl)
<!-- END KEY -->
<!-- BEGIN DATA -->

 Sets the context ClassLoader for this Thread. The context
 ClassLoader can be set when a thread is created, and allows
 the creator of the thread to provide the appropriate class loader
 to code running in the thread when loading classes and resources.

 <p>First, if there is a security manager, its <code>checkPermission</code> 
 method is called with a 
 <code>RuntimePermission("setContextClassLoader")</code> permission
  to see if it's ok to set the context ClassLoader.. 

 @param cl the context ClassLoader for this Thread
 
 @exception  SecurityException  if the current thread cannot set the 
 context ClassLoader.
 @see #getContextClassLoader
 @see SecurityManager#checkPermission
 @see RuntimePermission
 
 @since 1.2 

<!-- END DATA -->
<!-- BEGIN KEY -->
public static native boolean java.lang.Thread.holdsLock(Object obj)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns <tt>true</tt> if and only if the current thread holds the
 monitor lock on the specified object.

 <p>This method is designed to allow a program to assert that
 the current thread already holds a specified lock:
 <pre>
     assert Thread.holdsLock(obj);
 </pre>

 @param  obj the object on which to test lock ownership
 @throws NullPointerException if obj is <tt>null</tt>
 @return <tt>true</tt> if the current thread holds the monitor lock on
         the specified object.
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.StackTraceElement[] java.lang.Thread.getStackTrace()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns an array of stack trace elements representing the stack dump
 of this thread.  This method will return a zero-length array if
 this thread has not started or has terminated. 
 If the returned array is of non-zero length then the first element of 
 the array represents the top of the stack, which is the most recent
 method invocation in the sequence.  The last element of the array
 represents the bottom of the stack, which is the least recent method
 invocation in the sequence.

 <p>If there is a security manager, and this thread is not 
 the current thread, then the security manager's 
 <tt>checkPermission</tt> method is called with a 
 <tt>RuntimePermission("getStackTrace")</tt> permission
 to see if it's ok to get the stack trace. 

 <p>Some virtual machines may, under some circumstances, omit one
 or more stack frames from the stack trace.  In the extreme case,
 a virtual machine that has no stack trace information concerning
 this thread is permitted to return a zero-length array from this
 method.  

 @return an array of <tt>StackTraceElement</tt>, 
 each represents one stack frame.

 @throws SecurityException
        if a security manager exists and its 
        <tt>checkPermission</tt> method doesn't allow 
        getting the stack trace of thread.
 @see SecurityManager#checkPermission
 @see RuntimePermission
 @see Throwable#getStackTrace

 @since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.util.Map<java.lang.Thread, java.lang.StackTraceElement[]> java.lang.Thread.getAllStackTraces()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns a map of stack traces for all live threads.
 The map keys are threads and each map value is an array of
 <tt>StackTraceElement</tt> that represents the stack dump
 of the corresponding <tt>Thread</tt>.
 The returned stack traces are in the format specified for
 the {@link #getStackTrace getStackTrace} method.

 <p>The threads may be executing while this method is called.
 The stack trace of each thread only represents a snapshot and
 each stack trace may be obtained at different time.  A zero-length
 array will be returned in the map value if the virtual machine has 
 no stack trace information about a thread.

 <p>If there is a security manager, then the security manager's 
 <tt>checkPermission</tt> method is called with a 
 <tt>RuntimePermission("getStackTrace")</tt> permission as well as
 <tt>RuntimePermission("modifyThreadGroup")</tt> permission
 to see if it is ok to get the stack trace of all threads. 

 @return a <tt>Map</tt> from <tt>Thread</tt> to an array of 
 <tt>StackTraceElement</tt> that represents the stack trace of 
 the corresponding thread.

 @throws SecurityException
        if a security manager exists and its 
        <tt>checkPermission</tt> method doesn't allow 
        getting the stack trace of thread.
 @see #getStackTrace
 @see SecurityManager#checkPermission
 @see RuntimePermission
 @see Throwable#getStackTrace

 @since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public long java.lang.Thread.getId()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns the identifier of this Thread.  The thread ID is a positive
 <tt>long</tt> number generated when this thread was created.  
 The thread ID is unique and remains unchanged during its lifetime.  
 When a thread is terminated, this thread ID may be reused.

 @return this thread's ID.
 @since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.Thread.State java.lang.Thread.getState()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns the state of this thread.
 This method is designed for use in monitoring of the system state,
 not for synchronization control.
 
 @return this thread's state.
 @since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static void java.lang.Thread.setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Set the default handler invoked when a thread abruptly terminates
 due to an uncaught exception, and no other handler has been defined
 for that thread. 

 <p>Uncaught exception handling is controlled first by the thread, then
 by the thread's {@link ThreadGroup} object and finally by the default
 uncaught exception handler. If the thread does not have an explicit
 uncaught exception handler set, and the thread's thread group
 (including parent thread groups)  does not specialize its 
 <tt>uncaughtException</tt> method, then the default handler's
 <tt>uncaughtException</tt> method will be invoked.
 <p>By setting the default uncaught exception handler, an application
 can change the way in which uncaught exceptions are handled (such as
 logging to a specific device, or file) for those threads that would
 already accept whatever &quot;default&quot; behavior the system
 provided.

 <p>Note that the default uncaught exception handler should not usually
 defer to the thread's <tt>ThreadGroup</tt> object, as that could cause
 infinite recursion.

 @param eh the object to use as the default uncaught exception handler.
 If <tt>null</tt> then there is no default handler.

 @throws SecurityException if a security manager is present and it
         denies <tt>{@link RuntimePermission}
         (&quot;setDefaultUncaughtExceptionHandler&quot;)</tt>

 @see #setUncaughtExceptionHandler
 @see #getUncaughtExceptionHandler
 @see ThreadGroup#uncaughtException
 @since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public static java.lang.Thread.UncaughtExceptionHandler java.lang.Thread.getDefaultUncaughtExceptionHandler()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns the default handler invoked when a thread abruptly terminates
 due to an uncaught exception. If the returned value is <tt>null</tt>,
 there is no default.
 @since 1.5
 @see #setDefaultUncaughtExceptionHandler

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.Thread.UncaughtExceptionHandler java.lang.Thread.getUncaughtExceptionHandler()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns the handler invoked when this thread abruptly terminates
 due to an uncaught exception. If this thread has not had an
 uncaught exception handler explicitly set then this thread's
 <tt>ThreadGroup</tt> object is returned, unless this thread
 has terminated, in which case <tt>null</tt> is returned.
 @since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.lang.Thread.setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Set the handler invoked when this thread abruptly terminates
 due to an uncaught exception. 
 <p>A thread can take full control of how it responds to uncaught
 exceptions by having its uncaught exception handler explicitly set.
 If no such handler is set then the thread's <tt>ThreadGroup</tt>
 object acts as its handler.
 @param eh the object to use as this thread's uncaught exception
 handler. If <tt>null</tt> then this thread has no explicit handler.
 @throws  SecurityException  if the current thread is not allowed to
          modify this thread.
 @see #setDefaultUncaughtExceptionHandler
 @see ThreadGroup#uncaughtException
 @since 1.5

<!-- END DATA -->
