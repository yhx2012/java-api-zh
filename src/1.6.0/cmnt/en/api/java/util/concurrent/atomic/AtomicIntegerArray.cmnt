<!-- BEGIN KEY -->
public class java.util.concurrent.atomic.AtomicIntegerArray extends java.lang.Object implements java.io.Serializable
<!-- END KEY -->
<!-- BEGIN DATA -->
 An {@code int} array in which elements may be updated atomically.
 See the {@link java.util.concurrent.atomic} package
 specification for description of the properties of atomic
 variables.
 @since 1.5
 @author Doug Lea

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.concurrent.atomic.AtomicIntegerArray(int length)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Creates a new AtomicIntegerArray of given length.

 @param length the length of the array

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.concurrent.atomic.AtomicIntegerArray(int[] array)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Creates a new AtomicIntegerArray with the same length as, and
 all elements copied from, the given array.

 @param array the array to copy elements from
 @throws NullPointerException if array is null

<!-- END DATA -->
<!-- BEGIN KEY -->
public final int java.util.concurrent.atomic.AtomicIntegerArray.length()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns the length of the array.

 @return the length of the array

<!-- END DATA -->
<!-- BEGIN KEY -->
public final int java.util.concurrent.atomic.AtomicIntegerArray.get(int i)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Gets the current value at position {@code i}.

 @param i the index
 @return the current value

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.util.concurrent.atomic.AtomicIntegerArray.set(int i, int newValue)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Sets the element at position {@code i} to the given value.

 @param i the index
 @param newValue the new value

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.util.concurrent.atomic.AtomicIntegerArray.lazySet(int i, int newValue)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Eventually sets the element at position {@code i} to the given value.

 @param i the index
 @param newValue the new value
 @since 1.6

<!-- END DATA -->
<!-- BEGIN KEY -->
public final int java.util.concurrent.atomic.AtomicIntegerArray.getAndSet(int i, int newValue)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Atomically sets the element at position {@code i} to the given
 value and returns the old value.

 @param i the index
 @param newValue the new value
 @return the previous value

<!-- END DATA -->
<!-- BEGIN KEY -->
public final boolean java.util.concurrent.atomic.AtomicIntegerArray.compareAndSet(int i, int expect, int update)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Atomically sets the element at position {@code i} to the given
 updated value if the current value {@code ==} the expected value.

 @param i the index
 @param expect the expected value
 @param update the new value
 @return true if successful. False return indicates that
 the actual value was not equal to the expected value.

<!-- END DATA -->
<!-- BEGIN KEY -->
public final boolean java.util.concurrent.atomic.AtomicIntegerArray.weakCompareAndSet(int i, int expect, int update)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Atomically sets the element at position {@code i} to the given
 updated value if the current value {@code ==} the expected value.

 <p>May <a href="package-summary.html#Spurious">fail spuriously</a>
 and does not provide ordering guarantees, so is only rarely an
 appropriate alternative to {@code compareAndSet}.

 @param i the index
 @param expect the expected value
 @param update the new value
 @return true if successful.

<!-- END DATA -->
<!-- BEGIN KEY -->
public final int java.util.concurrent.atomic.AtomicIntegerArray.getAndIncrement(int i)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Atomically increments by one the element at index {@code i}.

 @param i the index
 @return the previous value

<!-- END DATA -->
<!-- BEGIN KEY -->
public final int java.util.concurrent.atomic.AtomicIntegerArray.getAndDecrement(int i)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Atomically decrements by one the element at index {@code i}.

 @param i the index
 @return the previous value

<!-- END DATA -->
<!-- BEGIN KEY -->
public final int java.util.concurrent.atomic.AtomicIntegerArray.getAndAdd(int i, int delta)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Atomically adds the given value to the element at index {@code i}.

 @param i the index
 @param delta the value to add
 @return the previous value

<!-- END DATA -->
<!-- BEGIN KEY -->
public final int java.util.concurrent.atomic.AtomicIntegerArray.incrementAndGet(int i)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Atomically increments by one the element at index {@code i}.

 @param i the index
 @return the updated value

<!-- END DATA -->
<!-- BEGIN KEY -->
public final int java.util.concurrent.atomic.AtomicIntegerArray.decrementAndGet(int i)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Atomically decrements by one the element at index {@code i}.

 @param i the index
 @return the updated value

<!-- END DATA -->
<!-- BEGIN KEY -->
public final int java.util.concurrent.atomic.AtomicIntegerArray.addAndGet(int i, int delta)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Atomically adds the given value to the element at index {@code i}.

 @param i the index
 @param delta the value to add
 @return the updated value

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.lang.String java.util.concurrent.atomic.AtomicIntegerArray.toString()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns the String representation of the current values of array.
 @return the String representation of the current values of array.

<!-- END DATA -->
