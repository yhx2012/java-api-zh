<!-- BEGIN KEY -->
public class java.awt.Container extends java.awt.Component
<!-- END KEY -->
<!-- BEGIN DATA -->
 A generic Abstract Window Toolkit(AWT) container object is a component 
 that can contain other AWT components.
 <p>
 Components added to a container are tracked in a list.  The order
 of the list will define the components' front-to-back stacking order 
 within the container.  If no index is specified when adding a
 component to a container, it will be added to the end of the list
 (and hence to the bottom of the stacking order).
 <p>
 <b>Note</b>: For details on the focus subsystem, see
 <a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html">
 How to Use the Focus Subsystem</a>,
 a section in <em>The Java Tutorial</em>, and the
 <a href="../../java/awt/doc-files/FocusSpec.html">Focus Specification</a>
 for more information.

 @version 	1.286, 07/27/06
 @author 	Arthur van Hoff
 @author 	Sami Shaio
 @see       #add(java.awt.Component, int)
 @see       #getComponent(int)
 @see       LayoutManager
 @since     JDK1.0

<!-- END DATA -->
<!-- BEGIN KEY -->
private static final java.io.ObjectStreamField[] java.awt.Container.serialPersistentFields
<!-- END KEY -->
<!-- BEGIN DATA -->
 @serialField ncomponents                     int
       The number of components in this container.
       This value can be null.
 @serialField component                       Component[]
       The components in this container.
 @serialField layoutMgr                       LayoutManager
       Layout manager for this container.
 @serialField dispatcher                      LightweightDispatcher
       Event router for lightweight components.  If this container
       is native, this dispatcher takes care of forwarding and
       retargeting the events to lightweight components contained
       (if any).
 @serialField maxSize                         Dimension
       Maximum size of this Container.
 @serialField focusCycleRoot                  boolean
       Indicates whether this Component is the root of a focus traversal cycle.
       Once focus enters a traversal cycle, typically it cannot leave it via
       focus traversal unless one of the up- or down-cycle keys is pressed.
       Normal traversal is limited to this Container, and all of this
       Container's descendants that are not descendants of inferior focus cycle
       roots.
 @serialField containerSerializedDataVersion  int
       Container Serial Data Version.
 @serialField focusTraversalPolicyProvider    boolean
       Stores the value of focusTraversalPolicyProvider property.

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Container()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Constructs a new Container. Containers can be extended directly, 
 but are lightweight in this case and must be contained by a parent
 somewhere higher up in the component tree that is native.
 (such as Frame for example).

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.awt.Container.getComponentCount()
<!-- END KEY -->
<!-- BEGIN DATA -->

 Gets the number of components in this panel.
 @return    the number of components in this panel.
 @see       #getComponent
 @since     JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.awt.Container.countComponents()
<!-- END KEY -->
<!-- BEGIN DATA -->

 @deprecated As of JDK version 1.1,
 replaced by getComponentCount().

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Component java.awt.Container.getComponent(int n)
<!-- END KEY -->
<!-- BEGIN DATA -->

 Gets the nth component in this container.
 @param      n   the index of the component to get.
 @return     the n<sup>th</sup> component in this container.
 @exception  ArrayIndexOutOfBoundsException  
                 if the n<sup>th</sup> value does not exist.     

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Component[] java.awt.Container.getComponents()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Gets all the components in this container.
 @return    an array of all the components in this container.     

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Insets java.awt.Container.getInsets()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Determines the insets of this container, which indicate the size 
 of the container's border. 
 <p>
 A <code>Frame</code> object, for example, has a top inset that 
 corresponds to the height of the frame's title bar. 
 @return    the insets of this container.
 @see       Insets
 @see       LayoutManager
 @since     JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Insets java.awt.Container.insets()
<!-- END KEY -->
<!-- BEGIN DATA -->
 @deprecated As of JDK version 1.1,
 replaced by <code>getInsets()</code>.

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Component java.awt.Container.add(Component comp)
<!-- END KEY -->
<!-- BEGIN DATA -->

 Appends the specified component to the end of this container. 
 This is a convenience method for {@link #addImpl}.
 <p>
 Note: If a component has been added to a container that
 has been displayed, <code>validate</code> must be
 called on that container to display the new component.
 If multiple components are being added, you can improve
 efficiency by calling <code>validate</code> only once,
 after all the components have been added.

 @param     comp   the component to be added
 @exception NullPointerException if {@code comp} is {@code null}
 @see #addImpl
 @see #validate
 @see javax.swing.JComponent#revalidate()
 @return    the component argument

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Component java.awt.Container.add(String name, Component comp)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Adds the specified component to this container.
 This is a convenience method for {@link #addImpl}.
 <p>
 This method is obsolete as of 1.1.  Please use the
 method <code>add(Component, Object)</code> instead.
 @exception NullPointerException if {@code comp} is {@code null}
 @see #add(Component, Object)

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Component java.awt.Container.add(Component comp, int index)
<!-- END KEY -->
<!-- BEGIN DATA -->

 Adds the specified component to this container at the given 
 position. 
 This is a convenience method for {@link #addImpl}.
 <p>
 Note: If a component has been added to a container that
 has been displayed, <code>validate</code> must be
 called on that container to display the new component.
 If multiple components are being added, you can improve
 efficiency by calling <code>validate</code> only once,
 after all the components have been added.

 @param     comp   the component to be added
 @param     index    the position at which to insert the component, 
                   or <code>-1</code> to append the component to the end
 @exception NullPointerException if {@code comp} is {@code null}
 @exception IllegalArgumentException if {@code index} is invalid (see
            {@link #addImpl} for details)
 @return    the component <code>comp</code>
 @see #addImpl
 @see #remove
 @see #validate
 @see javax.swing.JComponent#revalidate()

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.setComponentZOrder(Component comp, int index)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 <p>
 If the component is a child of some other container, it is 
 removed from that container before being added to this container.
 The important difference between this method and 
 <code>java.awt.Container.add(Component, int)</code> is that this method
 doesn't call <code>removeNotify</code> on the component while 
 removing it from its previous container unless necessary and when 
 allowed by the underlying native windowing system. This way, if the 
 component has the keyboard focus, it maintains the focus when 
 moved to the new position. 
 <p>
 This property is guaranteed to apply only to lightweight
 non-<code>Container</code> components.
 <p>
 <b>Note</b>: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to <code>removeNotify</code>. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

 @param     comp the component to be moved
 @param     index the position in the container's list to
            insert the component, where <code>getComponentCount()</code>
            appends to the end
 @exception NullPointerException if <code>comp</code> is
            <code>null</code>
 @exception IllegalArgumentException if <code>comp</code> is one of the
            container's parents
 @exception IllegalArgumentException if <code>index</code> is not in
            the range <code>[0, getComponentCount()]</code> for moving 
            between containers, or not in the range 
            <code>[0, getComponentCount()-1]</code> for moving inside
            a container
 @exception IllegalArgumentException if adding a container to itself
 @exception IllegalArgumentException if adding a <code>Window</code>
            to a container
 @see #getComponentZOrder(java.awt.Component)
 @since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public int java.awt.Container.getComponentZOrder(Component comp)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns the z-order index of the component inside the container. 
 The higher a component is in the z-order hierarchy, the lower
 its index.  The component with the lowest z-order index is
 painted last, above all other child components.

 @param comp the component being queried
 @return  the z-order index of the component; otherwise 
          returns -1 if the component is <code>null</code>
          or doesn't belong to the container 
 @see #setComponentZOrder(java.awt.Component, int)
 @since 1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.add(Component comp, Object constraints)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Adds the specified component to the end of this container.
 Also notifies the layout manager to add the component to 
 this container's layout using the specified constraints object.
 This is a convenience method for {@link #addImpl}.
 <p>
 Note: If a component has been added to a container that
 has been displayed, <code>validate</code> must be
 called on that container to display the new component.
 If multiple components are being added, you can improve
 efficiency by calling <code>validate</code> only once,
 after all the components have been added.

 @param     comp the component to be added
 @param     constraints an object expressing 
                  layout contraints for this component
 @exception NullPointerException if {@code comp} is {@code null}
 @see #addImpl
 @see #validate
 @see javax.swing.JComponent#revalidate()
 @see       LayoutManager
 @since     JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.add(Component comp, Object constraints, int index)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Adds the specified component to this container with the specified
 constraints at the specified index.  Also notifies the layout 
 manager to add the component to the this container's layout using 
 the specified constraints object.
 This is a convenience method for {@link #addImpl}.
 <p>
 Note: If a component has been added to a container that
 has been displayed, <code>validate</code> must be
 called on that container to display the new component.
 If multiple components are being added, you can improve
 efficiency by calling <code>validate</code> only once,
 after all the components have been added.

 @param comp the component to be added
 @param constraints an object expressing layout contraints for this
 @param index the position in the container's list at which to insert
 the component; <code>-1</code> means insert at the end
 component
 @exception NullPointerException if {@code comp} is {@code null}
 @exception IllegalArgumentException if {@code index} is invalid (see
            {@link #addImpl} for details)
 @see #addImpl
 @see #validate
 @see javax.swing.JComponent#revalidate()
 @see #remove
 @see LayoutManager

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void java.awt.Container.addImpl(Component comp, Object constraints, int index)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Adds the specified component to this container at the specified
 index. This method also notifies the layout manager to add 
 the component to this container's layout using the specified 
 constraints object via the <code>addLayoutComponent</code>
 method.
 <p>
 The constraints are
 defined by the particular layout manager being used.  For 
 example, the <code>BorderLayout</code> class defines five
 constraints: <code>BorderLayout.NORTH</code>,
 <code>BorderLayout.SOUTH</code>, <code>BorderLayout.EAST</code>,
 <code>BorderLayout.WEST</code>, and <code>BorderLayout.CENTER</code>.
 <p>
 The <code>GridBagLayout</code> class requires a
 <code>GridBagConstraints</code> object.  Failure to pass
 the correct type of constraints object results in an
 <code>IllegalArgumentException</code>.
 <p>
 If the current layout manager implements {@code LayoutManager2}, then
 {@link LayoutManager2#addLayoutComponent(Component,Object)} is invoked on
 it. If the current layout manager does not implement
 {@code LayoutManager2}, and constraints is a {@code String}, then
 {@link LayoutManager#addLayoutComponent(String,Component)} is invoked on it.
 <p>
 If the component is not an ancestor of this container and has a non-null
 parent, it is removed from its current parent before it is added to this
 container.
 <p>
 This is the method to override if a program needs to track 
 every add request to a container as all other add methods defer
 to this one. An overriding method should 
 usually include a call to the superclass's version of the method:
 <p>
 <blockquote>
 <code>super.addImpl(comp, constraints, index)</code>
 </blockquote>
 <p>
 @param     comp       the component to be added
 @param     constraints an object expressing layout constraints 
                 for this component
 @param     index the position in the container's list at which to
                 insert the component, where <code>-1</code> 
                 means append to the end
 @exception IllegalArgumentException if {@code index} is invalid;
            if {@code comp} is a child of this container, the valid
            range is {@code [-1, getComponentCount()-1]}; if component is
            not a child of this container, the valid range is 
            {@code [-1, getComponentCount()]}

 @exception IllegalArgumentException if {@code comp} is an ancestor of
                                     this container
 @exception IllegalArgumentException if adding a window to a container
 @exception NullPointerException if {@code comp} is {@code null}
 @see       #add(Component)       
 @see       #add(Component, int)       
 @see       #add(Component, java.lang.Object)       
 @see       LayoutManager
 @see       LayoutManager2
 @since     JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.remove(int index)
<!-- END KEY -->
<!-- BEGIN DATA -->

 Removes the component, specified by <code>index</code>, 
 from this container. 
 This method also notifies the layout manager to remove the
 component from this container's layout via the
 <code>removeLayoutComponent</code> method.

 <p>
 Note: If a component has been removed from a container that
 had been displayed, {@link #validate} must be
 called on that container to reflect changes.
 If multiple components are being removed, you can improve
 efficiency by calling {@link #validate} only once,
 after all the components have been removed.

 @param     index   the index of the component to be removed
 @throws ArrayIndexOutOfBoundsException if {@code index} is not in
         range {@code [0, getComponentCount()-1]}
 @see #add
 @see #validate
 @see #getComponentCount
 @since JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.remove(Component comp)
<!-- END KEY -->
<!-- BEGIN DATA -->

 Removes the specified component from this container.
 This method also notifies the layout manager to remove the
 component from this container's layout via the
 <code>removeLayoutComponent</code> method.

 <p>
 Note: If a component has been removed from a container that
 had been displayed, {@link #validate} must be
 called on that container to reflect changes.
 If multiple components are being removed, you can improve
 efficiency by calling {@link #validate} only once,
 after all the components have been removed.

 @param comp the component to be removed
 @see #add
 @see #validate
 @see #remove(int)

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.removeAll()
<!-- END KEY -->
<!-- BEGIN DATA -->

 Removes all the components from this container.
 This method also notifies the layout manager to remove the
 components from this container's layout via the
 <code>removeLayoutComponent</code> method.
 @see #add
 @see #remove

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.LayoutManager java.awt.Container.getLayout()
<!-- END KEY -->
<!-- BEGIN DATA -->

 Gets the layout manager for this container.  
 @see #doLayout
 @see #setLayout

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.setLayout(LayoutManager mgr)
<!-- END KEY -->
<!-- BEGIN DATA -->

 Sets the layout manager for this container.
 @param mgr the specified layout manager
 @see #doLayout
 @see #getLayout

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.doLayout()
<!-- END KEY -->
<!-- BEGIN DATA -->

 Causes this container to lay out its components.  Most programs 
 should not call this method directly, but should invoke 
 the <code>validate</code> method instead.
 @see LayoutManager#layoutContainer
 @see #setLayout
 @see #validate
 @since JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.layout()
<!-- END KEY -->
<!-- BEGIN DATA -->

 @deprecated As of JDK version 1.1,
 replaced by <code>doLayout()</code>.

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.invalidate()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Invalidates the container.  The container and all parents
 above it are marked as needing to be laid out.  This method can
 be called often, so it needs to execute quickly.

 <p> If the {@code LayoutManager} installed on this container is
 an instance of {@code LayoutManager2}, then
 {@link LayoutManager2#invalidateLayout(Container)} is invoked on
 it supplying this {@code Container} as the argument.

 @see #validate
 @see #layout
 @see LayoutManager
 @see LayoutManager2#invalidateLayout(Container)

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.validate()
<!-- END KEY -->
<!-- BEGIN DATA -->

 Validates this container and all of its subcomponents.
 <p>
 The <code>validate</code> method is used to cause a container
 to lay out its subcomponents again. It should be invoked when
 this container's subcomponents are modified (added to or
 removed from the container, or layout-related information
 changed) after the container has been displayed.

 <p>If this {@code Container} is not valid, this method invokes
 the {@code validateTree} method and marks this {@code Container}
 as valid. Otherwise, no action is performed.

 @see #add(java.awt.Component)
 @see Component#invalidate
 @see javax.swing.JComponent#revalidate()
 @see #validateTree

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void java.awt.Container.validateTree()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Recursively descends the container tree and recomputes the
 layout for any subtrees marked as needing it (those marked as
 invalid).  Synchronization should be provided by the method
 that calls this one:  <code>validate</code>.

 @see #doLayout
 @see #validate

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.setFont(Font f)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Sets the font of this container.
 @param f The font to become this container's font.
 @see Component#getFont
 @since JDK1.0

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Dimension java.awt.Container.getPreferredSize()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns the preferred size of this container.  If the preferred size has
 not been set explicitly by {@link Component#setPreferredSize(Dimension)}
 and this {@code Container} has a {@code non-null} {@link LayoutManager},
 then {@link LayoutManager#preferredLayoutSize(Container)}
 is used to calculate the preferred size.

 <p>Note: some implementations may cache the value returned from the
 {@code LayoutManager}.  Implementations that cache need not invoke
 {@code preferredLayoutSize} on the {@code LayoutManager} every time
 this method is invoked, rather the {@code LayoutManager} will only
 be queried after the {@code Container} becomes invalid.

 @return    an instance of <code>Dimension</code> that represents
                the preferred size of this container.
 @see       #getMinimumSize
 @see       #getMaximumSize
 @see       #getLayout
 @see       LayoutManager#preferredLayoutSize(Container)
 @see       Component#getPreferredSize

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Dimension java.awt.Container.preferredSize()
<!-- END KEY -->
<!-- BEGIN DATA -->

 @deprecated As of JDK version 1.1,
 replaced by <code>getPreferredSize()</code>.

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Dimension java.awt.Container.getMinimumSize()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns the minimum size of this container.  If the minimum size has
 not been set explicitly by {@link Component#setMinimumSize(Dimension)}
 and this {@code Container} has a {@code non-null} {@link LayoutManager},
 then {@link LayoutManager#minimumLayoutSize(Container)}
 is used to calculate the minimum size.

 <p>Note: some implementations may cache the value returned from the
 {@code LayoutManager}.  Implementations that cache need not invoke
 {@code minimumLayoutSize} on the {@code LayoutManager} every time
 this method is invoked, rather the {@code LayoutManager} will only
 be queried after the {@code Container} becomes invalid.

 @return    an instance of <code>Dimension</code> that represents
                the minimum size of this container.
 @see       #getPreferredSize
 @see       #getMaximumSize
 @see       #getLayout
 @see       LayoutManager#minimumLayoutSize(Container)
 @see       Component#getMinimumSize
 @since     JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Dimension java.awt.Container.minimumSize()
<!-- END KEY -->
<!-- BEGIN DATA -->

 @deprecated As of JDK version 1.1,
 replaced by <code>getMinimumSize()</code>.

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Dimension java.awt.Container.getMaximumSize()
<!-- END KEY -->
<!-- BEGIN DATA -->

 Returns the maximum size of this container.  If the maximum size has
 not been set explicitly by {@link Component#setMaximumSize(Dimension)}
 and the {@link LayoutManager} installed on this {@code Container}
 is an instance of {@link LayoutManager2}, then
 {@link LayoutManager2#maximumLayoutSize(Container)}
 is used to calculate the maximum size.

 <p>Note: some implementations may cache the value returned from the
 {@code LayoutManager2}.  Implementations that cache need not invoke
 {@code maximumLayoutSize} on the {@code LayoutManager2} every time
 this method is invoked, rather the {@code LayoutManager2} will only
 be queried after the {@code Container} becomes invalid.

 @return    an instance of <code>Dimension</code> that represents
                the maximum size of this container.
 @see       #getPreferredSize
 @see       #getMinimumSize
 @see       #getLayout
 @see       LayoutManager2#maximumLayoutSize(Container)
 @see       Component#getMaximumSize

<!-- END DATA -->
<!-- BEGIN KEY -->
public float java.awt.Container.getAlignmentX()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns the alignment along the x axis.  This specifies how
 the component would like to be aligned relative to other 
 components.  The value should be a number between 0 and 1
 where 0 represents alignment along the origin, 1 is aligned
 the furthest away from the origin, 0.5 is centered, etc.

<!-- END DATA -->
<!-- BEGIN KEY -->
public float java.awt.Container.getAlignmentY()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns the alignment along the y axis.  This specifies how
 the component would like to be aligned relative to other 
 components.  The value should be a number between 0 and 1
 where 0 represents alignment along the origin, 1 is aligned
 the furthest away from the origin, 0.5 is centered, etc.

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.paint(Graphics g)
<!-- END KEY -->
<!-- BEGIN DATA -->

 Paints the container. This forwards the paint to any lightweight
 components that are children of this container. If this method is
 reimplemented, super.paint(g) should be called so that lightweight
 components are properly rendered. If a child component is entirely
 clipped by the current clipping setting in g, paint() will not be
 forwarded to that child.

 @param g the specified Graphics window
 @see   Component#update(Graphics)

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.update(Graphics g)
<!-- END KEY -->
<!-- BEGIN DATA -->

 Updates the container.  This forwards the update to any lightweight
 components that are children of this container.  If this method is
 reimplemented, super.update(g) should be called so that lightweight
 components are properly rendered.  If a child component is entirely
 clipped by the current clipping setting in g, update() will not be
 forwarded to that child.

 @param g the specified Graphics window
 @see   Component#update(Graphics)

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.print(Graphics g)
<!-- END KEY -->
<!-- BEGIN DATA -->

 Prints the container. This forwards the print to any lightweight
 components that are children of this container. If this method is
 reimplemented, super.print(g) should be called so that lightweight
 components are properly rendered. If a child component is entirely
 clipped by the current clipping setting in g, print() will not be
 forwarded to that child.

 @param g the specified Graphics window
 @see   Component#update(Graphics)

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.paintComponents(Graphics g)
<!-- END KEY -->
<!-- BEGIN DATA -->

 Paints each of the components in this container.
 @param     g   the graphics context.
 @see       Component#paint
 @see       Component#paintAll

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.printComponents(Graphics g)
<!-- END KEY -->
<!-- BEGIN DATA -->

 Prints each of the components in this container. 
 @param     g   the graphics context.
 @see       Component#print
 @see       Component#printAll

<!-- END DATA -->
<!-- BEGIN KEY -->
public synchronized void java.awt.Container.addContainerListener(ContainerListener l)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Adds the specified container listener to receive container events
 from this container.
 If l is null, no exception is thrown and no action is performed.
 <p>Refer to <a href="doc-files/AWTThreadIssues.html#ListenersThreads"
 >AWT Threading Issues</a> for details on AWT's threading model.

 @param    l the container listener

 @see #removeContainerListener
 @see #getContainerListeners

<!-- END DATA -->
<!-- BEGIN KEY -->
public synchronized void java.awt.Container.removeContainerListener(ContainerListener l)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Removes the specified container listener so it no longer receives
 container events from this container.
 If l is null, no exception is thrown and no action is performed.
 <p>Refer to <a href="doc-files/AWTThreadIssues.html#ListenersThreads"
 >AWT Threading Issues</a> for details on AWT's threading model.

 @param 	l the container listener

 @see #addContainerListener
 @see #getContainerListeners

<!-- END DATA -->
<!-- BEGIN KEY -->
public synchronized java.awt.event.ContainerListener[] java.awt.Container.getContainerListeners()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns an array of all the container listeners
 registered on this container.

 @return all of this container's <code>ContainerListener</code>s
         or an empty array if no container
         listeners are currently registered

 @see #addContainerListener
 @see #removeContainerListener
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public T[] java.awt.Container.getListeners(java.lang.Class<T> listenerType)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns an array of all the objects currently registered
 as <code><em>Foo</em>Listener</code>s
 upon this <code>Container</code>.
 <code><em>Foo</em>Listener</code>s are registered using the
 <code>add<em>Foo</em>Listener</code> method.

 <p>
 You can specify the <code>listenerType</code> argument
 with a class literal, such as
 <code><em>Foo</em>Listener.class</code>.
 For example, you can query a
 <code>Container</code> <code>c</code>
 for its container listeners with the following code:

 <pre>ContainerListener[] cls = (ContainerListener[])(c.getListeners(ContainerListener.class));</pre>

 If no such listeners exist, this method returns an empty array.

 @param listenerType the type of listeners requested; this parameter
          should specify an interface that descends from
          <code>java.util.EventListener</code>
 @return an array of all objects registered as
          <code><em>Foo</em>Listener</code>s on this container,
          or an empty array if no such listeners have been added
 @exception ClassCastException if <code>listenerType</code>
          doesn't specify a class or interface that implements
          <code>java.util.EventListener</code>

 @see #getContainerListeners

 @since 1.3

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void java.awt.Container.processEvent(AWTEvent e)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Processes events on this container. If the event is a
 <code>ContainerEvent</code>, it invokes the
 <code>processContainerEvent</code> method, else it invokes 
 its superclass's <code>processEvent</code>.
 <p>Note that if the event parameter is <code>null</code>
 the behavior is unspecified and may result in an
 exception.

 @param e the event

<!-- END DATA -->
<!-- BEGIN KEY -->
protected void java.awt.Container.processContainerEvent(ContainerEvent e)
<!-- END KEY -->
<!-- BEGIN DATA -->

 Processes container events occurring on this container by
 dispatching them to any registered ContainerListener objects.
 NOTE: This method will not be called unless container events
 are enabled for this component; this happens when one of the
 following occurs:
 <ul>
 <li>A ContainerListener object is registered via
     <code>addContainerListener</code>
 <li>Container events are enabled via <code>enableEvents</code>
 </ul>
 <p>Note that if the event parameter is <code>null</code>
 the behavior is unspecified and may result in an
 exception.

 @param e the container event
 @see Component#enableEvents

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.deliverEvent(Event e)
<!-- END KEY -->
<!-- BEGIN DATA -->
 @deprecated As of JDK version 1.1,
 replaced by <code>dispatchEvent(AWTEvent e)</code>

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Component java.awt.Container.getComponentAt(int x, int y)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Locates the component that contains the x,y position.  The
 top-most child component is returned in the case where there
 is overlap in the components.  This is determined by finding
 the component closest to the index 0 that claims to contain
 the given point via Component.contains(), except that Components
 which have native peers take precedence over those which do not
 (i.e., lightweight Components).

 @param x the <i>x</i> coordinate
 @param y the <i>y</i> coordinate
 @return null if the component does not contain the position.
 If there is no child component at the requested point and the 
 point is within the bounds of the container the container itself 
 is returned; otherwise the top-most child is returned.
 @see Component#contains
 @since JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Component java.awt.Container.locate(int x, int y)
<!-- END KEY -->
<!-- BEGIN DATA -->
 @deprecated As of JDK version 1.1,
 replaced by <code>getComponentAt(int, int)</code>.

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Component java.awt.Container.getComponentAt(Point p)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Gets the component that contains the specified point.
 @param      p   the point.
 @return     returns the component that contains the point,
                 or <code>null</code> if the component does 
                 not contain the point. 
 @see        Component#contains 
 @since      JDK1.1 

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Point java.awt.Container.getMousePosition(boolean allowChildren) throws java.awt.HeadlessException
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns the position of the mouse pointer in this <code>Container</code>'s
 coordinate space if the <code>Container</code> is under the mouse pointer,
 otherwise returns <code>null</code>.
 This method is similar to {@link Component#getMousePosition()} with the exception
 that it can take the <code>Container</code>'s children into account.
 If <code>allowChildren</code> is <code>false</code>, this method will return
 a non-null value only if the mouse pointer is above the <code>Container</code>
 directly, not above the part obscured by children.
 If <code>allowChildren</code> is <code>true</code>, this method returns
 a non-null value if the mouse pointer is above <code>Container</code> or any
 of its descendants.

 @exception HeadlessException if GraphicsEnvironment.isHeadless() returns true
 @param     allowChildren true if children should be taken into account
 @see       Component#getMousePosition
 @return    mouse coordinates relative to this <code>Component</code>, or null
 @since     1.5

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Component java.awt.Container.findComponentAt(int x, int y)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Locates the visible child component that contains the specified
 position.  The top-most child component is returned in the case 
 where there is overlap in the components.  If the containing child 
 component is a Container, this method will continue searching for 
 the deepest nested child component.  Components which are not
 visible are ignored during the search.<p>

 The findComponentAt method is different from getComponentAt in
 that getComponentAt only searches the Container's immediate
 children; if the containing component is a Container, 
 findComponentAt will search that child to find a nested component.

 @param x the <i>x</i> coordinate
 @param y the <i>y</i> coordinate
 @return null if the component does not contain the position.
 If there is no child component at the requested point and the 
 point is within the bounds of the container the container itself 
 is returned.
 @see Component#contains
 @see #getComponentAt
 @since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.Component java.awt.Container.findComponentAt(Point p)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Locates the visible child component that contains the specified
 point.  The top-most child component is returned in the case 
 where there is overlap in the components.  If the containing child 
 component is a Container, this method will continue searching for 
 the deepest nested child component.  Components which are not
 visible are ignored during the search.<p>

 The findComponentAt method is different from getComponentAt in
 that getComponentAt only searches the Container's immediate
 children; if the containing component is a Container, 
 findComponentAt will search that child to find a nested component.

 @param      p   the point.
 @return null if the component does not contain the position.
 If there is no child component at the requested point and the 
 point is within the bounds of the container the container itself 
 is returned.
 @see Component#contains
 @see #getComponentAt
 @since 1.2

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.addNotify()
<!-- END KEY -->
<!-- BEGIN DATA -->

 Makes this Container displayable by connecting it to
 a native screen resource.  Making a container displayable will
 cause all of its children to be made displayable.
 This method is called internally by the toolkit and should
 not be called directly by programs.
 @see Component#isDisplayable
 @see #removeNotify

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.removeNotify()
<!-- END KEY -->
<!-- BEGIN DATA -->

 Makes this Container undisplayable by removing its connection
 to its native screen resource.  Making a container undisplayable
 will cause all of its children to be made undisplayable. 
 This method is called by the toolkit internally and should
 not be called directly by programs.
 @see Component#isDisplayable
 @see #addNotify

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Container.isAncestorOf(Component c)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Checks if the component is contained in the component hierarchy of
 this container.
 @param c the component
 @return     <code>true</code> if it is an ancestor; 
             <code>false</code> otherwise.
 @since      JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
protected java.lang.String java.awt.Container.paramString()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns a string representing the state of this <code>Container</code>.
 This method is intended to be used only for debugging purposes, and the 
 content and format of the returned string may vary between 
 implementations. The returned string may be empty but may not be 
 <code>null</code>.

 @return    the parameter string of this container

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.list(PrintStream out, int indent)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Prints a listing of this container to the specified output 
 stream. The listing starts at the specified indentation. 
 <p>
 The immediate children of the container are printed with
 an indentation of <code>indent+1</code>.  The children
 of those children are printed at <code>indent+2</code>
 and so on.

 @param    out      a print stream
 @param    indent   the number of spaces to indent
 @see      Component#list(java.io.PrintStream, int)
 @since    JDK1.0

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.list(PrintWriter out, int indent)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Prints out a list, starting at the specified indentation,
 to the specified print writer.
 <p>
 The immediate children of the container are printed with
 an indentation of <code>indent+1</code>.  The children
 of those children are printed at <code>indent+2</code>
 and so on.

 @param    out      a print writer
 @param    indent   the number of spaces to indent
 @see      Component#list(java.io.PrintWriter, int)
 @since    JDK1.1

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.setFocusTraversalKeys(int id, java.util.Set<? extends java.awt.AWTKeyStroke> keystrokes)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Sets the focus traversal keys for a given traversal operation for this
 Container.
 <p>
 The default values for a Container's focus traversal keys are
 implementation-dependent. Sun recommends that all implementations for a
 particular native platform use the same default values. The
 recommendations for Windows and Unix are listed below. These
 recommendations are used in the Sun AWT implementations.

 <table border=1 summary="Recommended default values for a Container's focus traversal keys">
 <tr>
    <th>Identifier</th>
    <th>Meaning</th>
    <th>Default</th>
 </tr>
 <tr>
    <td>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</td>
    <td>Normal forward keyboard traversal</td>
    <td>TAB on KEY_PRESSED, CTRL-TAB on KEY_PRESSED</td>
 </tr>
 <tr>
    <td>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS</td>
    <td>Normal reverse keyboard traversal</td>
    <td>SHIFT-TAB on KEY_PRESSED, CTRL-SHIFT-TAB on KEY_PRESSED</td>
 </tr>
 <tr>
    <td>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS</td>
    <td>Go up one focus traversal cycle</td>
    <td>none</td>
 </tr>
 <tr>
    <td>KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS<td>
    <td>Go down one focus traversal cycle</td>
    <td>none</td>
 </tr>
 </table>

 To disable a traversal key, use an empty Set; Collections.EMPTY_SET is
 recommended.
 <p>
 Using the AWTKeyStroke API, client code can specify on which of two
 specific KeyEvents, KEY_PRESSED or KEY_RELEASED, the focus traversal
 operation will occur. Regardless of which KeyEvent is specified,
 however, all KeyEvents related to the focus traversal key, including the
 associated KEY_TYPED event, will be consumed, and will not be dispatched
 to any Container. It is a runtime error to specify a KEY_TYPED event as
 mapping to a focus traversal operation, or to map the same event to
 multiple default focus traversal operations.
 <p>
 If a value of null is specified for the Set, this Container inherits the
 Set from its parent. If all ancestors of this Container have null
 specified for the Set, then the current KeyboardFocusManager's default
 Set is used.

 @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
 @param keystrokes the Set of AWTKeyStroke for the specified operation
 @see #getFocusTraversalKeys
 @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
 @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
 @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
 @see KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS
 @throws IllegalArgumentException if id is not one of
         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS, or if keystrokes
         contains null, or if any Object in keystrokes is not an
         AWTKeyStroke, or if any keystroke represents a KEY_TYPED event,
         or if any keystroke already maps to another focus traversal
         operation for this Container
 @since 1.4
 @beaninfo
       bound: true

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.util.Set<java.awt.AWTKeyStroke> java.awt.Container.getFocusTraversalKeys(int id)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns the Set of focus traversal keys for a given traversal operation
 for this Container. (See
 <code>setFocusTraversalKeys</code> for a full description of each key.)
 <p>
 If a Set of traversal keys has not been explicitly defined for this
 Container, then this Container's parent's Set is returned. If no Set
 has been explicitly defined for any of this Container's ancestors, then
 the current KeyboardFocusManager's default Set is returned.

 @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
 @return the Set of AWTKeyStrokes for the specified operation. The Set
         will be unmodifiable, and may be empty. null will never be
         returned.
 @see #setFocusTraversalKeys
 @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
 @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
 @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
 @see KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS
 @throws IllegalArgumentException if id is not one of
         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Container.areFocusTraversalKeysSet(int id)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns whether the Set of focus traversal keys for the given focus
 traversal operation has been explicitly defined for this Container. If
 this method returns <code>false</code>, this Container is inheriting the
 Set from an ancestor, or from the current KeyboardFocusManager.

 @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
 @return <code>true</code> if the the Set of focus traversal keys for the
         given focus traversal operation has been explicitly defined for
         this Component; <code>false</code> otherwise.
 @throws IllegalArgumentException if id is not one of
         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Container.isFocusCycleRoot(Container container)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns whether the specified Container is the focus cycle root of this
 Container's focus traversal cycle. Each focus traversal cycle has only
 a single focus cycle root and each Container which is not a focus cycle
 root belongs to only a single focus traversal cycle. Containers which
 are focus cycle roots belong to two cycles: one rooted at the Container
 itself, and one rooted at the Container's nearest focus-cycle-root
 ancestor. This method will return <code>true</code> for both such
 Containers in this case.

 @param container the Container to be tested
 @return <code>true</code> if the specified Container is a focus-cycle-
         root of this Container; <code>false</code> otherwise
 @see #isFocusCycleRoot()
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.setFocusTraversalPolicy(FocusTraversalPolicy policy)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Sets the focus traversal policy that will manage keyboard traversal of
 this Container's children, if this Container is a focus cycle root. If
 the argument is null, this Container inherits its policy from its focus-
 cycle-root ancestor. If the argument is non-null, this policy will be 
 inherited by all focus-cycle-root children that have no keyboard-
 traversal policy of their own (as will, recursively, their focus-cycle-
 root children).
 <p>
 If this Container is not a focus cycle root, the policy will be
 remembered, but will not be used or inherited by this or any other
 Containers until this Container is made a focus cycle root.

 @param policy the new focus traversal policy for this Container
 @see #getFocusTraversalPolicy
 @see #setFocusCycleRoot
 @see #isFocusCycleRoot
 @since 1.4
 @beaninfo
       bound: true

<!-- END DATA -->
<!-- BEGIN KEY -->
public java.awt.FocusTraversalPolicy java.awt.Container.getFocusTraversalPolicy()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns the focus traversal policy that will manage keyboard traversal
 of this Container's children, or null if this Container is not a focus
 cycle root. If no traversal policy has been explicitly set for this
 Container, then this Container's focus-cycle-root ancestor's policy is
 returned. 

 @return this Container's focus traversal policy, or null if this
         Container is not a focus cycle root.
 @see #setFocusTraversalPolicy
 @see #setFocusCycleRoot
 @see #isFocusCycleRoot
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Container.isFocusTraversalPolicySet()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns whether the focus traversal policy has been explicitly set for
 this Container. If this method returns <code>false</code>, this
 Container will inherit its focus traversal policy from an ancestor.

 @return <code>true</code> if the focus traversal policy has been
         explicitly set for this Container; <code>false</code> otherwise.
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.setFocusCycleRoot(boolean focusCycleRoot)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Sets whether this Container is the root of a focus traversal cycle. Once
 focus enters a traversal cycle, typically it cannot leave it via focus
 traversal unless one of the up- or down-cycle keys is pressed. Normal
 traversal is limited to this Container, and all of this Container's
 descendants that are not descendants of inferior focus cycle roots. Note
 that a FocusTraversalPolicy may bend these restrictions, however. For
 example, ContainerOrderFocusTraversalPolicy supports implicit down-cycle
 traversal.
 <p>
 The alternative way to specify the traversal order of this Container's 
 children is to make this Container a 
 <a href="doc-files/FocusSpec.html#FocusTraversalPolicyProviders">focus traversal policy provider</a>.  

 @param focusCycleRoot indicates whether this Container is the root of a
        focus traversal cycle
 @see #isFocusCycleRoot()
 @see #setFocusTraversalPolicy
 @see #getFocusTraversalPolicy
 @see ContainerOrderFocusTraversalPolicy
 @see #setFocusTraversalPolicyProvider
 @since 1.4
 @beaninfo
       bound: true

<!-- END DATA -->
<!-- BEGIN KEY -->
public boolean java.awt.Container.isFocusCycleRoot()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns whether this Container is the root of a focus traversal cycle.
 Once focus enters a traversal cycle, typically it cannot leave it via
 focus traversal unless one of the up- or down-cycle keys is pressed.
 Normal traversal is limited to this Container, and all of this
 Container's descendants that are not descendants of inferior focus
 cycle roots. Note that a FocusTraversalPolicy may bend these
 restrictions, however. For example, ContainerOrderFocusTraversalPolicy
 supports implicit down-cycle traversal.

 @return whether this Container is the root of a focus traversal cycle
 @see #setFocusCycleRoot
 @see #setFocusTraversalPolicy
 @see #getFocusTraversalPolicy
 @see ContainerOrderFocusTraversalPolicy
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public final void java.awt.Container.setFocusTraversalPolicyProvider(boolean provider)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Sets whether this container will be used to provide focus
 traversal policy. Container with this property as
 <code>true</code> will be used to acquire focus traversal policy
 instead of closest focus cycle root ancestor.
 @param provider indicates whether this container will be used to
                provide focus traversal policy
 @see #setFocusTraversalPolicy
 @see #getFocusTraversalPolicy     
 @see #isFocusTraversalPolicyProvider
 @since 1.5
 @beaninfo
        bound: true

<!-- END DATA -->
<!-- BEGIN KEY -->
public final boolean java.awt.Container.isFocusTraversalPolicyProvider()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Returns whether this container provides focus traversal
 policy. If this property is set to <code>true</code> then when
 keyboard focus manager searches container hierarchy for focus
 traversal policy and encounters this container before any other
 container with this property as true or focus cycle roots then
 its focus traversal policy will be used instead of focus cycle
 root's policy.
 @see #setFocusTraversalPolicy
 @see #getFocusTraversalPolicy     
 @see #setFocusCycleRoot
 @see #setFocusTraversalPolicyProvider
 @return <code>true</code> if this container provides focus traversal
         policy, <code>false</code> otherwise
 @since 1.5
 @beaninfo
        bound: true

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.transferFocusDownCycle()
<!-- END KEY -->
<!-- BEGIN DATA -->
 Transfers the focus down one focus traversal cycle. If this Container is
 a focus cycle root, then the focus owner is set to this Container's
 default Component to focus, and the current focus cycle root is set to
 this Container. If this Container is not a focus cycle root, then no
 focus traversal operation occurs.

 @see       Component#requestFocus()
 @see       #isFocusCycleRoot
 @see       #setFocusCycleRoot
 @since     1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.applyComponentOrientation(ComponentOrientation o)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Sets the <code>ComponentOrientation</code> property of this container
 and all components contained within it.

 @param o the new component orientation of this container and
        the components contained within it.
 @exception NullPointerException if <code>orientation</code> is null.
 @see Component#setComponentOrientation
 @see Component#getComponentOrientation
 @since 1.4

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.addPropertyChangeListener(PropertyChangeListener listener)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Adds a PropertyChangeListener to the listener list. The listener is
 registered for all bound properties of this class, including the
 following:
 <ul>
    <li>this Container's font ("font")</li>
    <li>this Container's background color ("background")</li>
    <li>this Container's foreground color ("foreground")</li>
    <li>this Container's focusability ("focusable")</li>
    <li>this Container's focus traversal keys enabled state
        ("focusTraversalKeysEnabled")</li>
    <li>this Container's Set of FORWARD_TRAVERSAL_KEYS
        ("forwardFocusTraversalKeys")</li>
    <li>this Container's Set of BACKWARD_TRAVERSAL_KEYS
        ("backwardFocusTraversalKeys")</li>
    <li>this Container's Set of UP_CYCLE_TRAVERSAL_KEYS
        ("upCycleFocusTraversalKeys")</li>
    <li>this Container's Set of DOWN_CYCLE_TRAVERSAL_KEYS
        ("downCycleFocusTraversalKeys")</li>
    <li>this Container's focus traversal policy ("focusTraversalPolicy")
        </li>
    <li>this Container's focus-cycle-root state ("focusCycleRoot")</li>
 </ul>
 Note that if this Container is inheriting a bound property, then no
 event will be fired in response to a change in the inherited property.
 <p>
 If listener is null, no exception is thrown and no action is performed.

 @param    listener  the PropertyChangeListener to be added

 @see Component#removePropertyChangeListener
 @see #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)

<!-- END DATA -->
<!-- BEGIN KEY -->
public void java.awt.Container.addPropertyChangeListener(String propertyName, PropertyChangeListener listener)
<!-- END KEY -->
<!-- BEGIN DATA -->
 Adds a PropertyChangeListener to the listener list for a specific
 property. The specified property may be user-defined, or one of the
 following defaults:
 <ul>
    <li>this Container's font ("font")</li>
    <li>this Container's background color ("background")</li>
    <li>this Container's foreground color ("foreground")</li>
    <li>this Container's focusability ("focusable")</li>
    <li>this Container's focus traversal keys enabled state
        ("focusTraversalKeysEnabled")</li>
    <li>this Container's Set of FORWARD_TRAVERSAL_KEYS
        ("forwardFocusTraversalKeys")</li>
    <li>this Container's Set of BACKWARD_TRAVERSAL_KEYS
        ("backwardFocusTraversalKeys")</li>
    <li>this Container's Set of UP_CYCLE_TRAVERSAL_KEYS
        ("upCycleFocusTraversalKeys")</li>
    <li>this Container's Set of DOWN_CYCLE_TRAVERSAL_KEYS
        ("downCycleFocusTraversalKeys")</li>
    <li>this Container's focus traversal policy ("focusTraversalPolicy")
        </li>
    <li>this Container's focus-cycle-root state ("focusCycleRoot")</li>
    <li>this Container's focus-traversal-policy-provider state("focusTraversalPolicyProvider")</li>
    <li>this Container's focus-traversal-policy-provider state("focusTraversalPolicyProvider")</li>
 </ul>
 Note that if this Container is inheriting a bound property, then no
 event will be fired in response to a change in the inherited property.
 <p>
 If listener is null, no exception is thrown and no action is performed.

 @param propertyName one of the property names listed above
 @param listener the PropertyChangeListener to be added

 @see #addPropertyChangeListener(java.beans.PropertyChangeListener)
 @see Component#removePropertyChangeListener

<!-- END DATA -->
<!-- BEGIN KEY -->
private void java.awt.Container.readObject(ObjectInputStream s) throws java.lang.ClassNotFoundException, java.io.IOException
<!-- END KEY -->
<!-- BEGIN DATA -->
 Deserializes this <code>Container</code> from the specified
 <code>ObjectInputStream</code>.
 <ul>
    <li>Reads default serializable fields from the stream.</li>
    <li>Reads a list of serializable ContainerListener(s) as optional
        data. If the list is null, no Listeners are installed.</li>
    <li>Reads this Container's FocusTraversalPolicy, which may be null,
        as optional data.</li>
 </ul>

 @param s the <code>ObjectInputStream</code> to read
 @serial
 @see #addContainerListener
 @see #writeObject(ObjectOutputStream)

<!-- END DATA -->
<!-- BEGIN KEY -->
private void java.awt.Container.writeObject(ObjectOutputStream s) throws java.io.IOException
<!-- END KEY -->
<!-- BEGIN DATA -->
 Serializes this <code>Container</code> to the specified
 <code>ObjectOutputStream</code>.
 <ul>
    <li>Writes default serializable fields to the stream.</li>
    <li>Writes a list of serializable ContainerListener(s) as optional
        data. The non-serializable ContainerListner(s) are detected and
        no attempt is made to serialize them.</li>
    <li>Write this Container's FocusTraversalPolicy if and only if it
        is Serializable; otherwise, <code>null</code> is written.</li>
 </ul>

 @param s the <code>ObjectOutputStream</code> to write
 @serialData <code>null</code> terminated sequence of 0 or more pairs;
   the pair consists of a <code>String</code> and <code>Object</code>;
   the <code>String</code> indicates the type of object and
   is one of the following:
   <code>containerListenerK</code> indicating an
     <code>ContainerListener</code> object;
   the <code>Container</code>'s <code>FocusTraversalPolicy</code>,
     or <code>null</code>

 @see AWTEventMulticaster#save(java.io.ObjectOutputStream, java.lang.String, java.util.EventListener)
 @see Container#containerListenerK
 @see #readObject(ObjectInputStream)

<!-- END DATA -->
